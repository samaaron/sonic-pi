class:: ElementaryCA
summary:: An audio rate additive synthesis signal generated by simulating an elementary cellular automaton
related:: Classes/Flock
categories:: UGens>Generators>Deterministic

Description::
The input and output of an elementary cellular automaton can be represented as a grid of 1s and 0s, where the first row is the row of initial 'seed values', and each subsequent row represents a new generation of values created by transforming the previous row based on a particular set of rules. This UGen leverages this to create an audio signal by linking each 'cell' of the automaton to a particular partial frequency and treating the cell values as boolean flags that determine whether or not a particular partial is to be added into the final output.
As well as allowing the user to specify the fundamental frequency, the Ugen allows customisation of a handful of parameters including the quantity, position in the frequency domain and amplitude profile of additional partials.

note::
The encoded_partials parameter is a workaround to allow the Sonic Pi live coding environment to specify the array of initial 'binary' input values for the automaton by encoding them in a single integer number.
::

Classmethods::

method::ar

argument::bufnum
The id of a buffer containing a collection of numbers treated as the source of a deterministic random number generator.

argument::freq
The fundamental frequency of the final output signal. Valid values are numbers greater than 0.

argument::wolfram_code
The code used to identify which of the 256 elementary cellular automata to simulate. Valid values are the integers between 0 and 255 inclusively.

argument::num_columns
The number of columns in the automaton's simulated 'grid'. Valid values are numbers greater than 0. The result of multiplying num_columns and num_rows must be no more than 100, and is used in determining the maximum number of potential partials in the final output signal. 

argument::num_rows
The number of rows in the automaton's simulated 'grid'. Valid values are numbers greater than 0. The result of multiplying num_columns and num_rows must be no more than 100, and is used in determining the maximum number of potential partials in the final output signal.

argument::encoded_partials
This is a number that encodes a list of binary digits representing the initial 'seed values' of the automaton. It should encode a list whose length is the same as the value of the num_columns parameter. For example, when num_columns is 8, a value for encoded_partials of 255 is valid since it decodes to a list of eight 1s.

argument::seed
A number used to deterministically offset an index into the random number buffer values.

argument::width
The proportional width between each possible partial in the frequency domain. A value of 1 produces successive partials that are each an octave higher than the previous one. Valid values are numbers between 0 and 2 inclusively.

argument::odd_skew
The amount by which odd partials are skewed away from the position derived from width. Valid values are between -0.99 and 0.99 inclusively.

argument::even_skew
The amount by which even partials are skewed away from the position derived from width. Valid values are between -0.99 and 0.99 inclusively.

argument::amp_tilt
A value that controls the amplitude decay envelope of the partials as a whole. Values below 1 begin tilting the envelope towards a positive (upwards) slope. Values above 1 increase the negative (downwards) slope. Valid values are between -1 and 3 inclusively.

argument::balance
A value that cuts the amplitude of either the odd or even partials. Valid values are between -1 and 1 inclusively.

argument::randomise
A flag that indicates whether or not to randomly choose the first few partials. Valid values are either 0 or 1.

Examples::

code::
// Create a buffer of random numbers for the deterministic random number generator
b = Buffer.alloc(s, 44100);
v = FloatArray.fill(44100, {1.0.rand});
b.loadCollection(v);
/*
  Generate a signal using elementary cellular automaton #110,
  using a number encoding the list of binary values [1,0,1,1,0,1,1,1].
  (Note the randomise parameter is set to 0 (ie, 'off') -
  The encoded array of binary values is therefore used as the initial input to
  the automaton, instead of having those values chosen randomly).
*/
{
  var env, snd;
  env = Env.new([0, 1, 1, 1, 0], [0, 0, 5, 0], 2);
  snd = ElementaryCA.ar(b.bufnum, 440.0, 110, 8, 2, 183, 0, 1, 0, 0, 1, 0, 0);
  snd = Pan2.ar(snd * EnvGen.ar(env, doneAction: 2), 0);
}.play;
// Display the frequencies with the frequency scope.
FreqScope.new(512, 300, 0, server: s);

/*
  Generate a signal using elementary cellular automaton #30,
  containing 40 total frequency components (fundamental and partials),
  using randomly chosen values for the input of the automaton.
  (Note that the encoded_partials parameter is ignored).
*/
{
  var env, snd;
  env = Env.new([0, 1, 1, 1, 0], [0, 0, 5, 0], 2);
  snd = ElementaryCA.ar(b.bufnum, 440.0, 30, 8, 5, 255, 0, 1, 0, 0, 1, 0, 1);
  snd = Pan2.ar(snd * EnvGen.ar(env, doneAction: 2), 0);
}.play;
// Display the frequencies with the frequency scope.
FreqScope.new(512, 300, 0, server: s);

/*
  Generate a signal using elementary cellular automaton #90,
  using randomly chosen values for the input of the automaton,
  by indexing into the random number buffer using the seed (offset) of 1234,
  and shifting all odd numbered partials slightly to the left in the frequency domain.
*/
{
  var env, snd;
  env = Env.new([0, 1, 1, 1, 0], [0, 0, 5, 0], 2);
  snd = ElementaryCA.ar(b.bufnum, 440.0, 90, 8, 2, 255, 1234, 1, -0.05, 0, 1, 0, 1);
  snd = Pan2.ar(snd * EnvGen.ar(env, doneAction: 2), 0);
}.play;
// Display the frequencies with the frequency scope.
FreqScope.new(512, 300, 0, server: s);

// Free the memory used by the random number buffer.
b.free;
::
