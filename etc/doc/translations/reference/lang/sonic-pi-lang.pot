  # This file is distributed under the same license as the Sonic Pi package.
  # Do not edit this file, use Weblate instead.
  # Read TRANSLATION.md for more information.

  msgid ""
  msgstr ""
  "Project-Id-Version: Sonic Pi\n"
  "MIME-Version: 1.0\n"
  "Content-Type: text/plain; charset=UTF-8\n"
  "Content-Transfer-Encoding: 8bit\n"

#: all_sample_names.md:9
msgid "Return a list of all the sample names available"
msgstr ""

#: all_sample_names.md:11 choose.md:15 chord.md:11 comment.md:11 control.md:13
#: cue.md:11 current_arg_checks.md:13 current_bpm.md:13 current_debug.md:13
#: current_sched_ahead_time.md:13 current_synth.md:13
#: current_synth_defaults.md:13 current_transpose.md:13 current_volume.md:13
#: define.md:11 defonce.md:11 dice.md:11 hz_to_midi.md:11 in_thread.md:14
#: kill.md:11 load_sample.md:13 load_samples.md:13 load_synthdefs.md:33
#: loop.md:15 midi_to_hz.md:11 note.md:11 note_info.md:11 one_in.md:11
#: play.md:20 play_chord.md:13 play_pattern.md:13 play_pattern_timed.md:15
#: print.md:11 puts.md:11 rand.md:11 rand_i.md:11 rrand.md:11 rrand_i.md:11
#: rt.md:11 sample.md:34 sample_buffer.md:11 sample_duration.md:13
#: sample_groups.md:11 sample_info.md:11 sample_names.md:11 scale.md:11
#: set_sched_ahead_time!.md:11 set_volume!.md:11 sleep.md:11 status.md:11
#: sync.md:11 synth.md:19 uncomment.md:11 use_arg_bpm_scaling.md:11
#: use_arg_checks.md:11 use_bpm.md:21 use_debug.md:11
#: use_merged_synth_defaults.md:11 use_random_seed.md:11 use_synth.md:11
#: use_synth_defaults.md:11 use_transpose.md:11 version.md:11 wait.md:11
#: with_arg_bpm_scaling.md:11 with_arg_checks.md:11 with_bpm.md:22
#: with_debug.md:11 with_fx.md:13 with_merged_synth_defaults.md:11
#: with_random_seed.md:11 with_synth.md:11 with_synth_defaults.md:11
#: with_transpose.md:11
msgid "Introduced in v2.0"
msgstr ""

#: assert.md:9
msgid "Raises an exception if the argument is either nil or false."
msgstr ""

#: assert.md:11 assert_equal.md:11 bt.md:11 octs.md:11
msgid "Introduced in v2.8"
msgstr ""

#: assert.md:13 assert_equal.md:13 assert_error.md:13 assert_not.md:13
#: assert_not_equal.md:13 assert_similar.md:17 at.md:17 block_duration.md:13
#: block_slept?.md:13 bools.md:13 buffer.md:13 choose.md:17 chord.md:13
#: chord_degree.md:13 control.md:15 cue.md:13 current_random_seed.md:15
#: current_time.md:15 current_volume.md:15 dec.md:13 defonce.md:13 degree.md:13
#: density.md:13 dice.md:13 doubles.md:13 factor?.md:13 get.md:15 halves.md:13
#: in_thread.md:16 inc.md:13 kill.md:13 knit.md:13 line.md:13 live_audio.md:23
#: live_loop.md:24 load_sample.md:15 load_samples.md:15 look.md:13 map.md:13
#: mc_block_id.md:13 mc_block_name.md:13 mc_location.md:13 midi.md:16
#: midi_all_notes_off.md:18 midi_cc.md:20 midi_channel_pressure.md:20
#: midi_clock_beat.md:16 midi_local_control_off.md:18
#: midi_local_control_on.md:18 midi_mode.md:25 midi_note_off.md:22
#: midi_note_on.md:22 midi_notes.md:13 midi_pc.md:18 midi_pitch_bend.md:23
#: midi_poly_pressure.md:20 midi_raw.md:18 midi_reset.md:18
#: midi_sound_off.md:18 note.md:13 note_range.md:13 octs.md:13 on.md:13
#: one_in.md:13 osc.md:43 osc_send.md:15 pick.md:19 pitch_to_ratio.md:13
#: play.md:22 play_chord.md:15 play_pattern.md:15 play_pattern_timed.md:17
#: print.md:13 puts.md:13 quantise.md:13 ramp.md:13 rand_back.md:13
#: rand_i_look.md:15 rand_look.md:15 rand_skip.md:13 range.md:13
#: ratio_to_pitch.md:13 rdist.md:13 reset.md:13 rest?.md:13 ring.md:13
#: rrand.md:13 rrand_i.md:13 run_code.md:13 sample.md:36 sample_duration.md:15
#: sample_free.md:15 sample_paths.md:13 scale.md:13 set.md:15
#: set_audio_latency!.md:15 set_volume!.md:13 shuffle.md:13 sleep.md:13
#: spark.md:13 spark_graph.md:13 spread.md:13 stop.md:13 stretch.md:13
#: sync.md:13 synth.md:21 tick.md:13 tick_reset.md:13 tick_set.md:13
#: time_warp.md:23 use_arg_bpm_scaling.md:13 use_cue_logging.md:13
#: use_debug.md:13 use_merged_synth_defaults.md:13 use_midi_logging.md:13
#: use_octave.md:13 use_osc.md:23 use_osc_logging.md:13 use_random_seed.md:13
#: use_sample_bpm.md:13 use_sched_ahead_time.md:17 use_timing_guarantees.md:13
#: use_transpose.md:13 use_tuning.md:13 vector.md:13 version.md:13
#: with_arg_bpm_scaling.md:13 with_fx.md:15 with_merged_synth_defaults.md:13
#: with_random_seed.md:13 with_sample_bpm.md:13 with_swing.md:13
#: with_timing_guarantees.md:13
msgid "## Examples"
msgstr ""

#: assert.md:15 assert_equal.md:15 assert_error.md:15 assert_not.md:15
#: assert_not_equal.md:15 assert_similar.md:19 at.md:19 beat.md:15
#: block_duration.md:15 block_slept?.md:15 bools.md:15 bt.md:15 buffer.md:15
#: choose.md:19 chord.md:15 chord_degree.md:15 chord_invert.md:19
#: chord_names.md:15 clear.md:15 comment.md:15 control.md:17 cue.md:15
#: current_arg_checks.md:17 current_beat_duration.md:17 current_bpm.md:17
#: current_cent_tuning.md:17 current_debug.md:17 current_midi_defaults.md:17
#: current_octave.md:17 current_random_seed.md:17 current_sample_defaults.md:17
#: current_sched_ahead_time.md:17 current_synth.md:17
#: current_synth_defaults.md:17 current_time.md:17 current_transpose.md:17
#: current_volume.md:17 dec.md:15 define.md:15 defonce.md:15 degree.md:15
#: density.md:15 dice.md:15 doubles.md:15 eval_file.md:15 factor?.md:15
#: get.md:17 halves.md:15 hz_to_midi.md:15 in_thread.md:18 inc.md:15 kill.md:15
#: knit.md:15 line.md:15 live_audio.md:25 live_loop.md:26 load_buffer.md:15
#: load_example.md:15 load_sample.md:17 load_samples.md:17 load_synthdefs.md:37
#: look.md:15 loop.md:19 map.md:15 mc_block_id.md:15 mc_block_ids.md:15
#: mc_block_name.md:15 mc_block_names.md:15 mc_camera_fixed.md:15
#: mc_camera_normal.md:15 mc_camera_set_location.md:15
#: mc_camera_third_person.md:15 mc_checkpoint_restore.md:15
#: mc_checkpoint_save.md:15 mc_get_block.md:15 mc_get_tile.md:15
#: mc_ground_height.md:15 mc_location.md:15 mc_message.md:15 mc_set_block.md:15
#: mc_set_tile.md:15 mc_surface_teleport.md:15 mc_teleport.md:15 midi.md:18
#: midi_all_notes_off.md:20 midi_cc.md:22 midi_channel_pressure.md:22
#: midi_clock_beat.md:18 midi_clock_tick.md:20 midi_continue.md:20
#: midi_local_control_off.md:20 midi_local_control_on.md:20 midi_mode.md:27
#: midi_note_off.md:24 midi_note_on.md:24 midi_notes.md:15 midi_pc.md:20
#: midi_pitch_bend.md:25 midi_poly_pressure.md:22 midi_raw.md:20
#: midi_reset.md:20 midi_sound_off.md:20 midi_start.md:20 midi_stop.md:20
#: midi_sysex.md:22 midi_to_hz.md:15 note.md:15 note_info.md:15
#: note_range.md:15 octs.md:15 on.md:15 one_in.md:15 osc.md:45 osc_send.md:17
#: pick.md:21 pitch_to_ratio.md:15 play.md:24 play_chord.md:17
#: play_pattern.md:17 play_pattern_timed.md:19 print.md:15 puts.md:15
#: quantise.md:15 ramp.md:15 rand.md:15 rand_back.md:15 rand_i.md:15
#: rand_i_look.md:17 rand_look.md:17 rand_reset.md:15 rand_skip.md:15
#: range.md:15 ratio_to_pitch.md:15 rdist.md:15 reset.md:15 reset_mixer!.md:15
#: rest?.md:15 ring.md:15 rrand.md:15 rrand_i.md:15 rt.md:15 run_code.md:15
#: run_file.md:15 sample.md:38 sample_buffer.md:15 sample_duration.md:17
#: sample_free.md:17 sample_free_all.md:15 sample_info.md:15
#: sample_loaded?.md:15 sample_paths.md:15 scale.md:15 scale_names.md:15
#: scsynth_info.md:15 set.md:17 set_audio_latency!.md:17 set_cent_tuning!.md:21
#: set_control_delta!.md:15 set_mixer_control!.md:15
#: set_recording_bit_depth!.md:15 set_sched_ahead_time!.md:15 set_volume!.md:15
#: shuffle.md:15 sleep.md:15 spark.md:15 spark_graph.md:15 spread.md:15
#: status.md:15 stop.md:15 stretch.md:15 sync.md:15 sync_bpm.md:15 synth.md:23
#: tick.md:15 tick_reset.md:15 tick_reset_all.md:15 tick_set.md:15
#: time_warp.md:25 uncomment.md:15 use_arg_bpm_scaling.md:15
#: use_arg_checks.md:15 use_bpm.md:25 use_bpm_mul.md:15 use_cent_tuning.md:17
#: use_cue_logging.md:15 use_debug.md:15 use_merged_midi_defaults.md:15
#: use_merged_sample_defaults.md:15 use_merged_synth_defaults.md:15
#: use_midi_defaults.md:15 use_midi_logging.md:15 use_octave.md:15
#: use_osc.md:25 use_osc_logging.md:15 use_random_seed.md:15
#: use_random_source.md:36 use_real_time.md:20 use_sample_bpm.md:15
#: use_sample_defaults.md:15 use_sched_ahead_time.md:19 use_synth.md:15
#: use_synth_defaults.md:15 use_timing_guarantees.md:15 use_transpose.md:15
#: use_tuning.md:15 vector.md:15 version.md:15 vt.md:15
#: with_arg_bpm_scaling.md:15 with_arg_checks.md:15 with_bpm.md:26
#: with_bpm_mul.md:15 with_cent_tuning.md:15 with_cue_logging.md:15
#: with_debug.md:15 with_fx.md:17 with_merged_midi_defaults.md:15
#: with_merged_sample_defaults.md:15 with_merged_synth_defaults.md:15
#: with_midi_defaults.md:15 with_midi_logging.md:15 with_octave.md:15
#: with_osc.md:15 with_osc_logging.md:15 with_random_seed.md:15
#: with_random_source.md:15 with_real_time.md:21 with_sample_bpm.md:15
#: with_sample_defaults.md:15 with_sched_ahead_time.md:19 with_swing.md:15
#: with_synth.md:15 with_synth_defaults.md:15 with_timing_guarantees.md:15
#: with_transpose.md:15 with_tuning.md:15
msgid "<table class=\"examples\">"
msgstr ""

#: assert.md:16 assert.md:19 assert_equal.md:16 assert_equal.md:19
#: assert_error.md:16 assert_error.md:19 assert_not.md:16 assert_not.md:19
#: assert_not_equal.md:16 assert_not_equal.md:19 assert_similar.md:20
#: assert_similar.md:23 at.md:20 at.md:23 beat.md:16 beat.md:19
#: block_duration.md:16 block_duration.md:19 block_slept?.md:16
#: block_slept?.md:19 bools.md:16 bools.md:19 bt.md:16 bt.md:19 buffer.md:16
#: buffer.md:19 choose.md:20 choose.md:23 chord.md:16 chord.md:19
#: chord_degree.md:16 chord_degree.md:19 chord_invert.md:20 chord_invert.md:23
#: chord_names.md:16 chord_names.md:19 clear.md:16 clear.md:19 comment.md:16
#: comment.md:19 control.md:18 control.md:21 cue.md:16 cue.md:19
#: current_arg_checks.md:18 current_arg_checks.md:21
#: current_beat_duration.md:18 current_beat_duration.md:21 current_bpm.md:18
#: current_bpm.md:21 current_cent_tuning.md:18 current_cent_tuning.md:21
#: current_debug.md:18 current_debug.md:21 current_midi_defaults.md:18
#: current_midi_defaults.md:21 current_octave.md:18 current_octave.md:21
#: current_random_seed.md:18 current_random_seed.md:21
#: current_sample_defaults.md:18 current_sample_defaults.md:21
#: current_sched_ahead_time.md:18 current_sched_ahead_time.md:21
#: current_synth.md:18 current_synth.md:21 current_synth_defaults.md:18
#: current_synth_defaults.md:21 current_time.md:18 current_time.md:21
#: current_transpose.md:18 current_transpose.md:21 current_volume.md:18
#: current_volume.md:21 dec.md:16 dec.md:19 define.md:16 define.md:19
#: defonce.md:16 defonce.md:19 degree.md:16 degree.md:19 density.md:16
#: density.md:19 dice.md:16 dice.md:19 doubles.md:16 doubles.md:19
#: eval_file.md:16 eval_file.md:19 factor?.md:16 factor?.md:19 get.md:18
#: get.md:21 halves.md:16 halves.md:19 hz_to_midi.md:16 hz_to_midi.md:19
#: in_thread.md:19 in_thread.md:22 inc.md:16 inc.md:19 kill.md:16 kill.md:19
#: knit.md:16 knit.md:19 line.md:16 line.md:19 live_audio.md:26
#: live_audio.md:29 live_loop.md:27 live_loop.md:30 load_buffer.md:16
#: load_buffer.md:19 load_example.md:16 load_example.md:19 load_sample.md:18
#: load_sample.md:21 load_samples.md:18 load_samples.md:21 load_synthdefs.md:38
#: load_synthdefs.md:41 look.md:16 look.md:19 loop.md:20 loop.md:23 map.md:16
#: map.md:19 mc_block_id.md:16 mc_block_id.md:19 mc_block_ids.md:16
#: mc_block_ids.md:19 mc_block_name.md:16 mc_block_name.md:19
#: mc_block_names.md:16 mc_block_names.md:19 mc_camera_fixed.md:16
#: mc_camera_fixed.md:19 mc_camera_normal.md:16 mc_camera_normal.md:19
#: mc_camera_set_location.md:16 mc_camera_set_location.md:19
#: mc_camera_third_person.md:16 mc_camera_third_person.md:19
#: mc_checkpoint_restore.md:16 mc_checkpoint_restore.md:19
#: mc_checkpoint_save.md:16 mc_checkpoint_save.md:19 mc_get_block.md:16
#: mc_get_block.md:19 mc_get_tile.md:16 mc_get_tile.md:19
#: mc_ground_height.md:16 mc_ground_height.md:19 mc_location.md:16
#: mc_location.md:19 mc_message.md:16 mc_message.md:19 mc_set_block.md:16
#: mc_set_block.md:19 mc_set_tile.md:16 mc_set_tile.md:19
#: mc_surface_teleport.md:16 mc_surface_teleport.md:19 mc_teleport.md:16
#: mc_teleport.md:19 midi.md:19 midi.md:22 midi_all_notes_off.md:21
#: midi_all_notes_off.md:24 midi_cc.md:23 midi_cc.md:26
#: midi_channel_pressure.md:23 midi_channel_pressure.md:26
#: midi_clock_beat.md:19 midi_clock_beat.md:22 midi_clock_tick.md:21
#: midi_clock_tick.md:24 midi_continue.md:21 midi_continue.md:24
#: midi_local_control_off.md:21 midi_local_control_off.md:24
#: midi_local_control_on.md:21 midi_local_control_on.md:24 midi_mode.md:28
#: midi_mode.md:31 midi_note_off.md:25 midi_note_off.md:28 midi_note_on.md:25
#: midi_note_on.md:28 midi_notes.md:16 midi_notes.md:19 midi_pc.md:21
#: midi_pc.md:24 midi_pitch_bend.md:26 midi_pitch_bend.md:29
#: midi_poly_pressure.md:23 midi_poly_pressure.md:26 midi_raw.md:21
#: midi_raw.md:24 midi_reset.md:21 midi_reset.md:24 midi_sound_off.md:21
#: midi_sound_off.md:24 midi_start.md:21 midi_start.md:24 midi_stop.md:21
#: midi_stop.md:24 midi_sysex.md:23 midi_sysex.md:26 midi_to_hz.md:16
#: midi_to_hz.md:19 note.md:16 note.md:19 note_info.md:16 note_info.md:19
#: note_range.md:16 note_range.md:19 octs.md:16 octs.md:19 on.md:16 on.md:19
#: one_in.md:16 one_in.md:19 osc.md:46 osc.md:49 osc_send.md:18 osc_send.md:21
#: pick.md:22 pick.md:25 pitch_to_ratio.md:16 pitch_to_ratio.md:19 play.md:25
#: play.md:28 play_chord.md:18 play_chord.md:21 play_pattern.md:18
#: play_pattern.md:21 play_pattern_timed.md:20 play_pattern_timed.md:23
#: print.md:16 print.md:19 puts.md:16 puts.md:19 quantise.md:16 quantise.md:19
#: ramp.md:16 ramp.md:19 rand.md:16 rand.md:19 rand_back.md:16 rand_back.md:19
#: rand_i.md:16 rand_i.md:19 rand_i_look.md:18 rand_i_look.md:21
#: rand_look.md:18 rand_look.md:21 rand_reset.md:16 rand_reset.md:19
#: rand_skip.md:16 rand_skip.md:19 range.md:16 range.md:19 ratio_to_pitch.md:16
#: ratio_to_pitch.md:19 rdist.md:16 rdist.md:19 reset.md:16 reset.md:19
#: reset_mixer!.md:16 reset_mixer!.md:19 rest?.md:16 rest?.md:19 ring.md:16
#: ring.md:19 rrand.md:16 rrand.md:19 rrand_i.md:16 rrand_i.md:19 rt.md:16
#: rt.md:19 run_code.md:16 run_code.md:19 run_file.md:16 run_file.md:19
#: sample.md:39 sample.md:42 sample_buffer.md:16 sample_buffer.md:19
#: sample_duration.md:18 sample_duration.md:21 sample_free.md:18
#: sample_free.md:21 sample_free_all.md:16 sample_free_all.md:19
#: sample_info.md:16 sample_info.md:19 sample_loaded?.md:16
#: sample_loaded?.md:19 sample_paths.md:16 sample_paths.md:19 scale.md:16
#: scale.md:19 scale_names.md:16 scale_names.md:19 scsynth_info.md:16
#: scsynth_info.md:19 set.md:18 set.md:21 set_audio_latency!.md:18
#: set_audio_latency!.md:21 set_cent_tuning!.md:22 set_cent_tuning!.md:25
#: set_control_delta!.md:16 set_control_delta!.md:19 set_mixer_control!.md:16
#: set_mixer_control!.md:19 set_recording_bit_depth!.md:16
#: set_recording_bit_depth!.md:19 set_sched_ahead_time!.md:16
#: set_sched_ahead_time!.md:19 set_volume!.md:16 set_volume!.md:19
#: shuffle.md:16 shuffle.md:19 sleep.md:16 sleep.md:19 spark.md:16 spark.md:19
#: spark_graph.md:16 spark_graph.md:19 spread.md:16 spread.md:19 status.md:16
#: status.md:19 stop.md:16 stop.md:19 stretch.md:16 stretch.md:19 sync.md:16
#: sync.md:19 sync_bpm.md:16 sync_bpm.md:19 synth.md:24 synth.md:27 tick.md:16
#: tick.md:19 tick_reset.md:16 tick_reset.md:19 tick_reset_all.md:16
#: tick_reset_all.md:19 tick_set.md:16 tick_set.md:19 time_warp.md:26
#: time_warp.md:29 uncomment.md:16 uncomment.md:19 use_arg_bpm_scaling.md:16
#: use_arg_bpm_scaling.md:19 use_arg_checks.md:16 use_arg_checks.md:19
#: use_bpm.md:26 use_bpm.md:29 use_bpm_mul.md:16 use_bpm_mul.md:19
#: use_cent_tuning.md:18 use_cent_tuning.md:21 use_cue_logging.md:16
#: use_cue_logging.md:19 use_debug.md:16 use_debug.md:19
#: use_merged_midi_defaults.md:16 use_merged_midi_defaults.md:19
#: use_merged_sample_defaults.md:16 use_merged_sample_defaults.md:19
#: use_merged_synth_defaults.md:16 use_merged_synth_defaults.md:19
#: use_midi_defaults.md:16 use_midi_defaults.md:19 use_midi_logging.md:16
#: use_midi_logging.md:19 use_octave.md:16 use_octave.md:19 use_osc.md:26
#: use_osc.md:29 use_osc_logging.md:16 use_osc_logging.md:19
#: use_random_seed.md:16 use_random_seed.md:19 use_random_source.md:37
#: use_random_source.md:40 use_real_time.md:21 use_real_time.md:24
#: use_sample_bpm.md:16 use_sample_bpm.md:19 use_sample_defaults.md:16
#: use_sample_defaults.md:19 use_sched_ahead_time.md:20
#: use_sched_ahead_time.md:23 use_synth.md:16 use_synth.md:19
#: use_synth_defaults.md:16 use_synth_defaults.md:19
#: use_timing_guarantees.md:16 use_timing_guarantees.md:19 use_transpose.md:16
#: use_transpose.md:19 use_tuning.md:16 use_tuning.md:19 vector.md:16
#: vector.md:19 version.md:16 version.md:19 vt.md:16 vt.md:19
#: with_arg_bpm_scaling.md:16 with_arg_bpm_scaling.md:19 with_arg_checks.md:16
#: with_arg_checks.md:19 with_bpm.md:27 with_bpm.md:30 with_bpm_mul.md:16
#: with_bpm_mul.md:19 with_cent_tuning.md:16 with_cent_tuning.md:19
#: with_cue_logging.md:16 with_cue_logging.md:19 with_debug.md:16
#: with_debug.md:19 with_fx.md:18 with_fx.md:21 with_merged_midi_defaults.md:16
#: with_merged_midi_defaults.md:19 with_merged_sample_defaults.md:16
#: with_merged_sample_defaults.md:19 with_merged_synth_defaults.md:16
#: with_merged_synth_defaults.md:19 with_midi_defaults.md:16
#: with_midi_defaults.md:19 with_midi_logging.md:16 with_midi_logging.md:19
#: with_octave.md:16 with_octave.md:19 with_osc.md:16 with_osc.md:19
#: with_osc_logging.md:16 with_osc_logging.md:19 with_random_seed.md:16
#: with_random_seed.md:19 with_random_source.md:16 with_random_source.md:19
#: with_real_time.md:22 with_real_time.md:25 with_sample_bpm.md:16
#: with_sample_bpm.md:19 with_sample_defaults.md:16 with_sample_defaults.md:19
#: with_sched_ahead_time.md:20 with_sched_ahead_time.md:23 with_swing.md:16
#: with_swing.md:19 with_synth.md:16 with_synth.md:19 with_synth_defaults.md:16
#: with_synth_defaults.md:19 with_timing_guarantees.md:16
#: with_timing_guarantees.md:19 with_transpose.md:16 with_transpose.md:19
#: with_tuning.md:16 with_tuning.md:19
msgid "<tr>"
msgstr ""

#: assert.md:17 assert_equal.md:17 assert_error.md:17 assert_not.md:17
#: assert_not_equal.md:17 assert_similar.md:21 at.md:21 beat.md:17
#: block_duration.md:17 block_slept?.md:17 bools.md:17 bt.md:17 buffer.md:17
#: choose.md:21 chord.md:17 chord_degree.md:17 chord_invert.md:21
#: chord_names.md:17 clear.md:17 comment.md:17 control.md:19 cue.md:17
#: current_arg_checks.md:19 current_beat_duration.md:19 current_bpm.md:19
#: current_cent_tuning.md:19 current_debug.md:19 current_midi_defaults.md:19
#: current_octave.md:19 current_random_seed.md:19 current_sample_defaults.md:19
#: current_sched_ahead_time.md:19 current_synth.md:19
#: current_synth_defaults.md:19 current_time.md:19 current_transpose.md:19
#: current_volume.md:19 dec.md:17 define.md:17 defonce.md:17 degree.md:17
#: density.md:17 dice.md:17 doubles.md:17 eval_file.md:17 factor?.md:17
#: get.md:19 halves.md:17 hz_to_midi.md:17 in_thread.md:20 inc.md:17 kill.md:17
#: knit.md:17 line.md:17 live_audio.md:27 live_loop.md:28 load_buffer.md:17
#: load_example.md:17 load_sample.md:19 load_samples.md:19 load_synthdefs.md:39
#: look.md:17 loop.md:21 map.md:17 mc_block_id.md:17 mc_block_ids.md:17
#: mc_block_name.md:17 mc_block_names.md:17 mc_camera_fixed.md:17
#: mc_camera_normal.md:17 mc_camera_set_location.md:17
#: mc_camera_third_person.md:17 mc_checkpoint_restore.md:17
#: mc_checkpoint_save.md:17 mc_get_block.md:17 mc_get_tile.md:17
#: mc_ground_height.md:17 mc_location.md:17 mc_message.md:17 mc_set_block.md:17
#: mc_set_tile.md:17 mc_surface_teleport.md:17 mc_teleport.md:17 midi.md:20
#: midi_all_notes_off.md:22 midi_cc.md:24 midi_channel_pressure.md:24
#: midi_clock_beat.md:20 midi_clock_tick.md:22 midi_continue.md:22
#: midi_local_control_off.md:22 midi_local_control_on.md:22 midi_mode.md:29
#: midi_note_off.md:26 midi_note_on.md:26 midi_notes.md:17 midi_pc.md:22
#: midi_pitch_bend.md:27 midi_poly_pressure.md:24 midi_raw.md:22
#: midi_reset.md:22 midi_sound_off.md:22 midi_start.md:22 midi_stop.md:22
#: midi_sysex.md:24 midi_to_hz.md:17 note.md:17 note_info.md:17
#: note_range.md:17 octs.md:17 on.md:17 one_in.md:17 osc.md:47 osc_send.md:19
#: pick.md:23 pitch_to_ratio.md:17 play.md:26 play_chord.md:19
#: play_pattern.md:19 play_pattern_timed.md:21 print.md:17 puts.md:17
#: quantise.md:17 ramp.md:17 rand.md:17 rand_back.md:17 rand_i.md:17
#: rand_i_look.md:19 rand_look.md:19 rand_reset.md:17 rand_skip.md:17
#: range.md:17 ratio_to_pitch.md:17 rdist.md:17 reset.md:17 reset_mixer!.md:17
#: rest?.md:17 ring.md:17 rrand.md:17 rrand_i.md:17 rt.md:17 run_code.md:17
#: run_file.md:17 sample.md:40 sample_buffer.md:17 sample_duration.md:19
#: sample_free.md:19 sample_free_all.md:17 sample_info.md:17
#: sample_loaded?.md:17 sample_paths.md:17 scale.md:17 scale_names.md:17
#: scsynth_info.md:17 set.md:19 set_audio_latency!.md:19 set_cent_tuning!.md:23
#: set_control_delta!.md:17 set_mixer_control!.md:17
#: set_recording_bit_depth!.md:17 set_sched_ahead_time!.md:17 set_volume!.md:17
#: shuffle.md:17 sleep.md:17 spark.md:17 spark_graph.md:17 spread.md:17
#: status.md:17 stop.md:17 stretch.md:17 sync.md:17 sync_bpm.md:17 synth.md:25
#: tick.md:17 tick_reset.md:17 tick_reset_all.md:17 tick_set.md:17
#: time_warp.md:27 uncomment.md:17 use_arg_bpm_scaling.md:17
#: use_arg_checks.md:17 use_bpm.md:27 use_bpm_mul.md:17 use_cent_tuning.md:19
#: use_cue_logging.md:17 use_debug.md:17 use_merged_midi_defaults.md:17
#: use_merged_sample_defaults.md:17 use_merged_synth_defaults.md:17
#: use_midi_defaults.md:17 use_midi_logging.md:17 use_octave.md:17
#: use_osc.md:27 use_osc_logging.md:17 use_random_seed.md:17
#: use_random_source.md:38 use_real_time.md:22 use_sample_bpm.md:17
#: use_sample_defaults.md:17 use_sched_ahead_time.md:21 use_synth.md:17
#: use_synth_defaults.md:17 use_timing_guarantees.md:17 use_transpose.md:17
#: use_tuning.md:17 vector.md:17 version.md:17 vt.md:17
#: with_arg_bpm_scaling.md:17 with_arg_checks.md:17 with_bpm.md:28
#: with_bpm_mul.md:17 with_cent_tuning.md:17 with_cue_logging.md:17
#: with_debug.md:17 with_fx.md:19 with_merged_midi_defaults.md:17
#: with_merged_sample_defaults.md:17 with_merged_synth_defaults.md:17
#: with_midi_defaults.md:17 with_midi_logging.md:17 with_octave.md:17
#: with_osc.md:17 with_osc_logging.md:17 with_random_seed.md:17
#: with_random_source.md:17 with_real_time.md:23 with_sample_bpm.md:17
#: with_sample_defaults.md:17 with_sched_ahead_time.md:21 with_swing.md:17
#: with_synth.md:17 with_synth_defaults.md:17 with_timing_guarantees.md:17
#: with_transpose.md:17 with_tuning.md:17
msgid ""
"<th colspan=\"2\" class=\"even head\"># Example 1 ────────────────────────────────"
"──────────────────────</th>"
msgstr ""

#: assert.md:18 assert_equal.md:18 assert_error.md:18 assert_not.md:18
#: assert_not_equal.md:18 assert_similar.md:22 at.md:22 beat.md:18
#: block_duration.md:18 block_slept?.md:18 bools.md:18 bt.md:18 buffer.md:18
#: choose.md:22 chord.md:18 chord_degree.md:18 chord_invert.md:22
#: chord_names.md:18 clear.md:18 comment.md:18 control.md:20 cue.md:18
#: current_arg_checks.md:20 current_beat_duration.md:20 current_bpm.md:20
#: current_cent_tuning.md:20 current_debug.md:20 current_midi_defaults.md:20
#: current_octave.md:20 current_random_seed.md:20 current_sample_defaults.md:20
#: current_sched_ahead_time.md:20 current_synth.md:20
#: current_synth_defaults.md:20 current_time.md:20 current_transpose.md:20
#: current_volume.md:20 dec.md:18 define.md:18 defonce.md:18 degree.md:18
#: density.md:18 dice.md:18 doubles.md:18 eval_file.md:18 factor?.md:18
#: get.md:20 halves.md:18 hz_to_midi.md:18 in_thread.md:21 inc.md:18 kill.md:18
#: knit.md:18 line.md:18 live_audio.md:28 live_loop.md:29 load_buffer.md:18
#: load_example.md:18 load_sample.md:20 load_samples.md:20 load_synthdefs.md:40
#: look.md:18 loop.md:22 map.md:18 mc_block_id.md:18 mc_block_ids.md:18
#: mc_block_name.md:18 mc_block_names.md:18 mc_camera_fixed.md:18
#: mc_camera_normal.md:18 mc_camera_set_location.md:18
#: mc_camera_third_person.md:18 mc_checkpoint_restore.md:18
#: mc_checkpoint_save.md:18 mc_get_block.md:18 mc_get_tile.md:18
#: mc_ground_height.md:18 mc_location.md:18 mc_message.md:18 mc_set_block.md:18
#: mc_set_tile.md:18 mc_surface_teleport.md:18 mc_teleport.md:18 midi.md:21
#: midi_all_notes_off.md:23 midi_cc.md:25 midi_channel_pressure.md:25
#: midi_clock_beat.md:21 midi_clock_tick.md:23 midi_continue.md:23
#: midi_local_control_off.md:23 midi_local_control_on.md:23 midi_mode.md:30
#: midi_note_off.md:27 midi_note_on.md:27 midi_notes.md:18 midi_pc.md:23
#: midi_pitch_bend.md:28 midi_poly_pressure.md:25 midi_raw.md:23
#: midi_reset.md:23 midi_sound_off.md:23 midi_start.md:23 midi_stop.md:23
#: midi_sysex.md:25 midi_to_hz.md:18 note.md:18 note_info.md:18
#: note_range.md:18 octs.md:18 on.md:18 one_in.md:18 osc.md:48 osc_send.md:20
#: pick.md:24 pitch_to_ratio.md:18 play.md:27 play_chord.md:20
#: play_pattern.md:20 play_pattern_timed.md:22 print.md:18 puts.md:18
#: quantise.md:18 ramp.md:18 rand.md:18 rand_back.md:18 rand_i.md:18
#: rand_i_look.md:20 rand_look.md:20 rand_reset.md:18 rand_skip.md:18
#: range.md:18 ratio_to_pitch.md:18 rdist.md:18 reset.md:18 reset_mixer!.md:18
#: rest?.md:18 ring.md:18 rrand.md:18 rrand_i.md:18 rt.md:18 run_code.md:18
#: run_file.md:18 sample.md:41 sample_buffer.md:18 sample_duration.md:20
#: sample_free.md:20 sample_free_all.md:18 sample_info.md:18
#: sample_loaded?.md:18 sample_paths.md:18 scale.md:18 scale_names.md:18
#: scsynth_info.md:18 set.md:20 set_audio_latency!.md:20 set_cent_tuning!.md:24
#: set_control_delta!.md:18 set_mixer_control!.md:18
#: set_recording_bit_depth!.md:18 set_sched_ahead_time!.md:18 set_volume!.md:18
#: shuffle.md:18 sleep.md:18 spark.md:18 spark_graph.md:18 spread.md:18
#: status.md:18 stop.md:18 stretch.md:18 sync.md:18 sync_bpm.md:18 synth.md:26
#: tick.md:18 tick_reset.md:18 tick_reset_all.md:18 tick_set.md:18
#: time_warp.md:28 uncomment.md:18 use_arg_bpm_scaling.md:18
#: use_arg_checks.md:18 use_bpm.md:28 use_bpm_mul.md:18 use_cent_tuning.md:20
#: use_cue_logging.md:18 use_debug.md:18 use_merged_midi_defaults.md:18
#: use_merged_sample_defaults.md:18 use_merged_synth_defaults.md:18
#: use_midi_defaults.md:18 use_midi_logging.md:18 use_octave.md:18
#: use_osc.md:28 use_osc_logging.md:18 use_random_seed.md:18
#: use_random_source.md:39 use_real_time.md:23 use_sample_bpm.md:18
#: use_sample_defaults.md:18 use_sched_ahead_time.md:22 use_synth.md:18
#: use_synth_defaults.md:18 use_timing_guarantees.md:18 use_transpose.md:18
#: use_tuning.md:18 vector.md:18 version.md:18 vt.md:18
#: with_arg_bpm_scaling.md:18 with_arg_checks.md:18 with_bpm.md:29
#: with_bpm_mul.md:18 with_cent_tuning.md:18 with_cue_logging.md:18
#: with_debug.md:18 with_fx.md:20 with_merged_midi_defaults.md:18
#: with_merged_sample_defaults.md:18 with_merged_synth_defaults.md:18
#: with_midi_defaults.md:18 with_midi_logging.md:18 with_octave.md:18
#: with_osc.md:18 with_osc_logging.md:18 with_random_seed.md:18
#: with_random_source.md:18 with_real_time.md:24 with_sample_bpm.md:18
#: with_sample_defaults.md:18 with_sched_ahead_time.md:22 with_swing.md:18
#: with_synth.md:18 with_synth_defaults.md:18 with_timing_guarantees.md:18
#: with_transpose.md:18 with_tuning.md:18
msgid "</tr>"
msgstr ""

#: assert.md:20 assert.md:34 assert_equal.md:20 assert_equal.md:30
#: assert_error.md:20 assert_error.md:33 assert_not.md:20 assert_not.md:34
#: assert_not_equal.md:20 assert_not_equal.md:32 assert_similar.md:24
#: assert_similar.md:35 at.md:24 at.md:35 beat.md:20 beat.md:36
#: block_duration.md:20 block_duration.md:37 block_slept?.md:20
#: block_slept?.md:37 bools.md:20 bools.md:30 bt.md:20 bt.md:35 buffer.md:20
#: buffer.md:32 choose.md:24 choose.md:38 chord.md:20 chord.md:30
#: chord_degree.md:20 chord_degree.md:30 chord_invert.md:24 chord_invert.md:38
#: chord_names.md:20 chord_names.md:30 clear.md:20 clear.md:59 comment.md:20
#: comment.md:33 control.md:22 control.md:38 cue.md:20 cue.md:38
#: current_arg_checks.md:22 current_arg_checks.md:32
#: current_beat_duration.md:22 current_beat_duration.md:36 current_bpm.md:22
#: current_bpm.md:32 current_cent_tuning.md:22 current_cent_tuning.md:32
#: current_debug.md:22 current_debug.md:32 current_midi_defaults.md:22
#: current_midi_defaults.md:34 current_octave.md:22 current_octave.md:32
#: current_random_seed.md:22 current_random_seed.md:32
#: current_sample_defaults.md:22 current_sample_defaults.md:34
#: current_sched_ahead_time.md:22 current_sched_ahead_time.md:33
#: current_synth.md:22 current_synth.md:32 current_synth_defaults.md:22
#: current_synth_defaults.md:34 current_time.md:22 current_time.md:32
#: current_transpose.md:22 current_transpose.md:32 current_volume.md:22
#: current_volume.md:32 dec.md:20 dec.md:30 define.md:20 define.md:42
#: defonce.md:20 defonce.md:56 degree.md:20 degree.md:32 density.md:20
#: density.md:35 dice.md:20 dice.md:31 doubles.md:20 doubles.md:30
#: eval_file.md:20 eval_file.md:30 factor?.md:20 factor?.md:30 get.md:22
#: get.md:32 halves.md:20 halves.md:30 hz_to_midi.md:20 hz_to_midi.md:30
#: in_thread.md:23 in_thread.md:40 inc.md:20 inc.md:30 kill.md:20 kill.md:33
#: knit.md:20 knit.md:30 line.md:20 line.md:30 live_audio.md:30
#: live_audio.md:41 live_loop.md:31 live_loop.md:45 load_buffer.md:20
#: load_buffer.md:30 load_example.md:20 load_example.md:30 load_sample.md:22
#: load_sample.md:33 load_samples.md:22 load_samples.md:33 load_synthdefs.md:42
#: load_synthdefs.md:52 look.md:20 look.md:32 loop.md:24 loop.md:43 map.md:20
#: map.md:30 mc_block_id.md:20 mc_block_id.md:30 mc_block_ids.md:20
#: mc_block_ids.md:30 mc_block_name.md:20 mc_block_name.md:30
#: mc_block_names.md:20 mc_block_names.md:30 mc_camera_fixed.md:20
#: mc_camera_fixed.md:29 mc_camera_normal.md:20 mc_camera_normal.md:29
#: mc_camera_set_location.md:20 mc_camera_set_location.md:29
#: mc_camera_third_person.md:20 mc_camera_third_person.md:29
#: mc_checkpoint_restore.md:20 mc_checkpoint_restore.md:29
#: mc_checkpoint_save.md:20 mc_checkpoint_save.md:29 mc_get_block.md:20
#: mc_get_block.md:30 mc_get_tile.md:20 mc_get_tile.md:30
#: mc_ground_height.md:20 mc_ground_height.md:30 mc_location.md:20
#: mc_location.md:30 mc_message.md:20 mc_message.md:30 mc_set_block.md:20
#: mc_set_block.md:30 mc_set_tile.md:20 mc_set_tile.md:29
#: mc_surface_teleport.md:20 mc_surface_teleport.md:30 mc_teleport.md:20
#: mc_teleport.md:31 midi.md:23 midi.md:33 midi_all_notes_off.md:25
#: midi_all_notes_off.md:35 midi_cc.md:27 midi_cc.md:37
#: midi_channel_pressure.md:27 midi_channel_pressure.md:37
#: midi_clock_beat.md:23 midi_clock_beat.md:33 midi_clock_tick.md:25
#: midi_clock_tick.md:35 midi_continue.md:25 midi_continue.md:35
#: midi_local_control_off.md:25 midi_local_control_off.md:35
#: midi_local_control_on.md:25 midi_local_control_on.md:35 midi_mode.md:32
#: midi_mode.md:42 midi_note_off.md:29 midi_note_off.md:39 midi_note_on.md:29
#: midi_note_on.md:39 midi_notes.md:20 midi_notes.md:30 midi_pc.md:25
#: midi_pc.md:35 midi_pitch_bend.md:30 midi_pitch_bend.md:40
#: midi_poly_pressure.md:27 midi_poly_pressure.md:37 midi_raw.md:25
#: midi_raw.md:35 midi_reset.md:25 midi_reset.md:35 midi_sound_off.md:25
#: midi_sound_off.md:35 midi_start.md:25 midi_start.md:35 midi_stop.md:25
#: midi_stop.md:35 midi_sysex.md:27 midi_sysex.md:37 midi_to_hz.md:20
#: midi_to_hz.md:30 note.md:20 note.md:33 note_info.md:20 note_info.md:31
#: note_range.md:20 note_range.md:30 octs.md:20 octs.md:30 on.md:20 on.md:31
#: one_in.md:20 one_in.md:30 osc.md:50 osc.md:64 osc_send.md:22 osc_send.md:32
#: pick.md:26 pick.md:36 pitch_to_ratio.md:20 pitch_to_ratio.md:30 play.md:29
#: play.md:39 play_chord.md:22 play_chord.md:37 play_pattern.md:22
#: play_pattern.md:37 play_pattern_timed.md:24 play_pattern_timed.md:43
#: print.md:20 print.md:30 puts.md:20 puts.md:30 quantise.md:20 quantise.md:30
#: ramp.md:20 ramp.md:30 rand.md:20 rand.md:30 rand_back.md:20 rand_back.md:39
#: rand_i.md:20 rand_i.md:30 rand_i_look.md:22 rand_i_look.md:32
#: rand_look.md:22 rand_look.md:32 rand_reset.md:20 rand_reset.md:35
#: rand_skip.md:20 rand_skip.md:37 range.md:20 range.md:30 ratio_to_pitch.md:20
#: ratio_to_pitch.md:30 rdist.md:20 rdist.md:30 reset.md:20 reset.md:46
#: reset_mixer!.md:20 reset_mixer!.md:34 rest?.md:20 rest?.md:30 ring.md:20
#: ring.md:30 rrand.md:20 rrand.md:30 rrand_i.md:20 rrand_i.md:30 rt.md:20
#: rt.md:34 run_code.md:20 run_code.md:30 run_file.md:20 run_file.md:30
#: sample.md:43 sample.md:54 sample_buffer.md:20 sample_buffer.md:29
#: sample_duration.md:22 sample_duration.md:33 sample_free.md:22
#: sample_free.md:37 sample_free_all.md:20 sample_free_all.md:34
#: sample_info.md:20 sample_info.md:29 sample_loaded?.md:20
#: sample_loaded?.md:32 sample_paths.md:20 sample_paths.md:30 scale.md:20
#: scale.md:30 scale_names.md:20 scale_names.md:30 scsynth_info.md:20
#: scsynth_info.md:40 set.md:22 set.md:32 set_audio_latency!.md:22
#: set_audio_latency!.md:33 set_cent_tuning!.md:26 set_cent_tuning!.md:38
#: set_control_delta!.md:20 set_control_delta!.md:38 set_mixer_control!.md:20
#: set_mixer_control!.md:30 set_recording_bit_depth!.md:20
#: set_recording_bit_depth!.md:30 set_sched_ahead_time!.md:20
#: set_sched_ahead_time!.md:30 set_volume!.md:20 set_volume!.md:30
#: shuffle.md:20 shuffle.md:30 sleep.md:20 sleep.md:41 spark.md:20 spark.md:30
#: spark_graph.md:20 spark_graph.md:30 spread.md:20 spread.md:30 status.md:20
#: status.md:42 stop.md:20 stop.md:33 stretch.md:20 stretch.md:30 sync.md:20
#: sync.md:38 sync_bpm.md:20 sync_bpm.md:29 synth.md:28 synth.md:42 tick.md:20
#: tick.md:33 tick_reset.md:20 tick_reset.md:36 tick_reset_all.md:20
#: tick_reset_all.md:39 tick_set.md:20 tick_set.md:31 time_warp.md:30
#: time_warp.md:57 uncomment.md:20 uncomment.md:33 use_arg_bpm_scaling.md:20
#: use_arg_bpm_scaling.md:35 use_arg_checks.md:20 use_arg_checks.md:32
#: use_bpm.md:30 use_bpm.md:61 use_bpm_mul.md:20 use_bpm_mul.md:37
#: use_cent_tuning.md:22 use_cent_tuning.md:34 use_cue_logging.md:20
#: use_cue_logging.md:30 use_debug.md:20 use_debug.md:30
#: use_merged_midi_defaults.md:20 use_merged_midi_defaults.md:40
#: use_merged_sample_defaults.md:20 use_merged_sample_defaults.md:38
#: use_merged_synth_defaults.md:20 use_merged_synth_defaults.md:39
#: use_midi_defaults.md:20 use_midi_defaults.md:38 use_midi_logging.md:20
#: use_midi_logging.md:30 use_octave.md:20 use_octave.md:32 use_osc.md:30
#: use_osc.md:44 use_osc_logging.md:20 use_osc_logging.md:30
#: use_random_seed.md:20 use_random_seed.md:35 use_random_source.md:41
#: use_random_source.md:70 use_real_time.md:25 use_real_time.md:35
#: use_sample_bpm.md:20 use_sample_bpm.md:35 use_sample_defaults.md:20
#: use_sample_defaults.md:38 use_sched_ahead_time.md:24
#: use_sched_ahead_time.md:34 use_synth.md:20 use_synth.md:32
#: use_synth_defaults.md:20 use_synth_defaults.md:38
#: use_timing_guarantees.md:20 use_timing_guarantees.md:32 use_transpose.md:20
#: use_transpose.md:32 use_tuning.md:20 use_tuning.md:34 vector.md:20
#: vector.md:30 version.md:20 version.md:30 vt.md:20 vt.md:32
#: with_arg_bpm_scaling.md:20 with_arg_bpm_scaling.md:33 with_arg_checks.md:20
#: with_arg_checks.md:43 with_bpm.md:31 with_bpm.md:63 with_bpm_mul.md:20
#: with_bpm_mul.md:40 with_cent_tuning.md:20 with_cent_tuning.md:38
#: with_cue_logging.md:20 with_cue_logging.md:41 with_debug.md:20
#: with_debug.md:43 with_fx.md:22 with_fx.md:36 with_merged_midi_defaults.md:20
#: with_merged_midi_defaults.md:45 with_merged_sample_defaults.md:20
#: with_merged_sample_defaults.md:40 with_merged_synth_defaults.md:20
#: with_merged_synth_defaults.md:31 with_midi_defaults.md:20
#: with_midi_defaults.md:44 with_midi_logging.md:20 with_midi_logging.md:41
#: with_octave.md:20 with_octave.md:36 with_osc.md:20 with_osc.md:40
#: with_osc_logging.md:20 with_osc_logging.md:41 with_random_seed.md:20
#: with_random_seed.md:40 with_random_source.md:20 with_random_source.md:49
#: with_real_time.md:26 with_real_time.md:36 with_sample_bpm.md:20
#: with_sample_bpm.md:35 with_sample_defaults.md:20 with_sample_defaults.md:40
#: with_sched_ahead_time.md:24 with_sched_ahead_time.md:38 with_swing.md:20
#: with_swing.md:34 with_synth.md:20 with_synth.md:40 with_synth_defaults.md:20
#: with_synth_defaults.md:40 with_timing_guarantees.md:20
#: with_timing_guarantees.md:31 with_transpose.md:20 with_transpose.md:40
#: with_tuning.md:20 with_tuning.md:38
msgid "<td class=\"even\">"
msgstr ""

#: assert.md:24
msgid "assert true  "
msgstr ""

#: assert.md:25
msgid "assert 1     "
msgstr ""

#: assert.md:26
msgid "assert \"foo\""
msgstr ""

#: assert.md:27
msgid "assert false "
msgstr ""

#: assert.md:33 assert_equal.md:29 assert_error.md:32 assert_not.md:33
#: assert_not_equal.md:31 assert_similar.md:34 at.md:34 beat.md:35
#: block_duration.md:36 block_slept?.md:36 bools.md:29 bt.md:34 buffer.md:31
#: choose.md:37 chord.md:29 chord_degree.md:29 chord_invert.md:37
#: chord_names.md:29 clear.md:58 comment.md:32 control.md:37 cue.md:37
#: current_arg_checks.md:31 current_beat_duration.md:35 current_bpm.md:31
#: current_cent_tuning.md:31 current_debug.md:31 current_midi_defaults.md:33
#: current_octave.md:31 current_random_seed.md:31 current_sample_defaults.md:33
#: current_sched_ahead_time.md:32 current_synth.md:31
#: current_synth_defaults.md:33 current_time.md:31 current_transpose.md:31
#: current_volume.md:31 dec.md:29 define.md:41 defonce.md:55 degree.md:31
#: density.md:34 dice.md:30 doubles.md:29 eval_file.md:29 factor?.md:29
#: get.md:31 halves.md:29 hz_to_midi.md:29 in_thread.md:39 inc.md:29 kill.md:32
#: knit.md:29 line.md:29 live_audio.md:40 live_loop.md:44 load_buffer.md:29
#: load_example.md:29 load_sample.md:32 load_samples.md:32 load_synthdefs.md:51
#: look.md:31 loop.md:42 map.md:29 mc_block_id.md:29 mc_block_ids.md:29
#: mc_block_name.md:29 mc_block_names.md:29 mc_camera_fixed.md:28
#: mc_camera_normal.md:28 mc_camera_set_location.md:28
#: mc_camera_third_person.md:28 mc_checkpoint_restore.md:28
#: mc_checkpoint_save.md:28 mc_get_block.md:29 mc_get_tile.md:29
#: mc_ground_height.md:29 mc_location.md:29 mc_message.md:29 mc_set_block.md:29
#: mc_set_tile.md:28 mc_surface_teleport.md:29 mc_teleport.md:30 midi.md:32
#: midi_all_notes_off.md:34 midi_cc.md:36 midi_channel_pressure.md:36
#: midi_clock_beat.md:32 midi_clock_tick.md:34 midi_continue.md:34
#: midi_local_control_off.md:34 midi_local_control_on.md:34 midi_mode.md:41
#: midi_note_off.md:38 midi_note_on.md:38 midi_notes.md:29 midi_pc.md:34
#: midi_pitch_bend.md:39 midi_poly_pressure.md:36 midi_raw.md:34
#: midi_reset.md:34 midi_sound_off.md:34 midi_start.md:34 midi_stop.md:34
#: midi_sysex.md:36 midi_to_hz.md:29 note.md:32 note_info.md:30
#: note_range.md:29 octs.md:29 on.md:30 one_in.md:29 osc.md:63 osc_send.md:31
#: pick.md:35 pitch_to_ratio.md:29 play.md:38 play_chord.md:36
#: play_pattern.md:36 play_pattern_timed.md:42 print.md:29 puts.md:29
#: quantise.md:29 ramp.md:29 rand.md:29 rand_back.md:38 rand_i.md:29
#: rand_i_look.md:31 rand_look.md:31 rand_reset.md:34 rand_skip.md:36
#: range.md:29 ratio_to_pitch.md:29 rdist.md:29 reset.md:45 reset_mixer!.md:33
#: rest?.md:29 ring.md:29 rrand.md:29 rrand_i.md:29 rt.md:33 run_code.md:29
#: run_file.md:29 sample.md:53 sample_buffer.md:28 sample_duration.md:32
#: sample_free.md:36 sample_free_all.md:33 sample_info.md:28
#: sample_loaded?.md:31 sample_paths.md:29 scale.md:29 scale_names.md:29
#: scsynth_info.md:39 set.md:31 set_audio_latency!.md:32 set_cent_tuning!.md:37
#: set_control_delta!.md:37 set_mixer_control!.md:29
#: set_recording_bit_depth!.md:29 set_sched_ahead_time!.md:29 set_volume!.md:29
#: shuffle.md:29 sleep.md:40 spark.md:29 spark_graph.md:29 spread.md:29
#: status.md:41 stop.md:32 stretch.md:29 sync.md:37 sync_bpm.md:28 synth.md:41
#: tick.md:32 tick_reset.md:35 tick_reset_all.md:38 tick_set.md:30
#: time_warp.md:56 uncomment.md:32 use_arg_bpm_scaling.md:34
#: use_arg_checks.md:31 use_bpm.md:60 use_bpm_mul.md:36 use_cent_tuning.md:33
#: use_cue_logging.md:29 use_debug.md:29 use_merged_midi_defaults.md:39
#: use_merged_sample_defaults.md:37 use_merged_synth_defaults.md:38
#: use_midi_defaults.md:37 use_midi_logging.md:29 use_octave.md:31
#: use_osc.md:43 use_osc_logging.md:29 use_random_seed.md:34
#: use_random_source.md:69 use_real_time.md:34 use_sample_bpm.md:34
#: use_sample_defaults.md:37 use_sched_ahead_time.md:33 use_synth.md:31
#: use_synth_defaults.md:37 use_timing_guarantees.md:31 use_transpose.md:31
#: use_tuning.md:33 vector.md:29 version.md:29 vt.md:31
#: with_arg_bpm_scaling.md:32 with_arg_checks.md:42 with_bpm.md:62
#: with_bpm_mul.md:39 with_cent_tuning.md:37 with_cue_logging.md:40
#: with_debug.md:42 with_fx.md:35 with_merged_midi_defaults.md:44
#: with_merged_sample_defaults.md:39 with_merged_synth_defaults.md:30
#: with_midi_defaults.md:43 with_midi_logging.md:40 with_octave.md:35
#: with_osc.md:39 with_osc_logging.md:40 with_random_seed.md:39
#: with_random_source.md:48 with_real_time.md:35 with_sample_bpm.md:34
#: with_sample_defaults.md:39 with_sched_ahead_time.md:37 with_swing.md:33
#: with_synth.md:39 with_synth_defaults.md:39 with_timing_guarantees.md:30
#: with_transpose.md:39 with_tuning.md:37
msgid "</td>"
msgstr ""

#: assert.md:36 assert_equal.md:32 assert_error.md:35 assert_not.md:36
#: assert_not_equal.md:34 assert_similar.md:37 at.md:37 beat.md:38
#: block_duration.md:39 block_slept?.md:39 bools.md:32 bt.md:37 buffer.md:34
#: choose.md:40 chord.md:32 chord_degree.md:32 chord_invert.md:40
#: chord_names.md:32 clear.md:61 comment.md:35 control.md:40 cue.md:40
#: current_arg_checks.md:34 current_beat_duration.md:38 current_bpm.md:34
#: current_cent_tuning.md:34 current_debug.md:34 current_midi_defaults.md:36
#: current_octave.md:34 current_random_seed.md:34 current_sample_defaults.md:36
#: current_sched_ahead_time.md:35 current_synth.md:34
#: current_synth_defaults.md:36 current_time.md:34 current_transpose.md:34
#: current_volume.md:34 dec.md:32 define.md:44 defonce.md:58 degree.md:34
#: density.md:37 dice.md:33 doubles.md:32 eval_file.md:32 factor?.md:32
#: get.md:34 halves.md:32 hz_to_midi.md:32 in_thread.md:42 inc.md:32 kill.md:35
#: knit.md:32 line.md:32 live_audio.md:43 live_loop.md:47 load_buffer.md:32
#: load_example.md:32 load_sample.md:35 load_samples.md:35 load_synthdefs.md:54
#: look.md:34 loop.md:45 map.md:32 mc_block_id.md:32 mc_block_ids.md:32
#: mc_block_name.md:32 mc_block_names.md:32 mc_camera_fixed.md:31
#: mc_camera_normal.md:31 mc_camera_set_location.md:31
#: mc_camera_third_person.md:31 mc_checkpoint_restore.md:31
#: mc_checkpoint_save.md:31 mc_get_block.md:32 mc_get_tile.md:32
#: mc_ground_height.md:32 mc_location.md:32 mc_message.md:32 mc_set_block.md:32
#: mc_set_tile.md:31 mc_surface_teleport.md:32 mc_teleport.md:33 midi.md:35
#: midi_all_notes_off.md:37 midi_cc.md:39 midi_channel_pressure.md:39
#: midi_clock_beat.md:35 midi_clock_tick.md:37 midi_continue.md:37
#: midi_local_control_off.md:37 midi_local_control_on.md:37 midi_mode.md:44
#: midi_note_off.md:41 midi_note_on.md:41 midi_notes.md:32 midi_pc.md:37
#: midi_pitch_bend.md:42 midi_poly_pressure.md:39 midi_raw.md:37
#: midi_reset.md:37 midi_sound_off.md:37 midi_start.md:37 midi_stop.md:37
#: midi_sysex.md:39 midi_to_hz.md:32 note.md:35 note_info.md:33
#: note_range.md:32 octs.md:32 on.md:33 one_in.md:32 osc.md:66 osc_send.md:34
#: pick.md:38 pitch_to_ratio.md:32 play.md:41 play_chord.md:39
#: play_pattern.md:39 play_pattern_timed.md:45 print.md:32 puts.md:32
#: quantise.md:32 ramp.md:32 rand.md:32 rand_back.md:41 rand_i.md:32
#: rand_i_look.md:34 rand_look.md:34 rand_reset.md:37 rand_skip.md:39
#: range.md:32 ratio_to_pitch.md:32 rdist.md:32 reset.md:48 reset_mixer!.md:36
#: rest?.md:32 ring.md:32 rrand.md:32 rrand_i.md:32 rt.md:36 run_code.md:32
#: run_file.md:32 sample.md:56 sample_buffer.md:31 sample_duration.md:35
#: sample_free.md:39 sample_free_all.md:36 sample_info.md:31
#: sample_loaded?.md:34 sample_paths.md:32 scale.md:32 scale_names.md:32
#: scsynth_info.md:42 set.md:34 set_audio_latency!.md:35 set_cent_tuning!.md:40
#: set_control_delta!.md:40 set_mixer_control!.md:32
#: set_recording_bit_depth!.md:32 set_sched_ahead_time!.md:32 set_volume!.md:32
#: shuffle.md:32 sleep.md:43 spark.md:32 spark_graph.md:32 spread.md:32
#: status.md:44 stop.md:35 stretch.md:32 sync.md:40 sync_bpm.md:31 synth.md:44
#: tick.md:35 tick_reset.md:38 tick_reset_all.md:41 tick_set.md:33
#: time_warp.md:59 uncomment.md:35 use_arg_bpm_scaling.md:37
#: use_arg_checks.md:34 use_bpm.md:63 use_bpm_mul.md:39 use_cent_tuning.md:36
#: use_cue_logging.md:32 use_debug.md:32 use_merged_midi_defaults.md:42
#: use_merged_sample_defaults.md:40 use_merged_synth_defaults.md:41
#: use_midi_defaults.md:40 use_midi_logging.md:32 use_octave.md:34
#: use_osc.md:46 use_osc_logging.md:32 use_random_seed.md:37
#: use_random_source.md:72 use_real_time.md:37 use_sample_bpm.md:37
#: use_sample_defaults.md:40 use_sched_ahead_time.md:36 use_synth.md:34
#: use_synth_defaults.md:40 use_timing_guarantees.md:34 use_transpose.md:34
#: use_tuning.md:36 vector.md:32 version.md:32 vt.md:34
#: with_arg_bpm_scaling.md:35 with_arg_checks.md:45 with_bpm.md:65
#: with_bpm_mul.md:42 with_cent_tuning.md:40 with_cue_logging.md:43
#: with_debug.md:45 with_fx.md:38 with_merged_midi_defaults.md:47
#: with_merged_sample_defaults.md:42 with_merged_synth_defaults.md:33
#: with_midi_defaults.md:46 with_midi_logging.md:43 with_octave.md:38
#: with_osc.md:42 with_osc_logging.md:43 with_random_seed.md:42
#: with_random_source.md:51 with_real_time.md:38 with_sample_bpm.md:37
#: with_sample_defaults.md:42 with_sched_ahead_time.md:40 with_swing.md:36
#: with_synth.md:42 with_synth_defaults.md:42 with_timing_guarantees.md:33
#: with_transpose.md:42 with_tuning.md:40
msgid "<!--- #tr -->"
msgstr ""

#: assert.md:38 assert_equal.md:34 assert_not.md:38 assert_not_equal.md:36
#: assert_similar.md:39
msgid "# Simple assertions"
msgstr ""

#: assert.md:39
msgid "# As true is neither nil or false, this assertion passes"
msgstr ""

#: assert.md:40
msgid "# Similarly, 1 passes"
msgstr ""

#: assert.md:41
msgid "# As do string"
msgstr ""

#: assert.md:42 assert_not.md:42
msgid "# This will raise an exception"
msgstr ""

#: assert.md:70 assert_not.md:70
msgid "# Communicating error messages"
msgstr ""

#: assert.md:71 assert_not.md:71
msgid "# This will raise an exception containing the message \"oops\""
msgstr ""

#: assert.md:100 assert_equal.md:64
msgid "# More interesting assertions"
msgstr ""

#: assert.md:101 assert_equal.md:65
msgid "# Ensure that arithmetic is sane!"
msgstr ""

#: assert.md:102 assert_equal.md:66
msgid "# ensure lists can be correctly counted"
msgstr ""

#: assert_equal.md:9
msgid "Raises an exception if both arguments aren't equal. "
msgstr ""

#: assert_equal.md:24
msgid "assert_equal 1, 1"
msgstr ""

#: assert_equal.md:93 assert_not_equal.md:66
msgid "# Add messages to the exceptions"
msgstr ""

#: assert_error.md:9
msgid ""
"Runs the block and ensures that it raises the correct Exception. Useful for as"
"serting that an Exception will be raised. You may specify the particular Excep"
"tion class, which defaults to `Exception`."
msgstr ""

#: assert_error.md:11 assert_similar.md:15 buffer.md:11
#: current_midi_defaults.md:13 current_time.md:13 get.md:13 live_audio.md:21
#: midi.md:14 midi_all_notes_off.md:16 midi_cc.md:18
#: midi_channel_pressure.md:18 midi_clock_beat.md:14 midi_clock_tick.md:16
#: midi_continue.md:16 midi_local_control_off.md:16 midi_local_control_on.md:16
#: midi_mode.md:23 midi_note_off.md:20 midi_note_on.md:20 midi_pitch_bend.md:21
#: midi_poly_pressure.md:18 midi_raw.md:16 midi_reset.md:16
#: midi_sound_off.md:16 midi_start.md:16 midi_stop.md:16 osc.md:41
#: osc_send.md:13 set.md:13 use_merged_midi_defaults.md:11
#: use_midi_defaults.md:11 use_midi_logging.md:11 use_osc.md:21
#: use_osc_logging.md:11 use_real_time.md:16 use_sched_ahead_time.md:15
#: with_merged_midi_defaults.md:11 with_midi_defaults.md:11
#: with_midi_logging.md:11 with_osc.md:11 with_osc_logging.md:11
#: with_real_time.md:17 with_sched_ahead_time.md:15 with_swing.md:11
msgid "Introduced in v3.0"
msgstr ""

#: assert_error.md:23
msgid "assert_error do"
msgstr ""

#: assert_error.md:24
msgid "  play 70"
msgstr ""

#: assert_error.md:25
msgid "end                        "
msgstr ""

#: assert_error.md:26 scsynth_info.md:24 scsynth_info.md:25 scsynth_info.md:26
#: scsynth_info.md:27 scsynth_info.md:28 scsynth_info.md:29 scsynth_info.md:30
#: scsynth_info.md:31 scsynth_info.md:32 scsynth_info.md:33
msgid "                           "
msgstr ""

#: assert_error.md:39
msgid "# Will throw an exception: \"Assert error failed!\" as the block"
msgstr ""

#: assert_error.md:40
msgid "# contains no errors."
msgstr ""

#: assert_error.md:71
msgid "# Will not throw an exception as the block contains an error."
msgstr ""

#: assert_error.md:102
msgid "# Will not throw an exception as the block contains a ZeroDivisionError."
msgstr ""

#: assert_error.md:134
msgid ""
"# Will throw an exception as the block contains a ZeroDivisionError rather tha"
"n"
msgstr ""

#: assert_error.md:135
msgid "# a ThreadError."
msgstr ""

#: assert_not.md:9
msgid "Raises an exception if the argument is not either nil or false."
msgstr ""

#: assert_not.md:11 assert_not_equal.md:11 use_random_source.md:32
#: with_random_source.md:11
msgid "Introduced in v3.3"
msgstr ""

#: assert_not.md:24
msgid "assert_not false  "
msgstr ""

#: assert_not.md:25
msgid "assert_not nil    "
msgstr ""

#: assert_not.md:26
msgid "assert_not 1 == 5 "
msgstr ""

#: assert_not.md:27
msgid "assert true "
msgstr ""

#: assert_not.md:39
msgid "# As false is either nil or false, this assertion passes"
msgstr ""

#: assert_not.md:40
msgid "# As nil is either nil or false, this assertion passes"
msgstr ""

#: assert_not.md:41
msgid "# These numbers are not equal"
msgstr ""

#: assert_not_equal.md:9
msgid "Raises an exception if both arguments are qual. "
msgstr ""

#: assert_not_equal.md:24
msgid "assert_not_equal 1, 3"
msgstr ""

#: assert_not_equal.md:25
msgid "assert_not_equal 1, -1"
msgstr ""

#: assert_not_equal.md:26
msgid "assert_not_equal 1, :foo"
msgstr ""

#: assert_similar.md:9
msgid "Raises an exception if both arguments aren't similar."
msgstr ""

#: assert_similar.md:11
msgid ""
"Currently similarity is only defined for numbers - all other types are compare"
"d for equality with assert_equal."
msgstr ""

#: assert_similar.md:13
msgid ""
"Useful for testing in cases where floating point imprecision stops you from be"
"ing able to use `assert_equal`. "
msgstr ""

#: assert_similar.md:28
msgid "assert_similar 1, 1"
msgstr ""

#: assert_similar.md:40 assert_similar.md:69
msgid "#=> True"
msgstr ""

#: assert_similar.md:68
msgid "# Handles floating point imprecision"
msgstr ""

#: at.md:9 time_warp.md:11
msgid ""
"Given a list of times, run the block once after waiting each given time. If pa"
"ssed an optional params list, will pass each param individually to each block "
"call. If size of params list is smaller than the times list, the param values "
"will act as rings (rotate through). If the block is given 1 arg, the times are"
" fed through. If the block is given 2 args, both the times and the params are "
"fed through. A third block arg will receive the index of the time."
msgstr ""

#: at.md:11
msgid ""
"Note, all code within the block is executed in its own thread. Therefore despi"
"te inheriting all thread locals such as the random stream and ticks, modificat"
"ions will be isolated to the block and will not affect external code."
msgstr ""

#: at.md:13
msgid ""
"`at` is just-in-time scheduling using multiple isolated threads. See `time_war"
"p` for ahead-of-time scheduling within the current thread."
msgstr ""

#: at.md:15 chord_degree.md:11 dec.md:11 degree.md:11 factor?.md:11 inc.md:11
#: live_loop.md:22 ndefine.md:11 quantise.md:11 rest?.md:11
#: set_control_delta!.md:11 shuffle.md:11 use_sample_bpm.md:11 vt.md:11
#: with_sample_bpm.md:11
msgid "Introduced in v2.1"
msgstr ""

#: at.md:27
msgid "at 4 do"
msgstr ""

#: at.md:28
msgid "    sample :ambi_choir   "
msgstr ""

#: at.md:29 choose.md:32 comment.md:27 cue.md:26 define.md:27 define.md:36
#: defonce.md:29 defonce.md:42 defonce.md:50 density.md:29 in_thread.md:29
#: in_thread.md:34 sync.md:26 uncomment.md:27 use_bpm.md:37 use_bpm.md:46
#: use_bpm.md:55 use_random_source.md:60 with_bpm.md:38 with_bpm.md:49
#: with_bpm.md:57 with_bpm_mul.md:32 with_cue_logging.md:31
#: with_midi_logging.md:31 with_osc_logging.md:31 with_random_seed.md:31
#: with_random_source.md:39 with_sample_bpm.md:28 with_swing.md:26
msgid "  end"
msgstr ""

#: at.md:40
msgid "# play sample after waiting for 4 beats"
msgstr ""

#: at.md:70 time_warp.md:379
msgid "# plays a note after waiting 1 beat,"
msgstr ""

#: at.md:71 time_warp.md:380
msgid "# then after 1 more beat,"
msgstr ""

#: at.md:72 time_warp.md:381
msgid "# then after 2 more beats (4 beats total)"
msgstr ""

#: at.md:100 time_warp.md:409
msgid "# plays 3 different notes"
msgstr ""

#: at.md:132 time_warp.md:441
msgid "# alternate soft and loud"
msgstr ""

#: at.md:133 time_warp.md:442
msgid "# cymbal hits three times"
msgstr ""

#: at.md:162 time_warp.md:471
msgid "# when no params are given to at, the times are fed through to the block"
msgstr ""

#: at.md:163 time_warp.md:472
msgid "#=> prints 0, 1, then 2"
msgstr ""

#: at.md:192
msgid ""
"#If you specify the block with 2 args, it will pass through both the time and "
"the param"
msgstr ""

#: at.md:193 time_warp.md:502
msgid "#=> prints out [0, :a], [1, :b], then [2, :a]"
msgstr ""

#: at.md:222
msgid ""
"#If you specify the block with 2 args, and no param list to at, it will pass t"
"hrough both the time and the index"
msgstr ""

#: at.md:223 time_warp.md:532
msgid "#=> prints out [0, 0], [0.5, 1], then [2, 2]"
msgstr ""

#: at.md:252
msgid ""
"#If you specify the block with 3 args, it will pass through the time, the para"
"m and the index"
msgstr ""

#: at.md:253 time_warp.md:562
msgid "#=> prints out [0, :a, 0], [0.5, :b, 1], then [2, :a, 2]"
msgstr ""

#: at.md:291
msgid "# at does not consume & interfere with the outer random stream"
msgstr ""

#: at.md:292 time_warp.md:602 time_warp.md:606
msgid "# 0.75006103515625"
msgstr ""

#: at.md:294
msgid "# the random stream inside the at block is separate and"
msgstr ""

#: at.md:295
msgid "# isolated from the outer stream."
msgstr ""

#: at.md:296 at.md:339
msgid "# 0.9287109375"
msgstr ""

#: at.md:297 at.md:340 at.md:343
msgid "# 0.1043701171875"
msgstr ""

#: at.md:301
msgid "# value is still 0.75006103515625"
msgstr ""

#: at.md:336
msgid "# Each block run within at has its own isolated random stream:"
msgstr ""

#: at.md:338 time_warp.md:653
msgid "# first time round (after 1 beat) prints:"
msgstr ""

#: at.md:342 time_warp.md:657
msgid "# second time round (after 2 beats) prints:"
msgstr ""

#: at.md:344
msgid "# 0.764617919921875"
msgstr ""

#: beat.md:9
msgid ""
"Returns the beat value for the current thread/live_loop. Beats are advanced on"
"ly by calls to `sleep` and `sync`. Beats are distinct from virtual time (the v"
"alue obtained by calling `vt`) in that it has no notion of rate. It is just es"
"sentially a counter for sleeps. After a `sync`, the beat is overridden with th"
"e beat value from the thread which called `cue`. "
msgstr ""

#: beat.md:11 current_random_seed.md:13 doubles.md:11 fx_names.md:11
#: halves.md:11 load_buffer.md:11 load_example.md:11 on.md:11 pick.md:17
#: sample_paths.md:11 set_cent_tuning!.md:17 sync_bpm.md:11
#: use_timing_guarantees.md:11 with_timing_guarantees.md:11
msgid "Introduced in v2.10"
msgstr ""

#: beat.md:13 bt.md:13 chord_invert.md:17 chord_names.md:13 clear.md:13
#: comment.md:13 current_arg_checks.md:15 current_beat_duration.md:15
#: current_bpm.md:15 current_cent_tuning.md:15 current_debug.md:15
#: current_midi_defaults.md:15 current_octave.md:15
#: current_sample_defaults.md:15 current_sched_ahead_time.md:15
#: current_synth.md:15 current_synth_defaults.md:15 current_transpose.md:15
#: define.md:13 eval_file.md:13 hz_to_midi.md:13 load_buffer.md:13
#: load_example.md:13 load_synthdefs.md:35 loop.md:17 mc_block_ids.md:13
#: mc_block_names.md:13 mc_camera_fixed.md:13 mc_camera_normal.md:13
#: mc_camera_set_location.md:13 mc_camera_third_person.md:13
#: mc_checkpoint_restore.md:13 mc_checkpoint_save.md:13 mc_get_block.md:13
#: mc_get_tile.md:13 mc_ground_height.md:13 mc_message.md:13 mc_set_block.md:13
#: mc_set_tile.md:13 mc_surface_teleport.md:13 mc_teleport.md:13
#: midi_clock_tick.md:18 midi_continue.md:18 midi_start.md:18 midi_stop.md:18
#: midi_sysex.md:20 midi_to_hz.md:13 note_info.md:13 rand.md:13 rand_i.md:13
#: rand_reset.md:13 reset_mixer!.md:13 rt.md:13 run_file.md:13
#: sample_buffer.md:13 sample_free_all.md:13 sample_info.md:13
#: sample_loaded?.md:13 scale_names.md:13 scsynth_info.md:13
#: set_cent_tuning!.md:19 set_control_delta!.md:13 set_mixer_control!.md:13
#: set_recording_bit_depth!.md:13 set_sched_ahead_time!.md:13 status.md:13
#: sync_bpm.md:13 tick_reset_all.md:13 uncomment.md:13 use_arg_checks.md:13
#: use_bpm.md:23 use_bpm_mul.md:13 use_cent_tuning.md:15
#: use_merged_midi_defaults.md:13 use_merged_sample_defaults.md:13
#: use_midi_defaults.md:13 use_random_source.md:34 use_real_time.md:18
#: use_sample_defaults.md:13 use_synth.md:13 use_synth_defaults.md:13 vt.md:13
#: with_arg_checks.md:13 with_bpm.md:24 with_bpm_mul.md:13
#: with_cent_tuning.md:13 with_cue_logging.md:13 with_debug.md:13
#: with_merged_midi_defaults.md:13 with_merged_sample_defaults.md:13
#: with_midi_defaults.md:13 with_midi_logging.md:13 with_octave.md:13
#: with_osc.md:13 with_osc_logging.md:13 with_random_source.md:13
#: with_real_time.md:19 with_sample_defaults.md:13 with_sched_ahead_time.md:17
#: with_synth.md:13 with_synth_defaults.md:13 with_transpose.md:13
#: with_tuning.md:13
msgid "## Example"
msgstr ""

#: beat.md:23 bt.md:23 rt.md:23
msgid "use_bpm 120 "
msgstr ""

#: beat.md:24 beat.md:26 beat.md:29
msgid "  puts beat   "
msgstr ""

#: beat.md:25 block_duration.md:25 block_slept?.md:25 loop.md:31
#: with_arg_checks.md:31 with_cue_logging.md:32 with_debug.md:31 with_fx.md:28
#: with_midi_logging.md:32 with_osc_logging.md:32 with_transpose.md:28
#: with_tuning.md:27
msgid "  sleep 1"
msgstr ""

#: beat.md:27
msgid "  use_bpm 2000"
msgstr ""

#: beat.md:28 block_duration.md:27 block_slept?.md:27 loop.md:33 use_bpm.md:48
msgid "  sleep 2"
msgstr ""

#: beat.md:40
msgid "# The current BPM makes no difference"
msgstr ""

#: beat.md:41 clear.md:71 clear.md:87 clear.md:92 look.md:36 look.md:37
#: look.md:190 mc_block_id.md:34 mc_block_id.md:61 reset.md:58 reset.md:64
#: reset.md:66 reset.md:131 reset.md:153 tick.md:37 tick.md:112
#: tick_reset_all.md:51 tick_reset_all.md:52
msgid "#=> 0"
msgstr ""

#: beat.md:43 current_beat_duration.md:41 look.md:76 map.md:34 ramp.md:34
#: ramp.md:169 ramp.md:196 ring.md:34 ring.md:88 tick.md:38 tick.md:71
#: tick.md:113 tick_reset_all.md:48 vector.md:34
msgid "#=> 1"
msgstr ""

#: beat.md:46 clear.md:69 ramp.md:88 ramp.md:115 ramp.md:142 reset.md:56
#: reset.md:129 reset.md:146 ring.md:115 tick.md:40 vector.md:88
msgid "#=> 3"
msgstr ""

#: block_duration.md:9
msgid ""
"Given a block, runs it and returns the amount of time that has passed. This ti"
"me is in seconds and is not scaled to the current BPM. Any threads spawned in "
"the block are not accounted for."
msgstr ""

#: block_duration.md:11 block_slept?.md:11 current_cent_tuning.md:13
#: current_octave.md:13 reset_mixer!.md:11 sample_free.md:13
#: sample_free_all.md:11 synth_names.md:11 use_cent_tuning.md:13
#: use_merged_sample_defaults.md:11 use_octave.md:11 with_cent_tuning.md:11
#: with_merged_sample_defaults.md:11 with_octave.md:11
msgid "Introduced in v2.9"
msgstr ""

#: block_duration.md:23
msgid "dur = block_duration do"
msgstr ""

#: block_duration.md:24 block_slept?.md:24 rt.md:24 use_bpm_mul.md:24
#: use_bpm_mul.md:29 with_bpm_mul.md:24 with_cent_tuning.md:27 with_debug.md:30
#: with_fx.md:27 with_merged_synth_defaults.md:24 with_synth.md:29
#: with_synth_defaults.md:30 with_transpose.md:27
msgid "  play 50"
msgstr ""

#: block_duration.md:26 block_slept?.md:26 loop.md:32 rt.md:26 sleep.md:27
#: sleep.md:35 use_bpm_mul.md:26 use_bpm_mul.md:31 with_bpm_mul.md:26
msgid "  play 62"
msgstr ""

#: block_duration.md:28 block_slept?.md:28 clear.md:53 live_loop.md:39
#: loop.md:34 on.md:25 use_sample_bpm.md:29 with_arg_bpm_scaling.md:27
#: with_arg_checks.md:33 with_cent_tuning.md:28 with_debug.md:33 with_fx.md:30
#: with_merged_midi_defaults.md:34 with_merged_sample_defaults.md:31
#: with_merged_synth_defaults.md:25 with_midi_defaults.md:27
#: with_midi_defaults.md:34 with_octave.md:27 with_osc.md:29
#: with_sample_bpm.md:29 with_sample_defaults.md:31 with_sched_ahead_time.md:29
#: with_swing.md:28 with_synth.md:30 with_synth_defaults.md:31
#: with_timing_guarantees.md:25 with_transpose.md:30 with_tuning.md:29
msgid "end"
msgstr ""

#: block_duration.md:30
msgid "puts dur"
msgstr ""

#: block_duration.md:48
msgid "#=> Returns 3 as 3 seconds have passed within the block"
msgstr ""

#: block_duration.md:92
msgid "#=> Returns 1.5 as 1.5 seconds have passed within the block"
msgstr ""

#: block_duration.md:93
msgid "#   (due to the BPM being 120)"
msgstr ""

#: block_slept?.md:9
msgid ""
"Given a block, runs it and returns whether or not the block contained sleeps o"
"r syncs"
msgstr ""

#: block_slept?.md:23
msgid "slept = block_slept? do"
msgstr ""

#: block_slept?.md:30
msgid "puts slept"
msgstr ""

#: block_slept?.md:48
msgid "#=> Returns true as there were sleeps in the block"
msgstr ""

#: block_slept?.md:87
msgid "# trigger a cue on a different thread"
msgstr ""

#: block_slept?.md:91
msgid "# wait for the cue before playing the note"
msgstr ""

#: block_slept?.md:95
msgid "#=> Returns true as the block contained a sync."
msgstr ""

#: block_slept?.md:132
msgid "#=> Returns false as there were no sleeps in the block"
msgstr ""

#: bools.md:9
msgid ""
"Create a new ring of booleans values from 1s and 0s, which can be easier to wr"
"ite and manipulate in a live setting."
msgstr ""

#: bools.md:11 knit.md:11 range.md:11 ring.md:11 sample_loaded?.md:11
msgid "Introduced in v2.2"
msgstr ""

#: bools.md:23
msgid "(bools 1, 0)   "
msgstr ""

#: bools.md:34
msgid "#=> (ring true, false)"
msgstr ""

#: bools.md:61
msgid "#=> (ring true, false, true, false, false)"
msgstr ""

#: bt.md:9
msgid ""
"Beat time representation. Scales the time to the current BPM. Useful for addin"
"g bpm scaling"
msgstr ""

#: bt.md:24 bt.md:26 bt.md:28
msgid "  puts bt(1)"
msgstr ""

#: bt.md:25
msgid "  use_bpm 60  "
msgstr ""

#: bt.md:27
msgid "  use_bpm 30  "
msgstr ""

#: bt.md:39
msgid "# Set the BPM to be double the default"
msgstr ""

#: bt.md:40
msgid "# 0.5"
msgstr ""

#: bt.md:41
msgid "# BPM is now default"
msgstr ""

#: bt.md:42 time_warp.md:655
msgid "# 1"
msgstr ""

#: bt.md:43
msgid "# BPM is now half the default"
msgstr ""

#: bt.md:44 time_warp.md:658
msgid "# 2"
msgstr ""

#: buffer.md:9
msgid ""
"Initialise or return a named buffer with a specific duration (defaults to 8 be"
"ats). Useful for working with the `:record` FX. If the buffer is requested wit"
"h a different duration, then a new buffer will be initialised and the old one "
"recycled."
msgstr ""

#: buffer.md:23
msgid "buffer(:foo)"
msgstr ""

#: buffer.md:24
msgid "b = buffer(:foo)"
msgstr ""

#: buffer.md:25
msgid "puts b.duration "
msgstr ""

#: buffer.md:36 buffer.md:96
msgid "# load a 8s buffer and name it :foo"
msgstr ""

#: buffer.md:37
msgid "# return cached buffer and bind it to b"
msgstr ""

#: buffer.md:38
msgid "#=> 8.0"
msgstr ""

#: buffer.md:65
msgid "# load a 16s buffer and name it :foo"
msgstr ""

#: buffer.md:97
msgid "# (this isn't 16s as the BPM has been"
msgstr ""

#: buffer.md:98
msgid "# doubled from the default of 60)"
msgstr ""

#: buffer.md:130 buffer.md:134
msgid "# init a 8s buffer and name it :foo"
msgstr ""

#: buffer.md:131 buffer.md:135
msgid "# return cached 8s buffer (has the same duration)"
msgstr ""

#: buffer.md:132
msgid "# init a new 10s buffer and name it :foo"
msgstr ""

#: buffer.md:133
msgid "# return cached 10s buffer"
msgstr ""

#: choose.md:9
msgid "Choose an element at random from a list (array)."
msgstr ""

#: choose.md:11
msgid ""
"If no arguments are given, will return a lambda function which when called tak"
"es an argument which will be a list to be chosen from. This is useful for choo"
"sing random `onset:` vals for samples"
msgstr ""

#: choose.md:13
msgid "Always returns a single element (or nil)"
msgstr ""

#: choose.md:27 loop.md:29
msgid "loop do"
msgstr ""

#: choose.md:28
msgid "    play choose([60, 64, 67])"
msgstr ""

#: choose.md:29 choose.md:31 comment.md:25 define.md:26 uncomment.md:25
#: use_bpm.md:36 use_bpm.md:45 use_bpm.md:54 with_bpm.md:37 with_bpm.md:56
msgid "    sleep 1"
msgstr ""

#: choose.md:30
msgid "    play chord(:c, :major).choose"
msgstr ""

#: choose.md:43
msgid "#=> plays one of 60, 64 or 67 at random"
msgstr ""

#: choose.md:45
msgid "#=> You can also call .choose on the list"
msgstr ""

#: choose.md:77
msgid "# Using choose for random sample onsets"
msgstr ""

#: choose.md:79
msgid "# choose a random onset value each time"
msgstr ""

#: chord.md:9
msgid ""
"Creates an immutable ring of Midi note numbers when given a tonic note and a c"
"hord type. If only passed a chord type, will default the tonic to 0. See examp"
"les."
msgstr ""

#: chord.md:23
msgid "puts (chord :e, :minor)"
msgstr ""

#: chord.md:34
msgid "# returns a ring of midi notes - (ring 64, 67, 71)"
msgstr ""

#: chord.md:61
msgid "# Play all the notes together"
msgstr ""

#: chord.md:92
msgid "# Chord inversions (see the fn chord_invert)"
msgstr ""

#: chord.md:93
msgid "# Play the basic :e3, :minor chord - (ring 52, 55, 59)"
msgstr ""

#: chord.md:94
msgid "# Play the first inversion of :e3, :minor - (ring 55, 59, 64)"
msgstr ""

#: chord.md:95
msgid "# Play the first inversion of :e3, :minor - (ring 59, 64, 67)"
msgstr ""

#: chord.md:123
msgid "# You can create a chord without a tonic:"
msgstr ""

#: chord.md:124
msgid "#=> (ring 0, 3, 7)"
msgstr ""

#: chord.md:154
msgid "# chords are great for arpeggiators"
msgstr ""

#: chord.md:248
msgid "# Sonic Pi supports a large range of chords"
msgstr ""

#: chord.md:249
msgid "# Notice that the more exotic ones have to be surrounded by ' quotes"
msgstr ""

#: chord_degree.md:9
msgid ""
"In music we build chords from scales. For example, a C major chord is made by "
"taking the 1st, 3rd and 5th notes of the C major scale (C, E and G). If you do"
" this on a piano you might notice that you play one, skip one, play one, skip "
"one etc. If we use the same spacing and start from the second note in C major "
"(which is a D), we get a D minor chord which is the 2nd, 4th and 6th notes in "
"C major (D, F and A). We can move this pattern all the way up or down the scal"
"e to get different types of chords. `chord_degree` is a helper method that ret"
"urns a ring of midi note numbers when given a degree (starting point in a scal"
"e) which is a symbol `:i`, `:ii`, `:iii`, `:iv`, `:v`, `:vi`, `:vii` or a numb"
"er `1`-`7`. The second argument is the tonic note of the scale, the third argu"
"ment is the scale type and finally the fourth argument is number of notes to s"
"tack up in the chord. If we choose 4 notes from degree `:i` of the C major sca"
"le, we take the 1st, 3rd, 5th and 7th notes of the scale to get a C major 7 ch"
"ord."
msgstr ""

#: chord_degree.md:23
msgid "puts (chord_degree :i, :A3, :major)"
msgstr ""

#: chord_degree.md:34
msgid "# returns a ring of midi notes - (ring 57, 61, 64, 68) - an A major 7 chord"
msgstr ""

#: chord_degree.md:87
msgid "# Chord ii in A major is a B minor chord"
msgstr ""

#: chord_degree.md:114
msgid "# Chord iii in A major is a C# minor chord"
msgstr ""

#: chord_degree.md:141
msgid "# Chord iv in A major is a D major chord"
msgstr ""

#: chord_degree.md:168
msgid ""
"# Taking four notes is the default. This gives us 7th chords - here it plays a"
" C major 7"
msgstr ""

#: chord_degree.md:195
msgid "# Taking five notes gives us 9th chords - here it plays a C major 9 chord"
msgstr ""

#: chord_degree.md:222
msgid "# Play the first inversion of chord i in C major - (ring 64, 67, 72)"
msgstr ""

#: chord_invert.md:9
msgid ""
"Given a set of notes, apply a number of inversions indicated by the `shift` pa"
"rameter. Inversions being an increase to notes if `shift` is positive or decre"
"asing the notes if `shift` is negative."
msgstr ""

#: chord_invert.md:11
msgid ""
"An inversion is simply rotating the chord and shifting the wrapped notes up or"
" down an octave. For example, consider the chord :e3, :minor - `(ring 52, 55, "
"59)`. When we invert it once, we rotate the notes around to `(ring 55, 59, 52)"
"`. However, because note 52 is wrapped round, it's shifted up an octave (12 se"
"mitones) so the actual first inversion of the chord :e3, :minor is `(ring 55, "
"59, 52 + 12)` or `(ring 55, 59, 64)`."
msgstr ""

#: chord_invert.md:13
msgid ""
"Note that it's also possible to directly invert chords on creation with the `i"
"nvert:` opt - `(chord :e3, :minor, invert: 2)`"
msgstr ""

#: chord_invert.md:15 chord_names.md:11 current_beat_duration.md:13 look.md:11
#: note_range.md:11 ramp.md:11 scale_names.md:11 stretch.md:11 tick.md:11
#: tick_reset.md:11 tick_reset_all.md:11 tick_set.md:11 use_cue_logging.md:11
#: use_tuning.md:11 vector.md:11 with_cue_logging.md:11 with_tuning.md:11
msgid "Introduced in v2.6"
msgstr ""

#: chord_invert.md:27
msgid "play (chord_invert (chord :A3, \"M\"), 0)"
msgstr ""

#: chord_invert.md:28 chord_invert.md:30 control.md:28 control.md:30 kill.md:25
#: play_pattern_timed.md:32 time_warp.md:35 with_octave.md:24 with_octave.md:28
msgid "sleep 1"
msgstr ""

#: chord_invert.md:29
msgid "play (chord_invert (chord :A3, \"M\"), 1)"
msgstr ""

#: chord_invert.md:31
msgid "play (chord_invert (chord :A3, \"M\"), 2)"
msgstr ""

#: chord_invert.md:42
msgid "#No inversion     - (ring 57, 61, 64)"
msgstr ""

#: chord_invert.md:44
msgid "#First inversion  - (ring 61, 64, 69)"
msgstr ""

#: chord_invert.md:46
msgid "#Second inversion - (ring 64, 69, 73)"
msgstr ""

#: chord_names.md:9
msgid "Returns a ring containing all chord names known to Sonic Pi"
msgstr ""

#: chord_names.md:23
msgid "puts chord_names"
msgstr ""

#: chord_names.md:34
msgid "#=>  prints a list of all the chords"
msgstr ""

#: clear.md:9
msgid ""
"All settings such as the current synth, BPM, random stream and tick values wil"
"l be reset to their defaults. Consider using `reset` to reset all these values"
" to those inherited from the parent thread."
msgstr ""

#: clear.md:11 map.md:11 rand_i_look.md:13 rand_look.md:13 reset.md:11
#: run_code.md:11 run_file.md:11 scsynth_info.md:11
#: set_recording_bit_depth!.md:11 time_warp.md:21
msgid "Introduced in v2.11"
msgstr ""

#: clear.md:23
msgid "Clear wipes out the threads locals"
msgstr ""

#: clear.md:24 reset.md:24
msgid "use_synth :blade"
msgstr ""

#: clear.md:25 reset.md:25
msgid "use_octave 3"
msgstr ""

#: clear.md:27 reset.md:27
msgid "puts \"before\"        "
msgstr ""

#: clear.md:28 reset.md:28 reset.md:36
msgid "puts current_synth     "
msgstr ""

#: clear.md:29 reset.md:29 reset.md:37
msgid "puts current_octave    "
msgstr ""

#: clear.md:30 reset.md:30 reset.md:38
msgid "puts rand              "
msgstr ""

#: clear.md:31 reset.md:31 reset.md:39
msgid "puts tick              "
msgstr ""

#: clear.md:33
msgid "at do"
msgstr ""

#: clear.md:34
msgid "  use_synth :tb303"
msgstr ""

#: clear.md:35 clear.md:51
msgid "  puts rand              "
msgstr ""

#: clear.md:36
msgid "  clear"
msgstr ""

#: clear.md:37
msgid "  puts \"thread\"        "
msgstr ""

#: clear.md:40 clear.md:41 clear.md:42 clear.md:43 clear.md:46 clear.md:49
#: clear.md:50 play_pattern.md:26 play_pattern.md:27 play_pattern.md:28
#: play_pattern.md:29 play_pattern.md:30
msgid "                         "
msgstr ""

#: clear.md:44
msgid "  puts current_synth     "
msgstr ""

#: clear.md:47
msgid "  puts current_octave    "
msgstr ""

#: clear.md:52
msgid "  puts tick              "
msgstr ""

#: clear.md:67 reset.md:54 reset.md:127
msgid "#=> \"before\""
msgstr ""

#: clear.md:68 reset.md:55 reset.md:128 reset.md:145
msgid "#=> :blade"
msgstr ""

#: clear.md:70 clear.md:91 reset.md:57 reset.md:65 reset.md:130
msgid "#=> 0.75006103515625"
msgstr ""

#: clear.md:75 reset.md:135 reset.md:152
msgid "#=> 0.9287109375"
msgstr ""

#: clear.md:77 reset.md:137
msgid "#=> \"thread\""
msgstr ""

#: clear.md:80
msgid "# The clear reset the current synth to the default"
msgstr ""

#: clear.md:81
msgid "# of :beep. We are therefore ignoring any inherited"
msgstr ""

#: clear.md:82
msgid "# synth settings. It is as if the thread was a completely"
msgstr ""

#: clear.md:83
msgid "# new Run."
msgstr ""

#: clear.md:84 reset.md:63
msgid "#=> :beep"
msgstr ""

#: clear.md:86
msgid "# The current octave defaults back to 0"
msgstr ""

#: clear.md:89
msgid "# The random stream defaults back to the standard"
msgstr ""

#: clear.md:90
msgid "# stream used by every new Run."
msgstr ""

#: comment.md:9
msgid ""
"Does not evaluate any of the code within the block. However, any optional args"
" passed before the block *will* be evaluated although they will be ignored. Se"
"e `uncomment` for switching commenting off without having to remove the commen"
"t form."
msgstr ""

#: comment.md:23
msgid "comment do"
msgstr ""

#: comment.md:24 define.md:25 uncomment.md:24 with_bpm_mul.md:29
msgid "    play 50"
msgstr ""

#: comment.md:26 uncomment.md:26 with_bpm_mul.md:31
msgid "    play 62"
msgstr ""

#: comment.md:37 uncomment.md:37
msgid "# starting a block level comment:"
msgstr ""

#: comment.md:38 comment.md:40
msgid "# not played"
msgstr ""

#: comment.md:39
msgid "# no sleep happens"
msgstr ""

#: control.md:9
msgid ""
"Control a running synth node by passing new parameters to it. A synth node rep"
"resents a running synth and can be obtained by assigning the return value of a"
" call to play or sample or by specifying a parameter to the do/end block of an"
" FX. You may modify any of the parameters you can set when triggering the synt"
"h, sample or FX. See documentation for opt details. If the synth to control is"
" a chord, then control will change all the notes of that chord group at once t"
"o a new target set of notes - see example. Also, you may use the on: opt to co"
"nditionally trigger the control - see the docs for the `synth` and `sample` fn"
"s for more information."
msgstr ""

#: control.md:11
msgid ""
"If no synth to control is specified, then the last synth triggered by the curr"
"ent (or parent) thread will be controlled - see example below."
msgstr ""

#: control.md:27
msgid "my_node = play 50, release: 5, cutoff: 60"
msgstr ""

#: control.md:29
msgid "control my_node, cutoff: 70"
msgstr ""

#: control.md:31
msgid "control my_node, cutoff: 90"
msgstr ""

#: control.md:42
msgid "# Basic control"
msgstr ""

#: control.md:44
msgid ""
"# play note 50 with release of 5 and cutoff of 60. Assign return value to vari"
"able my_node"
msgstr ""

#: control.md:45
msgid "# Sleep for a second"
msgstr ""

#: control.md:46
msgid "# Now modify cutoff from 60 to 70, sound is still playing"
msgstr ""

#: control.md:47
msgid "# Sleep for another second"
msgstr ""

#: control.md:48
msgid "# Now modify cutoff from 70 to 90, sound is still playing"
msgstr ""

#: control.md:79
msgid "# Combining control with slide opts allows you to create nice transitions."
msgstr ""

#: control.md:81
msgid "# start synth and specify slide time for cutoff opt"
msgstr ""

#: control.md:82
msgid "# Change the cutoff value with a control."
msgstr ""

#: control.md:83
msgid "# Cutoff will now slide over 8 beats from 70 to 130"
msgstr ""

#: control.md:117
msgid "# Use a short slide time and many controls to create a sliding melody"
msgstr ""

#: control.md:119
msgid "# get a random ordering of a scale"
msgstr ""

#: control.md:121
msgid "# Start our synth running with a long sustain and short note slide time"
msgstr ""

#: control.md:123
msgid "# Keep quickly changing the note by ticking through notes repeatedly"
msgstr ""

#: control.md:159
msgid "# Controlling FX"
msgstr ""

#: control.md:161
msgid "# Start FX but also use the handy || goalposts"
msgstr ""

#: control.md:162
msgid "# to grab a handle on the running FX. We can call"
msgstr ""

#: control.md:163
msgid "# our handle anything we want. Here we've called it bc"
msgstr ""

#: control.md:165
msgid "# We can use our handle bc now just like we used s in the"
msgstr ""

#: control.md:166
msgid "# previous example to modify the FX as it runs."
msgstr ""

#: control.md:200
msgid "# Controlling chords"
msgstr ""

#: control.md:202 control.md:241
msgid "# start a chord"
msgstr ""

#: control.md:204
msgid "# transition to new chord."
msgstr ""

#: control.md:205 control.md:244 control.md:285 control.md:327
msgid "# Each note in the original chord is mapped onto"
msgstr ""

#: control.md:206 control.md:245 control.md:328
msgid "# the equivalent in the new chord."
msgstr ""

#: control.md:239
msgid "# Sliding between chords"
msgstr ""

#: control.md:243
msgid "# slide to new chord."
msgstr ""

#: control.md:280
msgid "# Sliding from a larger to smaller chord"
msgstr ""

#: control.md:282
msgid "# start a chord with 7 notes"
msgstr ""

#: control.md:284
msgid "# slide to new chord with fewer notes (3)"
msgstr ""

#: control.md:286
msgid "# the equivalent in the new chord using ring-like indexing."
msgstr ""

#: control.md:287
msgid "# This means that the 4th note in the original chord will"
msgstr ""

#: control.md:288
msgid "# be mapped onto the 1st note in the second chord and so-on."
msgstr ""

#: control.md:323
msgid "# Sliding from a smaller to larger chord"
msgstr ""

#: control.md:324
msgid "# start a chord with 3 notes"
msgstr ""

#: control.md:326
msgid "# slide to new chord with more notes (7)"
msgstr ""

#: control.md:329
msgid "# This means that the 4th note in the new chord"
msgstr ""

#: control.md:330
msgid "# will not sound as there is no 4th note in the"
msgstr ""

#: control.md:331
msgid "# original chord."
msgstr ""

#: control.md:366
msgid "# Changing the slide rate"
msgstr ""

#: control.md:368
msgid "# Start a synth playing with a long cutoff slide"
msgstr ""

#: control.md:369
msgid "# wait a beat"
msgstr ""

#: control.md:370
msgid "# change the cutoff so it starts sliding slowly"
msgstr ""

#: control.md:371
msgid "# wait for 3 beats"
msgstr ""

#: control.md:372
msgid "# Change the cutoff_slide - the cutoff now slides more quickly to 130"
msgstr ""

#: control.md:373
msgid "# it will now take 1 beat to slide from its *current* value"
msgstr ""

#: control.md:374
msgid "# (somewhere between 70 and 130) to 130"
msgstr ""

#: control.md:407
msgid "# Controlling the last triggered synth"
msgstr ""

#: control.md:409
msgid "# Every time a synth is triggered, Sonic Pi automatically remembers the node"
msgstr ""

#: control.md:412
msgid "# This means we don't need to use an explicit variable to control the synth"
msgstr ""

#: control.md:413
msgid "# we last triggered."
msgstr ""

#: control.md:449
msgid "# Controlling multiple synths without variables"
msgstr ""

#: control.md:451
msgid "# Trigger a beep synth"
msgstr ""

#: control.md:453
msgid "# Control last triggered synth (:beep)"
msgstr ""

#: control.md:455
msgid "# Next, trigger a dsaw synth"
msgstr ""

#: control.md:457
msgid "# Control last triggered synth (:dsaw)"
msgstr ""

#: cue.md:9
msgid ""
"Send a heartbeat synchronisation message containing the (virtual) timestamp of"
" the current thread. Useful for syncing up external threads via the `sync` fn."
" Any opts which are passed are given to the thread which syncs on the `cue_id`"
". The values of the opts must be immutable. Currently numbers, symbols, boolea"
"ns, nil and frozen strings, or vectors/rings/frozen arrays/maps of immutable v"
"alues are supported."
msgstr ""

#: cue.md:23 sync.md:23
msgid "in_thread do"
msgstr ""

#: cue.md:24 sync.md:24
msgid "    sync :foo"
msgstr ""

#: cue.md:25 sync.md:25
msgid "    sample :ambi_lunar_land"
msgstr ""

#: cue.md:28 sync.md:28 with_bpm.md:40 with_bpm.md:51
msgid "  sleep 5"
msgstr ""

#: cue.md:30 sync.md:30 with_cue_logging.md:26
msgid "  cue :foo"
msgstr ""

#: cue.md:31 rand_back.md:28 rand_back.md:29 rand_skip.md:28 status.md:24
#: status.md:25 status.md:26 status.md:27 status.md:28 status.md:29
#: status.md:30 status.md:31 status.md:32 status.md:33 status.md:34
#: status.md:35 sync.md:31 use_random_source.md:63 with_random_seed.md:33
#: with_random_source.md:42
msgid "           "
msgstr ""

#: cue.md:43
msgid "# this parks the current thread waiting for a foo cue message to be received."
msgstr ""

#: cue.md:49
msgid "# We send a cue message from the main thread."
msgstr ""

#: cue.md:50 sync.md:50
msgid "# This then unblocks the thread above and we then hear the sample"
msgstr ""

#: cue.md:87 cue.md:152 sync.md:87 sync.md:179
msgid "# Start a metronome thread"
msgstr ""

#: cue.md:88 cue.md:153 sync.md:88 sync.md:180
msgid "# Loop forever:"
msgstr ""

#: cue.md:89 sync.md:89
msgid "# sending tick heartbeat messages"
msgstr ""

#: cue.md:90 cue.md:155 sync.md:90 sync.md:182
msgid "# and sleeping for 0.5 beats between ticks"
msgstr ""

#: cue.md:94 sync.md:94
msgid "# We can now play sounds using the metronome."
msgstr ""

#: cue.md:95 cue.md:162 cue.md:169 cue.md:176 sync.md:95 sync.md:189
#: sync.md:196 sync.md:203
msgid "# In the main thread, just loop"
msgstr ""

#: cue.md:96
msgid "# waiting for :tick cue messages"
msgstr ""

#: cue.md:97 sync.md:97
msgid "# after which play the drum kick sample"
msgstr ""

#: cue.md:154 sync.md:181
msgid "# sending one of three tick heartbeat messages randomly"
msgstr ""

#: cue.md:159 sync.md:186
msgid "# We can now play sounds using the metronome:"
msgstr ""

#: cue.md:163
msgid "# waiting for :foo cue messages"
msgstr ""

#: cue.md:164 sync.md:191
msgid "# after which play the elec beep sample"
msgstr ""

#: cue.md:170
msgid "# waiting for :bar cue messages"
msgstr ""

#: cue.md:171 sync.md:198
msgid "# after which play the elec flip sample"
msgstr ""

#: cue.md:177
msgid "# waiting for :baz cue messages"
msgstr ""

#: cue.md:178 sync.md:205
msgid "# after which play the elec blup sample"
msgstr ""

#: cue.md:220
msgid "# sending tick heartbeat messages with a value :foo"
msgstr ""

#: cue.md:225
msgid "# The value for :foo can now be used in synced threads"
msgstr ""

#: cue.md:229
msgid "# play the note value from :foo"
msgstr ""

#: current_arg_checks.md:9
msgid "Returns the current arg checking setting (`true` or `false`)."
msgstr ""

#: current_arg_checks.md:11
msgid "This can be set via the fns `use_arg_checks` and `with_arg_checks`."
msgstr ""

#: current_arg_checks.md:25
msgid "puts current_arg_checks"
msgstr ""

#: current_arg_checks.md:36
msgid "# Print out the current arg check setting"
msgstr ""

#: current_beat_duration.md:9
msgid ""
"Get the duration of the current beat in seconds. This is the actual length of "
"time which will elapse with `sleep 1`."
msgstr ""

#: current_beat_duration.md:11
msgid ""
"Affected by calls to `use_bpm`, `with_bpm`, `use_sample_bpm` and `with_sample_"
"bpm`."
msgstr ""

#: current_beat_duration.md:25
msgid "use_bpm 60"
msgstr ""

#: current_beat_duration.md:26 current_beat_duration.md:29
msgid "  puts current_beat_duration"
msgstr ""

#: current_beat_duration.md:28
msgid "  use_bpm 120"
msgstr ""

#: current_beat_duration.md:44 pitch_to_ratio.md:88
msgid "#=> 0.5"
msgstr ""

#: current_bpm.md:9
msgid "Returns the current tempo as a bpm value."
msgstr ""

#: current_bpm.md:11
msgid ""
"This can be set via the fns `use_bpm`, `with_bpm`, `use_sample_bpm` and `with_"
"sample_bpm`."
msgstr ""

#: current_bpm.md:25
msgid "puts current_bpm"
msgstr ""

#: current_bpm.md:36
msgid "# Print out the current bpm"
msgstr ""

#: current_cent_tuning.md:9
msgid "Returns the cent shift value."
msgstr ""

#: current_cent_tuning.md:11
msgid "This can be set via the fns `use_cent_tuning` and `with_cent_tuning`."
msgstr ""

#: current_cent_tuning.md:25
msgid "puts current_cent_tuning"
msgstr ""

#: current_cent_tuning.md:36
msgid "# Print out the current cent shift"
msgstr ""

#: current_debug.md:9
msgid "Returns the current debug setting (`true` or `false`)."
msgstr ""

#: current_debug.md:11
msgid "This can be set via the fns `use_debug` and `with_debug`."
msgstr ""

#: current_debug.md:25
msgid "puts current_debug"
msgstr ""

#: current_debug.md:36
msgid "# Print out the current debug setting"
msgstr ""

#: current_midi_defaults.md:9
msgid "Returns the current MIDI defaults. This is a map of opt names to values"
msgstr ""

#: current_midi_defaults.md:11
msgid ""
"This can be set via the fns `use_midi_defaults`, `with_midi_defaults`, `use_me"
"rged_midi_defaults` and `with_merged_midi_defaults`."
msgstr ""

#: current_midi_defaults.md:25
msgid "use_midi_defaults channel: 1, port: \"foo\""
msgstr ""

#: current_midi_defaults.md:26 use_merged_midi_defaults.md:23
#: use_midi_defaults.md:23 with_merged_midi_defaults.md:23
#: with_midi_defaults.md:23
msgid "midi_note_on :e1"
msgstr ""

#: current_midi_defaults.md:27
msgid "current_midi_defaults"
msgstr ""

#: current_midi_defaults.md:39
msgid "# Sends MIDI :e1 note on to channel 1 on port \"foo\""
msgstr ""

#: current_midi_defaults.md:40
msgid "#=> Prints {channel: 1, port: \"foo\"}"
msgstr ""

#: current_octave.md:9
msgid "Returns the octave shift value."
msgstr ""

#: current_octave.md:11
msgid "This can be set via the fns `use_octave` and `with_octave`."
msgstr ""

#: current_octave.md:25
msgid "puts current_octave"
msgstr ""

#: current_octave.md:36
msgid "# Print out the current octave shift"
msgstr ""

#: current_random_seed.md:9
msgid "Returns the current random seed."
msgstr ""

#: current_random_seed.md:11
msgid ""
"This can be set via the fns `use_random_seed` and `with_random_seed`. It is in"
"cremented every time you use the random number generator via fns such as `choo"
"se` and `rand`."
msgstr ""

#: current_random_seed.md:25
msgid "puts current_random_seed"
msgstr ""

#: current_random_seed.md:36
msgid "# Print out the current random seed"
msgstr ""

#: current_random_seed.md:72
msgid "# Resetting the seed back to a known place"
msgstr ""

#: current_random_seed.md:73
msgid "#=>  0.75006103515625"
msgstr ""

#: current_random_seed.md:74
msgid "#=>  0.733917236328125"
msgstr ""

#: current_random_seed.md:75
msgid "# Grab the current seed"
msgstr ""

#: current_random_seed.md:76 current_random_seed.md:80
msgid "#=> 0.464202880859375"
msgstr ""

#: current_random_seed.md:77 current_random_seed.md:81
msgid "#=> 0.24249267578125"
msgstr ""

#: current_random_seed.md:78
msgid "# Restore the seed"
msgstr ""

#: current_random_seed.md:79
msgid "# we'll now get the same random values:"
msgstr ""

#: current_sample_defaults.md:9
msgid ""
"Returns the current sample defaults. This is a map of synth arg names to eithe"
"r values or functions."
msgstr ""

#: current_sample_defaults.md:11
msgid ""
"This can be set via the fns `use_sample_defaults`, `with_sample_defaults`, `us"
"e_merged_sample_defaults` and `with_merged_sample_defaults`."
msgstr ""

#: current_sample_defaults.md:13 line.md:11 mc_block_id.md:11
#: mc_block_ids.md:11 mc_block_name.md:11 mc_block_names.md:11
#: mc_camera_fixed.md:11 mc_camera_normal.md:11 mc_camera_set_location.md:11
#: mc_camera_third_person.md:11 mc_chat_post.md:11 mc_checkpoint_restore.md:11
#: mc_checkpoint_save.md:11 mc_get_block.md:11 mc_get_height.md:11
#: mc_get_pos.md:11 mc_get_tile.md:11 mc_ground_height.md:11 mc_location.md:11
#: mc_message.md:11 mc_set_area.md:11 mc_set_block.md:11 mc_set_pos.md:11
#: mc_set_tile.md:11 mc_surface_teleport.md:11 mc_teleport.md:11
#: pitch_to_ratio.md:11 spark.md:11 spark_graph.md:11 stop.md:11
#: use_sample_defaults.md:11 with_sample_defaults.md:11
msgid "Introduced in v2.5"
msgstr ""

#: current_sample_defaults.md:25
msgid "use_sample_defaults amp: 0.5, cutoff: 80"
msgstr ""

#: current_sample_defaults.md:26 sample.md:47 sample_free.md:25
#: sample_free.md:27 sample_free.md:30 stop.md:23
#: use_merged_sample_defaults.md:23 use_merged_sample_defaults.md:27
#: use_sample_defaults.md:23 use_sample_defaults.md:27
#: with_merged_sample_defaults.md:23 with_merged_sample_defaults.md:27
#: with_sample_defaults.md:23 with_sample_defaults.md:27
msgid "sample :loop_amen"
msgstr ""

#: current_sample_defaults.md:27
msgid "puts current_sample_defaults"
msgstr ""

#: current_sample_defaults.md:39
msgid "# Plays amen break with amp 0.5 and cutoff 80"
msgstr ""

#: current_sample_defaults.md:40 current_synth_defaults.md:40
msgid "#=> Prints {amp: 0.5, cutoff: 80}"
msgstr ""

#: current_sched_ahead_time.md:9
msgid "Returns the current schedule ahead time."
msgstr ""

#: current_sched_ahead_time.md:11
msgid "This can be set via the fn `set_sched_ahead_time!`."
msgstr ""

#: current_sched_ahead_time.md:25
msgid "set_sched_ahead_time! 0.5"
msgstr ""

#: current_sched_ahead_time.md:26
msgid "puts current_sched_ahead_time"
msgstr ""

#: current_sched_ahead_time.md:38
msgid "# Prints 0.5"
msgstr ""

#: current_synth.md:9
msgid "Returns the current synth name."
msgstr ""

#: current_synth.md:11
msgid "This can be set via the fns `use_synth` and `with_synth`."
msgstr ""

#: current_synth.md:25
msgid "puts current_synth"
msgstr ""

#: current_synth.md:36
msgid "# Print out the current synth name"
msgstr ""

#: current_synth_defaults.md:9
msgid ""
"Returns the current synth defaults. This is a map of synth arg names to values"
"."
msgstr ""

#: current_synth_defaults.md:11
msgid ""
"This can be set via the fns `use_synth_defaults`, `with_synth_defaults`, `use_"
"merged_synth_defaults` and `with_merged_synth_defaults`."
msgstr ""

#: current_synth_defaults.md:25
msgid "use_synth_defaults amp: 0.5, cutoff: 80"
msgstr ""

#: current_synth_defaults.md:26 play.md:32 set_cent_tuning!.md:29
#: set_cent_tuning!.md:31 use_cent_tuning.md:25 use_cent_tuning.md:27
#: use_merged_synth_defaults.md:23 use_merged_synth_defaults.md:26
#: use_merged_synth_defaults.md:29 use_merged_synth_defaults.md:32
#: use_octave.md:23 use_octave.md:25 use_synth.md:23 use_synth.md:25
#: use_synth_defaults.md:23 use_synth_defaults.md:27 use_synth_defaults.md:31
#: use_transpose.md:23 use_transpose.md:25 with_cent_tuning.md:24
#: with_cent_tuning.md:31 with_octave.md:23 with_octave.md:29 with_synth.md:23
#: with_synth.md:26 with_synth.md:33 with_synth_defaults.md:23
#: with_synth_defaults.md:27
msgid "play 50"
msgstr ""

#: current_synth_defaults.md:27
msgid "puts current_synth_defaults"
msgstr ""

#: current_synth_defaults.md:39
msgid "# Plays note 50 with amp 0.5 and cutoff 80"
msgstr ""

#: current_time.md:9
msgid ""
"Returns the current logical time. This is a 'wall-clock' time which should typ"
"ically be pretty similar to Time.now but quantised to a nearby sleep point in "
"the thread. May be quite different to Time.now within a time_warp!"
msgstr ""

#: current_time.md:11
msgid ""
"Unlike `Time.now`, Multiple calls to `current_time` with no interleaved calls "
"to `sleep` or `sync` will return the same value."
msgstr ""

#: current_time.md:25
msgid "puts current_time"
msgstr ""

#: current_time.md:36
msgid "# 2017-03-19 23:37:57 +0000"
msgstr ""

#: current_time.md:71
msgid "# The difference between current_time and Time.now"
msgstr ""

#: current_time.md:72
msgid "# See that Time.now is continuous and current_time is discrete"
msgstr ""

#: current_time.md:73
msgid "#"
msgstr ""

#: current_time.md:74
msgid "# {run: 19, time: 0.0}"
msgstr ""

#: current_time.md:75
msgid "# ├─ \"A\" 1489966042.761211"
msgstr ""

#: current_time.md:76
msgid "# ├─ \"B\" 1489966042.760181"
msgstr ""

#: current_time.md:77
msgid "# ├─ \"C\" 1489966042.761235"
msgstr ""

#: current_time.md:78
msgid "# ├─ \"D\" 1489966042.760181"
msgstr ""

#: current_time.md:79
msgid "# └─ \"E\" 1489966042.760181"
msgstr ""

#: current_transpose.md:9
msgid "Returns the current transpose value."
msgstr ""

#: current_transpose.md:11
msgid "This can be set via the fns `use_transpose` and `with_transpose`."
msgstr ""

#: current_transpose.md:25
msgid "puts current_transpose"
msgstr ""

#: current_transpose.md:36
msgid "# Print out the current transpose value"
msgstr ""

#: current_volume.md:9
msgid "Returns the current volume."
msgstr ""

#: current_volume.md:11
msgid "This can be set via the fn `set_volume!`."
msgstr ""

#: current_volume.md:25
msgid "puts current_volume"
msgstr ""

#: current_volume.md:36
msgid "# Print out the current volume"
msgstr ""

#: current_volume.md:65 look.md:79 map.md:61 ramp.md:61 ring.md:61 tick.md:39
#: tick.md:72 tick.md:114 tick_reset_all.md:49 vector.md:61
msgid "#=> 2"
msgstr ""

#: dec.md:9
msgid "Decrement a number by `1`. Equivalent to `n - 1`"
msgstr ""

#: dec.md:23
msgid "dec 1"
msgstr ""

#: dec.md:34 inc.md:61
msgid "# returns 0"
msgstr ""

#: dec.md:61
msgid "# returns -2"
msgstr ""

#: define.md:9
msgid ""
"Allows you to group a bunch of code and give it your own name for future re-us"
"e. Functions are very useful for structuring your code. They are also the gate"
"way into live coding as you may redefine a function whilst a thread is calling"
" it, and the next time the thread calls your function, it will use the latest "
"definition."
msgstr ""

#: define.md:24
msgid "  define :foo do"
msgstr ""

#: define.md:30
msgid "  foo"
msgstr ""

#: define.md:34 defonce.md:48
msgid "  3.times do"
msgstr ""

#: define.md:35
msgid "    foo"
msgstr ""

#: define.md:46 defonce.md:60
msgid "# Define a new function called foo"
msgstr ""

#: define.md:52 defonce.md:68
msgid "# Call foo on its own"
msgstr ""

#: define.md:55 defonce.md:83
msgid "# You can use foo anywhere you would use normal code."
msgstr ""

#: define.md:56 defonce.md:84
msgid "# For example, in a block:"
msgstr ""

#: defonce.md:9
msgid ""
"Allows you to assign the result of some code to a name, with the property that"
" the code will only execute once - therefore stopping re-definitions. This is "
"useful for defining values that you use in your compositions but you don't wan"
"t to reset every time you press run. You may force the block to execute again "
"regardless of whether or not it has executed once already by using the overrid"
"e option (see examples)."
msgstr ""

#: defonce.md:23
msgid "defonce :foo do "
msgstr ""

#: defonce.md:24
msgid "    sleep 1       "
msgstr ""

#: defonce.md:25 defonce.md:26 time_warp.md:39 time_warp.md:46 time_warp.md:47
#: time_warp.md:48 with_merged_midi_defaults.md:32
#: with_merged_midi_defaults.md:33 with_midi_defaults.md:33
#: with_midi_defaults.md:37
msgid "                  "
msgstr ""

#: defonce.md:27
msgid "    puts \"hello\""
msgstr ""

#: defonce.md:32 defonce.md:35 defonce.md:44
msgid "  puts foo"
msgstr ""

#: defonce.md:39
msgid "  defonce :foo do"
msgstr ""

#: defonce.md:40
msgid "    puts \"you can't redefine me\""
msgstr ""

#: defonce.md:49
msgid "    play foo "
msgstr ""

#: defonce.md:61
msgid "# Sleep for a beat in the function definition. Note that this amount"
msgstr ""

#: defonce.md:62
msgid "# of time in seconds will depend on the current BPM of the live_loop"
msgstr ""

#: defonce.md:63
msgid "# or thread calling this function."
msgstr ""

#: defonce.md:64
msgid "# Print hello"
msgstr ""

#: defonce.md:65
msgid "# Return a value of 10"
msgstr ""

#: defonce.md:69
msgid "# The run sleeps for a beat and prints \"hello\" before returning 10"
msgstr ""

#: defonce.md:71
msgid "# Try it again:"
msgstr ""

#: defonce.md:72
msgid ""
"# This time the run doesn't sleep or print anything out. However, 10 is still "
"returned."
msgstr ""

#: defonce.md:76
msgid "# Try redefining foo"
msgstr ""

#: defonce.md:81
msgid "# We still don't see any printing or sleeping, and the result is still 10"
msgstr ""

#: defonce.md:86
msgid "# play 10"
msgstr ""

#: defonce.md:134
msgid "# plays 50"
msgstr ""

#: defonce.md:136
msgid "# This redefinition doesn't work due to the behaviour of defonce"
msgstr ""

#: defonce.md:140
msgid "# Still plays 50"
msgstr ""

#: defonce.md:142
msgid "# Force definition to take place with override option"
msgstr ""

#: defonce.md:146
msgid "# plays 80"
msgstr ""

#: degree.md:9
msgid ""
"For a given scale and tonic it takes a symbol/string/number and resolves it to"
" a midi note. The degree can be either a decimal number or a roman numeral (if"
" it's a string or symbol), and may optionally be prefixed an augmentation (`a`"
"/`d` for an augmented/diminished interval, `aa`/`dd` for double augmented/dimi"
"nished or `p` for a perfect (unchanged) interval)."
msgstr ""

#: degree.md:23
msgid "play degree(:iii, :D3, :major)"
msgstr ""

#: degree.md:24
msgid "play degree(3, :C3, :minor)"
msgstr ""

#: degree.md:25
msgid "play degree('d5', :B3, :major)"
msgstr ""

#: degree.md:36
msgid "# major third up from :D3"
msgstr ""

#: degree.md:37
msgid "# minor third up from :C3"
msgstr ""

#: degree.md:38
msgid "# diminished fifth up from :B3"
msgstr ""

#: degree.md:70
msgid "# for each degree in the chord"
msgstr ""

#: degree.md:71
msgid "# add the corresponding note"
msgstr ""

#: degree.md:73
msgid "# play an F# 13+11-9 chord, using roman numeral symbols"
msgstr ""

#: degree.md:108
msgid "# the same chord as above, but using decimal number strings"
msgstr ""

#: density.md:9
msgid ""
"Runs the block `d` times with the bpm for the block also multiplied by `d`. Gr"
"eat for repeating sections a number of times faster yet keeping within a fixed"
" time. If `d` is less than 1, then time will be stretched accordingly and the "
"block will take longer to complete."
msgstr ""

#: density.md:11 rdist.md:11 use_bpm_mul.md:11 with_bpm_mul.md:11
msgid "Introduced in v2.3"
msgstr ""

#: density.md:23 use_bpm_mul.md:23 with_bpm_mul.md:23
msgid "use_bpm 60  "
msgstr ""

#: density.md:25
msgid "  density 2 do      "
msgstr ""

#: density.md:26
msgid "                    "
msgstr ""

#: density.md:27
msgid "    sample :bd_haus"
msgstr ""

#: density.md:28
msgid "    sleep 0.5       "
msgstr ""

#: density.md:39 use_bpm_mul.md:41 with_bpm_mul.md:44
msgid "# Set the BPM to 60"
msgstr ""

#: density.md:41
msgid "# BPM for block is now 120"
msgstr ""

#: density.md:42
msgid "# block is called 2.times"
msgstr ""

#: density.md:43
msgid "# sample is played twice"
msgstr ""

#: density.md:44 density.md:76
msgid "# sleep is 0.25s"
msgstr ""

#: density.md:74
msgid "# You may also pass a param to the block similar to n.times"
msgstr ""

#: density.md:75
msgid "# prints out 0, 1"
msgstr ""

#: density.md:108
msgid "# Specifying a density val of < 1 will stretch out time"
msgstr ""

#: density.md:109
msgid "# A density of 0.5 will double the length of the block's"
msgstr ""

#: density.md:110
msgid "# execution time."
msgstr ""

#: density.md:111
msgid "# plays note 80 with 2s release"
msgstr ""

#: density.md:112
msgid "# sleep is 1s"
msgstr ""

#: dice.md:9
msgid ""
"Throws a dice with the specified num_sides (defaults to `6`) and returns the s"
"core as a number between `1` and `num_sides`."
msgstr ""

#: dice.md:23
msgid "dice"
msgstr ""

#: dice.md:24 use_random_source.md:30
msgid "      "
msgstr ""

#: dice.md:35
msgid "# will return a number between 1 and 6 inclusively"
msgstr ""

#: dice.md:36
msgid "# (with an even probability distribution)."
msgstr ""

#: dice.md:63
msgid "# will return a number between 1 and 3 inclusively"
msgstr ""

#: doubles.md:9
msgid ""
"Create a ring containing the results of successive doubling of the `start` val"
"ue. If `num_doubles` is negative, will return a ring of `halves`."
msgstr ""

#: doubles.md:23
msgid "(doubles 60, 2) "
msgstr ""

#: doubles.md:34
msgid "#=> (ring 60, 120)"
msgstr ""

#: doubles.md:61
msgid "#=> (ring 1.5, 3, 6)"
msgstr ""

#: doubles.md:88
msgid "#=> (ring 1.5, 3, 6, 12, 24)"
msgstr ""

#: doubles.md:115
msgid "#=> (ring 100, 50, 25, 12.5)"
msgstr ""

#: eval_file.md:9
msgid ""
"Reads the full contents of the file with `path` and executes within the curren"
"t thread like a function call."
msgstr ""

#: eval_file.md:11 midi_sysex.md:18
msgid "Introduced in v3.2"
msgstr ""

#: eval_file.md:23
msgid "eval_file \"~/path/to/sonic-pi-code.rb\""
msgstr ""

#: eval_file.md:34 run_file.md:34
msgid "#=> will run the contents of this file"
msgstr ""

#: factor?.md:9
msgid ""
"Test to see if factor is indeed a factor of `val`. In other words, can `val` b"
"e divided exactly by factor."
msgstr ""

#: factor?.md:23
msgid "factor?(10, 2)"
msgstr ""

#: factor?.md:34
msgid "# true - 10 is a multiple of 2 (2 * 5 = 10)"
msgstr ""

#: factor?.md:61
msgid "#false - 11 is not a multiple of 2"
msgstr ""

#: factor?.md:88
msgid "#true - 2 is a multiple of 0.5 (0.5 * 4 = 2)"
msgstr ""

#: fx_names.md:9
msgid "Return a list of all the FX available"
msgstr ""

#: get.md:9
msgid ""
"Retrieve information from Time State set prior to the current time from either"
" the current or any other thread. If called multiple times will always return "
"the same value unless a call to `sleep`, `sync`, `set` or `cue` is interleaved"
". Also, calls to `get` will always return the same value across Runs for deter"
"ministic behaviour - which means you may safely use it in your compositions fo"
"r repeatable music. If no value is stored with the relevant key, will return `"
"nil`."
msgstr ""

#: get.md:11
msgid ""
"May be used within a `time_warp` to retrieve past events. If in a time warp, `"
"get` can not be called from a future position. Does not advance time."
msgstr ""

#: get.md:25
msgid "get :foo"
msgstr ""

#: get.md:36
msgid "#=> returns the last value set as :foo, or nil"
msgstr ""

#: get.md:65 set.md:65
msgid "#=> returns 3"
msgstr ""

#: get.md:102 set.md:102
msgid "#=> always returns 3 (no race conditions here!)"
msgstr ""

#: halves.md:9
msgid ""
"Create a ring containing the results of successive halving of the `start` valu"
"e. If `num_halves` is negative, will return a ring of `doubles`."
msgstr ""

#: halves.md:23
msgid "(halves 60, 2) "
msgstr ""

#: halves.md:34
msgid "#=> (ring 60, 30)"
msgstr ""

#: halves.md:61
msgid "#=> (ring 120, 60, 30)"
msgstr ""

#: halves.md:88
msgid "#=> (ring 120, 60, 30, 15, 7.5)"
msgstr ""

#: halves.md:115
msgid "#=> (ring 30, 60, 120, 240, 480)"
msgstr ""

#: hz_to_midi.md:9
msgid ""
"Convert a frequency in hz to a midi note. Note that the result isn't an intege"
"r and there is a potential for some very minor rounding errors."
msgstr ""

#: hz_to_midi.md:23
msgid "hz_to_midi(261.63)"
msgstr ""

#: hz_to_midi.md:34
msgid "#=> 60.0003"
msgstr ""

#: in_thread.md:9
msgid ""
"Execute a given block (between `do` ... `end`) in a new thread. Use for playin"
"g multiple 'parts' at once. Each new thread created inherits all the use/with "
"defaults of the parent thread such as the time, current synth, bpm, default sy"
"nth args, etc. Despite inheriting defaults from the parent thread, any modific"
"ations of the defaults in the new thread will *not* affect the parent thread. "
"Threads may be named with the `name:` optional arg. Named threads will print t"
"heir name in the logging pane when they print their activity. If you attempt t"
"o create a new named thread with a name that is already in use by another exec"
"uting thread, no new thread will be created."
msgstr ""

#: in_thread.md:11
msgid ""
"It is possible to delay the initial trigger of the thread on creation with bot"
"h the `delay:` and `sync:` opts. See their respective docstrings. If both `del"
"ay:` and `sync:` are specified, on initial thread creation first the delay wil"
"l be honoured and then the sync."
msgstr ""

#: in_thread.md:26
msgid "loop do     "
msgstr ""

#: in_thread.md:27
msgid "    play 50   "
msgstr ""

#: in_thread.md:28
msgid "    sleep 1   "
msgstr ""

#: in_thread.md:31
msgid "  loop do     "
msgstr ""

#: in_thread.md:32
msgid "    play 55"
msgstr ""

#: in_thread.md:33
msgid "    sleep 0.5"
msgstr ""

#: in_thread.md:44
msgid "# If you write two loops one after another like this,"
msgstr ""

#: in_thread.md:45
msgid "# then only the first loop will execute as the loop acts"
msgstr ""

#: in_thread.md:46
msgid "# like a trap not letting the flow of control out"
msgstr ""

#: in_thread.md:49
msgid "# This code is never executed."
msgstr ""

#: in_thread.md:101
msgid "# In order to play two loops at the same time, the first loops need to"
msgstr ""

#: in_thread.md:102
msgid "# be in a thread (note that it's probably more idiomatic to use live_loop"
msgstr ""

#: in_thread.md:103
msgid "# when performing):"
msgstr ""

#: in_thread.md:105
msgid "# By wrapping our loop in an in_thread block, we split the"
msgstr ""

#: in_thread.md:106
msgid "# control flow into two parts. One flows into the loop (a) and"
msgstr ""

#: in_thread.md:107
msgid "# the other part flows immediately after the in_thread block (b)."
msgstr ""

#: in_thread.md:108
msgid "# both parts of the control flow execute at exactly the same time."
msgstr ""

#: in_thread.md:111 in_thread.md:113
msgid "# (a)"
msgstr ""

#: in_thread.md:119
msgid "# (b)"
msgstr ""

#: in_thread.md:121
msgid "# This loop is executed thanks to the thread above"
msgstr ""

#: in_thread.md:163
msgid "# Set the bpm to be double rate"
msgstr ""

#: in_thread.md:164
msgid "# Set the current synth to be :dsaw"
msgstr ""

#: in_thread.md:166
msgid "# Create a new thread"
msgstr ""

#: in_thread.md:167
msgid "# Play note 50 at time 0"
msgstr ""

#: in_thread.md:168
msgid "# Switch to fm synth (only affects this thread)"
msgstr ""

#: in_thread.md:169
msgid "# sleep for 0.5 seconds (as we're double rate)"
msgstr ""

#: in_thread.md:170
msgid "# Play note 38 at time 0.5"
msgstr ""

#: in_thread.md:173
msgid "# Play note 62 at time 0 (with dsaw synth)"
msgstr ""

#: in_thread.md:174
msgid "# sleep 1s"
msgstr ""

#: in_thread.md:175
msgid "# Play note 67 at time 1s (also with dsaw synth)"
msgstr ""

#: in_thread.md:213
msgid "# Here we've created a named thread"
msgstr ""

#: in_thread.md:220
msgid "# This thread isn't created as the name is"
msgstr ""

#: in_thread.md:221
msgid "# the same as the previous thread which is"
msgstr ""

#: in_thread.md:222
msgid "# still executing."
msgstr ""

#: in_thread.md:268
msgid "# Named threads work well with functions for live coding:"
msgstr ""

#: in_thread.md:269
msgid "# Create a function foo"
msgstr ""

#: in_thread.md:270
msgid "# which does something simple"
msgstr ""

#: in_thread.md:271
msgid "# and sleeps for some time"
msgstr ""

#: in_thread.md:274
msgid "# Create a named thread"
msgstr ""

#: in_thread.md:275
msgid "# which loops forever"
msgstr ""

#: in_thread.md:276
msgid "# calling our function"
msgstr ""

#: in_thread.md:280
msgid "# We are now free to modify the contents of :foo and re-run the entire buffer."
msgstr ""

#: in_thread.md:281
msgid ""
"# We'll hear the effect immediately without having to stop and re-start the co"
"de."
msgstr ""

#: in_thread.md:282
msgid ""
"# This is because our fn has been redefined, (which our thread will pick up) a"
"nd"
msgstr ""

#: in_thread.md:283
msgid ""
"# due to the thread being named, the second re-run will not create a new simil"
"arly"
msgstr ""

#: in_thread.md:284
msgid ""
"# named thread. This is a nice pattern for live coding and is the basis of liv"
"e_loop."
msgstr ""

#: in_thread.md:316
msgid "#Delaying the start of a thread"
msgstr ""

#: in_thread.md:318
msgid "# this sample is not triggered at time 0 but after 1 beat"
msgstr ""

#: in_thread.md:321
msgid "# Note 80 is played at time 0"
msgstr ""

#: inc.md:9
msgid "Increment a number by `1`. Equivalent to `n + 1`"
msgstr ""

#: inc.md:23
msgid "inc 1"
msgstr ""

#: inc.md:34
msgid "# returns 2"
msgstr ""

#: kill.md:9
msgid ""
"Kill a running synth sound or sample. In order to kill a sound, you need to ha"
"ve stored a reference to it in a variable."
msgstr ""

#: kill.md:24
msgid "foo = play 50, release: 4"
msgstr ""

#: kill.md:27
msgid "kill foo"
msgstr ""

#: kill.md:37
msgid "# store a reference to a running synth in a variable called foo:"
msgstr ""

#: kill.md:40
msgid "# foo is still playing, but we can kill it early:"
msgstr ""

#: knit.md:9
msgid ""
"Knits a series of value, count pairs to create a ring buffer where each value "
"is repeated count times."
msgstr ""

#: knit.md:23
msgid "(knit 1, 5)   "
msgstr ""

#: knit.md:34
msgid "#=> (ring 1, 1, 1, 1, 1)"
msgstr ""

#: knit.md:61
msgid "#=> (ring :e2, :e2, :c2, :c2, :c2)"
msgstr ""

#: line.md:9
msgid ""
"Create a ring buffer representing a straight line between start and finish of "
"steps elements. Steps defaults to `4`. Indexes wrap around positively and nega"
"tively. Similar to `range`."
msgstr ""

#: line.md:23
msgid "(line 0, 4, steps: 4)   "
msgstr ""

#: line.md:34 line.md:88
msgid "#=> (ring 0.0, 1.0, 2.0, 3.0)"
msgstr ""

#: line.md:61
msgid "#=> (ring 5.0, 4.0, 3.0, 2.0, 1.0)"
msgstr ""

#: live_audio.md:9
msgid ""
"Create a named synthesiser which works similar to `play`, `sample` or `synth`."
" Rather than synthesising the sound mathematically or playing back recorded au"
"dio, it streams audio live from your sound card."
msgstr ""

#: live_audio.md:11
msgid ""
"However, unlike `play`, `sample` and `synth`, which allow multiple similar syn"
"ths to play at the same time (i.e. a chord) only one `live_audio` synth of a g"
"iven name may exist in the system at any one time. This is similar to `live_lo"
"op` where only one live loop of each name may exist at any one time. See examp"
"les for further information."
msgstr ""

#: live_audio.md:13
msgid ""
"An additional difference is that `live_audio` will create an infinitely long s"
"ynth rather than be timed to an envelope like the standard `synth` and `sample"
"` synths. This is particularly suitable for working with continuous incoming a"
"udio streams where the source of the audio is unknown (for example, it may be "
"a guitar, an analog synth or an electronic violin). If the source is continuou"
"s, then it may not be suited to being stitched together by successive envelope"
"d calls to something like: `synth :sound_in, attack: 0, sustain: 4, release: 0"
"`. If we were to `live_loop` this with a `sleep 4` to match the sustain durati"
"on, we would get something that emulated a continuous stream, but for certain "
"inputs you'll hear clicking at the seams between each successive call to `synt"
"h` where the final part of the audio signal from the previous synth doesn't pr"
"ecisely match up with the start of the signal in the next synth due to very mi"
"nor timing differences."
msgstr ""

#: live_audio.md:15
msgid ""
"Another important feature of `live_audio` is that it will automatically move a"
"n existing `live_audio` synth into the current FX context. This means you can "
"live code the FX chain around the live stream and it will update automatically"
". See examples."
msgstr ""

#: live_audio.md:17
msgid "To stop a `live_audio` synth, use the `:stop` arg: `live_audio :foo, :stop`."
msgstr ""

#: live_audio.md:18
msgid "."
msgstr ""

#: live_audio.md:34
msgid "live_audio :foo "
msgstr ""

#: live_audio.md:45 use_random_seed.md:39 with_fx.md:40
msgid "# Basic usage"
msgstr ""

#: live_audio.md:46 live_audio.md:145
msgid "# Play whatever audio is coming into the sound card on input 1"
msgstr ""

#: live_audio.md:74
msgid "# Specify an input"
msgstr ""

#: live_audio.md:75
msgid "# Play whatever audio is coming into the sound card on input 3"
msgstr ""

#: live_audio.md:104
msgid "# Work with stereo input"
msgstr ""

#: live_audio.md:105
msgid "# Play whatever audio is coming into the sound card on inputs 3 and 4"
msgstr ""

#: live_audio.md:106
msgid "# as a stereo stream"
msgstr ""

#: live_audio.md:144
msgid "# Switching audio contexts (i.e. changing FX)"
msgstr ""

#: live_audio.md:147
msgid "# Wait for 2 seconds then..."
msgstr ""

#: live_audio.md:150
msgid "# Add reverb to the audio from input 1"
msgstr ""

#: live_audio.md:153
msgid "# Wait for another 2 seconds then..."
msgstr ""

#: live_audio.md:155
msgid "# Remove the reverb from input 1"
msgstr ""

#: live_audio.md:188
msgid "# Working with live_loops"
msgstr ""

#: live_audio.md:191
msgid "# chooses a new FX each time round the live loop"
msgstr ""

#: live_audio.md:192
msgid "# the audio stream from input 1 will be moved to the"
msgstr ""

#: live_audio.md:193
msgid "# new FX and the old FX will complete and finish as normal."
msgstr ""

#: live_audio.md:230
msgid "# Stopping"
msgstr ""

#: live_audio.md:232
msgid "#=> start playing audio from input 1"
msgstr ""

#: live_audio.md:233
msgid "#=> start playing audio from input 2"
msgstr ""

#: live_audio.md:235
msgid "#=> wait for 3s..."
msgstr ""

#: live_audio.md:237
msgid "#=> stop playing audio from input 1"
msgstr ""

#: live_audio.md:238
msgid "#=> (live_audio :bar is still playing)"
msgstr ""

#: live_loop.md:9
msgid ""
"Loop the do/end block forever. However, unlike a basic loop, a live_loop has t"
"wo special properties. Firstly it runs in a thread - so you can have any numbe"
"r of live loops running at the same time (concurrently). Secondly, you can cha"
"nge the behaviour of a live loop whilst it is still running without needing to"
" stop it. Live loops are therefore the secret to live coding with Sonic Pi."
msgstr ""

#: live_loop.md:11
msgid ""
"As live loops are excecuted within a named in_thread, they behave similarly. S"
"ee the in_thread documentation for all the details. However, it's worth mentio"
"ning a few important points here. Firstly, only one live loop with a given nam"
"e can run at any one time. Therefore, if you define two or more `live_loop`s c"
"alled `:foo` only one will be running. Another important aspect of `live_loop`"
"s is that they manage their own thread locals set with the `use_*` and `with_*"
"` fns. This means that each `live_loop` can have its own separate default synt"
"h, BPM and sample defaults. When a `live_loop` is *first* created, it inherits"
" the thread locals from the parent thread, but once it has started, the only w"
"ay to change them is by re-defining the do/end body of the `live_loop`. See th"
"e examples below for details. Finally, as mentioned above, provided their name"
"s are different, you may have many `live_loop`s executing at once."
msgstr ""

#: live_loop.md:13
msgid ""
"A typical way of live coding with live loops is to define a number of them in "
"a buffer, hit Run to start them and then to modify their do/end blocks and the"
"n hit Run again. This will not create any more thread, but instead just modify"
" the behaviour of the existing threads. The changes will *not* happen immediat"
"ely. Instead, they will only happen the next time round the loop. This is beca"
"use the behaviour of each live loop is implemented with a standard function. W"
"hen a live loop is updated, the function definition is also updated. Each time"
" round the live loop, the function is called, so the new behviour is only obse"
"rved next time round the loop."
msgstr ""

#: live_loop.md:15
msgid ""
"Also sends a `cue` with the same name each time the `live_loop` repeats. This "
"may be used to `sync` with other threads and `live_loop`s."
msgstr ""

#: live_loop.md:17
msgid ""
"If the `live_loop` block is given a parameter, this is given the result of the"
" last run of the loop (with initial value either being `0` or an init arg). Th"
"is allows you to 'thread' values across loops."
msgstr ""

#: live_loop.md:19
msgid ""
"Finally, it is possible to delay the initial trigger of the live_loop on creat"
"ion with both the `delay:` and `sync:` opts. See their respective docstrings. "
"If both `delay:` and `sync:` are specified, on initial live_loop creation firs"
"t the delay will be honoured and then the sync."
msgstr ""

#: live_loop.md:36
msgid "live_loop :ping do "
msgstr ""

#: live_loop.md:37
msgid "  sample :elec_ping"
msgstr ""

#: live_loop.md:38 use_bpm_mul.md:30
msgid "  sleep 1          "
msgstr ""

#: live_loop.md:49
msgid "# Define and start a simple live loop"
msgstr ""

#: live_loop.md:51 live_loop.md:89
msgid "# Create a live loop called :ping"
msgstr ""

#: live_loop.md:52 live_loop.md:90
msgid "# This live loops plays the :elec_ping sample"
msgstr ""

#: live_loop.md:53
msgid "# Then sleeps for 1 beat before repeating"
msgstr ""

#: live_loop.md:87
msgid "# Every live loop must sleep or sync"
msgstr ""

#: live_loop.md:91
msgid "# However, because the do/end lock of the live loop does not"
msgstr ""

#: live_loop.md:92
msgid "# contain any calls to sleep or sync, the live loop stops at"
msgstr ""

#: live_loop.md:93
msgid "# the end of the first loop with a 'Did not sleep' error."
msgstr ""

#: live_loop.md:129
msgid "# Multiple live loops will play at the same time"
msgstr ""

#: live_loop.md:130 live_loop.md:297 osc.md:232
msgid "# Start a live loop called :foo"
msgstr ""

#: live_loop.md:135
msgid "# Start another live loop called :bar"
msgstr ""

#: live_loop.md:136
msgid "# Both :foo and :bar will be playing"
msgstr ""

#: live_loop.md:137
msgid "# at the same time."
msgstr ""

#: live_loop.md:169
msgid "# Live loops inherit external use_* thread locals"
msgstr ""

#: live_loop.md:172
msgid "# live loop :foo now has a BPM of 30"
msgstr ""

#: live_loop.md:173 live_loop.md:215
msgid "# This sleep will be for 2 seconds"
msgstr ""

#: live_loop.md:211
msgid "# Live loops can have their own thread locals"
msgstr ""

#: live_loop.md:213
msgid "# Set the BPM of live loop :foo to 30"
msgstr ""

#: live_loop.md:219
msgid "# Set the BPM of live loop :bar to 120"
msgstr ""

#: live_loop.md:221
msgid "# This sleep will be for 0.5 seconds"
msgstr ""

#: live_loop.md:253
msgid "# Live loops can pass values between iterations"
msgstr ""

#: live_loop.md:254
msgid "# pass a param (a) to the block (inits to 0)"
msgstr ""

#: live_loop.md:255
msgid "# prints out all the integers"
msgstr ""

#: live_loop.md:257
msgid "# increment a by 1 (last value is passed back into the loop)"
msgstr ""

#: live_loop.md:296
msgid "# Live loop names must be unique"
msgstr ""

#: live_loop.md:302
msgid "# Attempt to start another also called :foo"
msgstr ""

#: live_loop.md:303
msgid "# With a different do/end block"
msgstr ""

#: live_loop.md:304
msgid "# This will not start another live loop"
msgstr ""

#: live_loop.md:305
msgid "# but instead replace the behaviour of the first."
msgstr ""

#: live_loop.md:306
msgid "# There will only be one live loop running playing"
msgstr ""

#: live_loop.md:307
msgid "# The bass drum"
msgstr ""

#: live_loop.md:353
msgid "# You can sync multiple live loops together"
msgstr ""

#: live_loop.md:354
msgid "# Wait for a :bar cue event before starting :foo"
msgstr ""

#: live_loop.md:355
msgid "# Live loop :foo is therefore blocked and does"
msgstr ""

#: live_loop.md:356
msgid "# not make a sound initially"
msgstr ""

#: live_loop.md:359
msgid "# Wait for 4 beats"
msgstr ""

#: live_loop.md:361
msgid "# Start a live loop called :foo which will emit a :bar"
msgstr ""

#: live_loop.md:362
msgid "# cue message therefore releasing the :foo live loop."
msgstr ""

#: live_loop.md:363
msgid "# Live loop :foo therefore starts and also inherits the"
msgstr ""

#: live_loop.md:364
msgid "# logical time of live loop :bar."
msgstr ""

#: live_loop.md:366
msgid "# This pattern is also useful to re-sync live loops after"
msgstr ""

#: live_loop.md:367
msgid "# errors are made. For example, when modifying live loop :foo"
msgstr ""

#: live_loop.md:368
msgid "# it is possible to introduce a runtime error which will stop"
msgstr ""

#: live_loop.md:369
msgid "# :foo but not :bar (as they are separate, isolated threads)."
msgstr ""

#: live_loop.md:370
msgid "# Once the error has been fixed and the code is re-run, :foo"
msgstr ""

#: live_loop.md:371
msgid "# will automatically wait for :bar to loop round and restart"
msgstr ""

#: live_loop.md:372
msgid "# in sync with the correct virtual clock."
msgstr ""

#: load_buffer.md:9
msgid ""
"Given a path to a file, will read the contents and load it into the current bu"
"ffer. This will replace any previous content."
msgstr ""

#: load_buffer.md:23
msgid "load_buffer \"~/sonic-pi-tracks/phat-beats.rb\""
msgstr ""

#: load_buffer.md:34
msgid "# will replace content of current buffer with contents of the file"
msgstr ""

#: load_example.md:9
msgid ""
"Given a keyword representing an example, will load it into the current buffer."
" This will replace any previous content."
msgstr ""

#: load_example.md:23
msgid "load_example :rerezzed"
msgstr ""

#: load_example.md:34
msgid "# will replace content of current buffer with the rerezzed example"
msgstr ""

#: load_sample.md:9
msgid ""
"Given a path to a `.wav`, `.wave`, `.aif`, `.aiff`, `.ogg`, `.oga` or `.flac` "
"file, pre-loads the sample into memory."
msgstr ""

#: load_sample.md:11
msgid ""
"You may also specify the same set of source and filter pre-args available to `"
"sample` itself. `load_sample` will then load all matching samples. See `sample"
"`'s docs for more information."
msgstr ""

#: load_sample.md:25 load_samples.md:25 sample_loaded?.md:23
msgid "load_sample :elec_blip"
msgstr ""

#: load_sample.md:26
msgid "sample :elec_blip"
msgstr ""

#: load_sample.md:37 load_samples.md:37 sample_loaded?.md:36
msgid "# :elec_blip is now loaded and ready to play as a sample"
msgstr ""

#: load_sample.md:38 load_samples.md:38
msgid "# No delay takes place when attempting to trigger it"
msgstr ""

#: load_sample.md:71 load_samples.md:71 sample_free.md:150
msgid "# Using source and filter pre-args"
msgstr ""

#: load_sample.md:73
msgid "# loads first matching sample in \"/path/to/sample/dir\""
msgstr ""

#: load_sample.md:74 load_samples.md:74
msgid "# loads sample with index 1 in \"/path/to/sample/dir\""
msgstr ""

#: load_sample.md:75 load_samples.md:75
msgid "# loads sample with name \"foo\" in \"/path/to/sample/dir\""
msgstr ""

#: load_sample.md:76
msgid "# loads first sample with file name containing \"quux\" in \"/path/to/sample/dir\""
msgstr ""

#: load_sample.md:77
msgid "# loads first sample which matches regex /[Bb]ar/ in \"/path/to/sample/dir\""
msgstr ""

#: load_samples.md:9
msgid ""
"Given a directory containing multiple `.wav`, `.wave`, `.aif`, `.aiff`, `.ogg`"
", `.oga` or `.flac` files, pre-loads all the samples into memory."
msgstr ""

#: load_samples.md:11
msgid ""
" You may also specify the same set of source and filter pre-args available to "
"`sample` itself. `load_sample` will load all matching samples (not just the sa"
"mple `sample` would play given the same opts) - see `sample`'s docs for more i"
"nformation."
msgstr ""

#: load_samples.md:26
msgid " sample :elec_blip"
msgstr ""

#: load_samples.md:73
msgid "# loads all samples in \"/path/to/sample/dir\""
msgstr ""

#: load_samples.md:76
msgid "# loads all samples with file names containing \"quux\" in \"/path/to/sample/dir\""
msgstr ""

#: load_samples.md:77
msgid "# loads all samples which match regex /[Bb]ar/ in \"/path/to/sample/dir\""
msgstr ""

#: load_synthdefs.md:9
msgid ""
"Load all pre-compiled synth designs in the specified directory. The binary fil"
"es containing synth designs need to have the extension `.scsyndef`. This is us"
"eful if you wish to use your own SuperCollider synthesiser designs within Soni"
"c Pi."
msgstr ""

#: load_synthdefs.md:11
msgid "## Important notes"
msgstr ""

#: load_synthdefs.md:13
msgid ""
"You may not trigger external synthdefs unless you enable the following GUI pre"
"ference:"
msgstr ""

#: load_synthdefs.md:16
msgid "Studio -> Synths and FX -> Enable external synths and FX"
msgstr ""

#: load_synthdefs.md:19
msgid ""
"Also, if you wish your synth to work with Sonic Pi's automatic stereo sound in"
"frastructure *you need to ensure your synth outputs a stereo signal* to an aud"
"io bus with an index specified by a synth arg named `out_bus`. For example, th"
"e following synth would work nicely:"
msgstr ""

#: load_synthdefs.md:22
msgid "    ("
msgstr ""

#: load_synthdefs.md:23
msgid "    SynthDef(\\piTest,"
msgstr ""

#: load_synthdefs.md:24
msgid "             {|freq = 200, amp = 1, out_bus = 0 |"
msgstr ""

#: load_synthdefs.md:25
msgid "               Out.ar(out_bus,"
msgstr ""

#: load_synthdefs.md:26
msgid ""
"                      SinOsc.ar([freq,freq],0,0.5)* Line.kr(1, 0, 5, amp, done"
"Action: 2))}"
msgstr ""

#: load_synthdefs.md:27
msgid "    ).writeDefFile(\"/Users/sam/Desktop/\")"
msgstr ""

#: load_synthdefs.md:28
msgid "    )"
msgstr ""

#: load_synthdefs.md:31 play.md:18
msgid "    "
msgstr ""

#: load_synthdefs.md:45
msgid "load_synthdefs \"~/Desktop/my_noises\""
msgstr ""

#: load_synthdefs.md:56
msgid "# Load all synthdefs in my_noises folder"
msgstr ""

#: look.md:9
msgid ""
"Read and return value of default tick. If a `key` is specified, read the value"
" of that specific tick. Ticks are `in_thread` and `live_loop` local, so the ti"
"ck read will be the tick of the current thread calling `look`."
msgstr ""

#: look.md:23
msgid "puts look"
msgstr ""

#: look.md:24 look.md:25 tick_reset.md:27 tick_reset.md:29 tick_reset_all.md:28
#: tick_reset_all.md:31
msgid "  puts look"
msgstr ""

#: look.md:38
msgid "#=> 0 # look doesn't advance the tick, it just returns the current value"
msgstr ""

#: look.md:72
msgid "#=> 0 # A look is always 0 before the first tick"
msgstr ""

#: look.md:73
msgid "# advance the tick"
msgstr ""

#: look.md:74
msgid "#=> 0 # Note: a look is still 0 after the first tick."
msgstr ""

#: look.md:77
msgid "#=> 1 # making multiple calls to look doesn't affect tick value"
msgstr ""

#: look.md:112
msgid "#=> 1 (keyed look :foo has been advanced)"
msgstr ""

#: look.md:113
msgid "#=> 0 (default look hasn't been advanced)"
msgstr ""

#: look.md:114
msgid "#=> 0 (other keyed looks haven't been advanced either)"
msgstr ""

#: look.md:149
msgid "# You can call look on lists and rings"
msgstr ""

#: look.md:151
msgid "# advance the default tick"
msgstr ""

#: look.md:153
msgid "# look into the default tick to play all notes in sequence"
msgstr ""

#: look.md:156
msgid "# use the same look on another ring"
msgstr ""

#: look.md:189
msgid "# Returns numbers unchanged if single argument"
msgstr ""

#: look.md:191 tick.md:115
msgid "#=> 4"
msgstr ""

#: look.md:192
msgid "#=> -4"
msgstr ""

#: look.md:193
msgid "#=> 20.3"
msgstr ""

#: loop.md:9
msgid ""
"Given a do/end block, repeats it forever. Note that once the program enters th"
"e loop - it will not move on but will instead stay within the loop. Plain loop"
"s like this are like black holes - instead of sucking in the light they suck i"
"n the program."
msgstr ""

#: loop.md:11
msgid ""
"The loop must either `sleep` or `sync` each time round otherwise it will stop "
"and throw an error. This is to stop the loop from spinning out of control and "
"locking the system."
msgstr ""

#: loop.md:13
msgid "For a more powerful, flexible loop built for live coding see `live_loop`."
msgstr ""

#: loop.md:27
msgid "play 70      "
msgstr ""

#: loop.md:30
msgid "  play 50    "
msgstr ""

#: loop.md:36
msgid "play 80     "
msgstr ""

#: loop.md:47
msgid "# note 70 is played"
msgstr ""

#: loop.md:50
msgid "# This loop will repeat notes 50 and 62 forever"
msgstr ""

#: loop.md:56
msgid "# This is *never* played as the program is trapped in the loop above"
msgstr ""

#: map.md:9
msgid "Create a new immutable key/value map from args. "
msgstr ""

#: map.md:23
msgid "(map foo: 1, bar: 2)[:foo]"
msgstr ""

#: map.md:88 vector.md:115 vector.md:142 vector.md:169 vector.md:196
msgid "#=> nil"
msgstr ""

#: mc_block_id.md:9
msgid ""
"Given a block name or id will return a number representing the id of the block"
" or throw an exception if the name or id isn't valid"
msgstr ""

#: mc_block_id.md:23
msgid "puts mc_block_id :air"
msgstr ""

#: mc_block_id.md:88 mc_block_name.md:88
msgid "#=> Throws an invalid block id exception"
msgstr ""

#: mc_block_id.md:115 mc_block_name.md:115
msgid "#=> Throws an invalid block name exception"
msgstr ""

#: mc_block_ids.md:9
msgid ""
"Returns a list of all the valid block ids as numbers. Note not all numbers are"
" valid block ids. For example, 19 is not a valid block id."
msgstr ""

#: mc_block_ids.md:23
msgid "puts mc_block_ids"
msgstr ""

#: mc_block_ids.md:34
msgid "#=> [0, 1, 2, 3, 4, 5..."
msgstr ""

#: mc_block_name.md:9
msgid ""
"Given a block id or a block name will return a symbol representing the block n"
"ame or throw an exception if the id or name isn't valid."
msgstr ""

#: mc_block_name.md:23
msgid "puts mc_block_name :air"
msgstr ""

#: mc_block_name.md:34 mc_block_name.md:61 mc_get_block.md:34
msgid "#=> :air"
msgstr ""

#: mc_block_names.md:9
msgid "Returns a list of all the valid block names as symbols"
msgstr ""

#: mc_block_names.md:23
msgid "puts mc_block_names"
msgstr ""

#: mc_block_names.md:34
msgid "#=> [:air, :stone, :grass, :dirt, :cobblestone..."
msgstr ""

#: mc_camera_fixed.md:9
msgid "Set the camera mode to fixed."
msgstr ""

#: mc_camera_normal.md:9
msgid "Set the camera mode to normal."
msgstr ""

#: mc_camera_set_location.md:9
msgid "Move the camera to a new location."
msgstr ""

#: mc_camera_third_person.md:9
msgid "Set the camera mode to third person"
msgstr ""

#: mc_chat_post.md:9
msgid "See mc_message"
msgstr ""

#: mc_checkpoint_restore.md:9
msgid "Restore the world to the last snapshot taken with `mc_checkpoint_save`."
msgstr ""

#: mc_checkpoint_save.md:9
msgid ""
"Take a snapshot of the world and save it. Restore back with `mc_checkpoint_res"
"tore`"
msgstr ""

#: mc_get_block.md:9
msgid "Returns the type of the block at the coords `x`, `y`, `z` as a symbol."
msgstr ""

#: mc_get_block.md:23
msgid "puts mc_get_block 40, 50, 60"
msgstr ""

#: mc_get_height.md:9
msgid "See `mc_ground_height`"
msgstr ""

#: mc_get_pos.md:9
msgid "See `mc_location`"
msgstr ""

#: mc_get_tile.md:9
msgid ""
"Returns the coordinates of the nearest block that the player is next to. This "
"is more course grained than `mc_location` as it only returns whole number coor"
"dinates."
msgstr ""

#: mc_get_tile.md:23
msgid "puts mc_get_tile"
msgstr ""

#: mc_get_tile.md:34
msgid "#=> [10, 20, 101]"
msgstr ""

#: mc_ground_height.md:9
msgid "Returns the height of the ground at the specified `x` and `z` coords."
msgstr ""

#: mc_ground_height.md:23
msgid "puts mc_ground_height 40, 50"
msgstr ""

#: mc_ground_height.md:34
msgid "#=> 43 (height of world at x=40, z=50)"
msgstr ""

#: mc_location.md:9
msgid ""
"Returns a list of floats `[x, y, z]` coords of the current location for Steve."
" The coordinates are finer grained than raw block coordinates but may be used "
"anywhere you might use block coords."
msgstr ""

#: mc_location.md:23
msgid "puts mc_location   "
msgstr ""

#: mc_location.md:34
msgid "#=> [10.1, 20.67, 101.34]"
msgstr ""

#: mc_location.md:61
msgid "#=> Find the current location and store in x, y and z variables."
msgstr ""

#: mc_message.md:9
msgid ""
"Post contents of `msg` on the Minecraft chat display. You may pass multiple ar"
"guments and all will be joined to form a single message (with spaces)."
msgstr ""

#: mc_message.md:23
msgid "mc_message \"Hello from Sonic Pi\""
msgstr ""

#: mc_message.md:34
msgid "#=> Displays \"Hello from Sonic Pi\" on Minecraft's chat display"
msgstr ""

#: mc_set_area.md:9
msgid ""
"Set an area/box of blocks of type `block_name` defined by two distinct sets of"
" coordinates."
msgstr ""

#: mc_set_block.md:9
msgid ""
"Change the block type of the block at coords `x`, `y`, `z` to `block_type`. Th"
"e block type may be specified either as a symbol such as `:air` or a number. S"
"ee `mc_block_ids` and `mc_block_types` for lists of valid symbols and numbers."
msgstr ""

#: mc_set_block.md:23
msgid "mc_set_block :glass, 40, 50, 60"
msgstr ""

#: mc_set_block.md:34
msgid "#=> set block at coords 40, 50, 60 to type glass"
msgstr ""

#: mc_set_pos.md:9
msgid "See `mc_teleport`"
msgstr ""

#: mc_surface_teleport.md:9
msgid ""
"Teleports you to the specified x and z coordinates with the y automatically se"
"t to place you on the surface of the world. For example, if the x and z coords"
" target a mountain, you'll be placed on top of the mountain, not in the air or"
" under the ground. See mc_ground_height for discovering the height of the grou"
"nd at a given x, z point."
msgstr ""

#: mc_surface_teleport.md:23
msgid "mc_surface_teleport 40, 50"
msgstr ""

#: mc_surface_teleport.md:34
msgid "#=> Teleport user to coords x = 40, y = height of surface, z = 50"
msgstr ""

#: mc_teleport.md:9
msgid ""
"Magically teleport the player to the location specified by the `x`, `y`, `z` c"
"oordinates. Use this for automatically moving the player either small or large"
" distances around the world."
msgstr ""

#: mc_teleport.md:23
msgid "mc_teleport 40, 50, 60 "
msgstr ""

#: mc_teleport.md:24
msgid "                       "
msgstr ""

#: mc_teleport.md:35
msgid "# The player will be moved to the position with coords:"
msgstr ""

#: mc_teleport.md:36
msgid "# x: 40, y: 50, z: 60"
msgstr ""

#: midi.md:9
msgid ""
"Sends a MIDI note on event to *all* connected MIDI devices and *all* channels "
"and then after sustain beats sends a MIDI note off event. Ensures MIDI trigger"
" is synchronised with standard calls to play and sample. Co-operates completel"
"y with Sonic Pi's timing system including `time_warp`."
msgstr ""

#: midi.md:11
msgid ""
"If `note` is specified as `:off` then all notes will be turned off (same as `m"
"idi_all_notes_off`)."
msgstr ""

#: midi.md:26
msgid "midi :e1, sustain: 0.3, vel_f: 0.5, channel: 3"
msgstr ""

#: midi.md:37
msgid ""
"# Play E, octave 1 for 0.3 beats at half velocity on channel 3 on all connecte"
"d MIDI ports."
msgstr ""

#: midi.md:64
msgid "#=> Turn off all notes on channel 3 on all connected MIDI ports"
msgstr ""

#: midi.md:91
msgid "#=> Play note :E1 for 1 beats on channel 3 on MIDI port named \"foo\" only"
msgstr ""

#: midi.md:121
msgid "# repeatedly play a ring of octaves"
msgstr ""

#: midi_all_notes_off.md:9
msgid ""
"Sends a MIDI all notes off message to *all* connected MIDI devices. on *all* c"
"hannels. Use the `port:` and `channel:` opts to restrict which MIDI ports and "
"channels are used."
msgstr ""

#: midi_all_notes_off.md:11
msgid "When an All Notes Off event is received, all oscillators will turn off."
msgstr ""

#: midi_all_notes_off.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - All Notes Off](https://www.m"
"idi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_all_notes_off.md:28
msgid "midi_all_notes_off"
msgstr ""

#: midi_all_notes_off.md:39
msgid "#=> Turn off all notes on MIDI devices on all channels (and ports)"
msgstr ""

#: midi_all_notes_off.md:66
msgid "#=> Turn off all notes on MIDI devices on channel 2"
msgstr ""

#: midi_cc.md:9
msgid ""
"Sends a MIDI control change message to *all* connected devices on *all* channe"
"ls. Use the `port:` and `channel:` opts to restrict which MIDI ports and chann"
"els are used."
msgstr ""

#: midi_cc.md:11
msgid ""
"Control number and control value can be passed as a note such as `:e3` and dec"
"imal values will be rounded down or up to the nearest whole number - so values"
" between 3.5 and 4 will be rounded up to 4 and values between 3.49999... and 3"
" will be rounded down to 3."
msgstr ""

#: midi_cc.md:13
msgid ""
"You may also optionally pass the control value as a floating point value betwe"
"en 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between 0"
" and 127) using the `val_f:` opt."
msgstr ""

#: midi_cc.md:15
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Control change](https://www"
".midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_cc.md:30
msgid "midi_cc 100, 32 "
msgstr ""

#: midi_cc.md:41 midi_cc.md:68
msgid ""
"#=> Sends MIDI cc message to control 100 with value 32 to all ports and channe"
"ls"
msgstr ""

#: midi_cc.md:95
msgid ""
"#=> Sends MIDI cc message to control 100 with value 32 on channel 5 to all por"
"ts"
msgstr ""

#: midi_cc.md:122
msgid ""
"#=> Sends MIDI cc message to control 100 with value 102 on channel 5 to all po"
"rts"
msgstr ""

#: midi_cc.md:149
msgid ""
"#=> Sends MIDI cc message to control 100 with value 102 on channel 1 and 5 to "
"all ports"
msgstr ""

#: midi_channel_pressure.md:9
msgid ""
"Sends a MIDI channel pressure (aftertouch) message to *all* connected devices "
"on *all* channels. Use the `port:` and `channel:` opts to restrict which MIDI "
"ports and channels are used."
msgstr ""

#: midi_channel_pressure.md:11
msgid ""
"The pressure value can be passed as a note such as `:e3` and decimal values wi"
"ll be rounded down or up to the nearest whole number - so values between 3.5 a"
"nd 4 will be rounded up to 4 and values between 3.49999... and 3 will be round"
"ed down to 3."
msgstr ""

#: midi_channel_pressure.md:13 midi_poly_pressure.md:13
msgid ""
"You may also optionally pass the pressure value as a floating point value betw"
"een 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between "
"0 and 127) using the `val_f:` opt."
msgstr ""

#: midi_channel_pressure.md:15
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Channel Pressure (Aftertouc"
"h)](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_channel_pressure.md:30
msgid "midi_channel_pressure 50 "
msgstr ""

#: midi_channel_pressure.md:41
msgid ""
"#=> Sends MIDI channel pressure message with value 50 to all ports and channel"
"s"
msgstr ""

#: midi_channel_pressure.md:68
msgid ""
"#=> Sends MIDI channel pressure message with value 60 to all ports and channel"
"s"
msgstr ""

#: midi_channel_pressure.md:95
msgid ""
"#=> Sends MIDI channel pressure message with value 63.5 to all ports and chann"
"els"
msgstr ""

#: midi_channel_pressure.md:122
msgid ""
"#=> Sends MIDI channel pressure message with value 30 on channel 1 and 5 to al"
"l ports"
msgstr ""

#: midi_clock_beat.md:9
msgid ""
"Sends enough MIDI clock ticks for one beat to *all* connected MIDI devices. Us"
"e the `port:` opt to restrict which MIDI ports are used."
msgstr ""

#: midi_clock_beat.md:11
msgid ""
"The MIDI specification requires 24 clock tick events to be sent per beat. Thes"
"e can either be sent manually using `midi_clock_tick` or all 24 can be schedul"
"ed in one go using this fn. `midi_clock_beat` will therefore schedule for 24 c"
"lock ticks to be sent linearly spread over duration beats. This fn will automa"
"tically take into account the current BPM and any `time_warp`s."
msgstr ""

#: midi_clock_beat.md:26
msgid "midi_clock_beat"
msgstr ""

#: midi_clock_beat.md:37
msgid "#=> Send 24 clock ticks over a period of 1 beat"
msgstr ""

#: midi_clock_beat.md:64
msgid "#=> Send 24 clock ticks over a period of 0.5 beats"
msgstr ""

#: midi_clock_beat.md:93
msgid "# Create a live loop which continually sends out MIDI clock"
msgstr ""

#: midi_clock_beat.md:94
msgid "# events at the current BPM"
msgstr ""

#: midi_clock_beat.md:127
msgid "# Ensuring Clock Phase is Correct"
msgstr ""

#: midi_clock_beat.md:129
msgid "# Send a midi_start event the first time round the live loop only"
msgstr ""

#: midi_clock_beat.md:130
msgid "# this will not just send a steady clock beat, but also ensure"
msgstr ""

#: midi_clock_beat.md:131
msgid "# the clock phase of the MIDI device matches Sonic Pi."
msgstr ""

#: midi_clock_tick.md:9
msgid ""
"Sends a MIDI clock tick message to *all* connected devices on *all* channels. "
"Use the `port:` and `channel:` opts to restrict which MIDI ports and channels "
"are used."
msgstr ""

#: midi_clock_tick.md:11
msgid ""
"Typical MIDI devices expect the clock to send 24 ticks per quarter note (typic"
"ally a beat). See `midi_clock_beat` for a simple way of sending all the ticks "
"for a given beat."
msgstr ""

#: midi_clock_tick.md:13
msgid ""
"[MIDI 1.0 Specification - System Real-Time Messages - Timing Clock](https://ww"
"w.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_clock_tick.md:28
msgid "midi_clock_tick"
msgstr ""

#: midi_clock_tick.md:39
msgid "#=> Send an individual clock tick to all connected MIDI devices on all ports."
msgstr ""

#: midi_continue.md:9
msgid ""
"Sends the MIDI continue system message to *all* connected MIDI devices on *all"
"* ports.  Use the `port:` opt to restrict which MIDI ports are used."
msgstr ""

#: midi_continue.md:11
msgid ""
"Upon receiving the MIDI continue event, the MIDI device(s) will continue at th"
"e point the sequence was stopped."
msgstr ""

#: midi_continue.md:13
msgid ""
"[MIDI 1.0 Specification - System Real-Time Messages - Continue](https://www.mi"
"di.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_continue.md:28
msgid "midi_continue"
msgstr ""

#: midi_continue.md:39
msgid "#=> Send continue message to all connected MIDI devices"
msgstr ""

#: midi_local_control_off.md:9
msgid ""
"Sends a MIDI local control off message to *all* connected devices on *all* cha"
"nnels. Use the `port:` and `channel:` opts to restrict which MIDI ports and ch"
"annels are used."
msgstr ""

#: midi_local_control_off.md:11
msgid ""
"All devices on a given channel will respond only to data received over MIDI. P"
"layed data, etc. will be ignored. See `midi_local_control_on` to enable local "
"control."
msgstr ""

#: midi_local_control_off.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - Local Control Off](https://w"
"ww.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_local_control_off.md:28
msgid "midi_local_control_off"
msgstr ""

#: midi_local_control_off.md:39
msgid "#=> Disable local control on MIDI devices on all channels (and ports)"
msgstr ""

#: midi_local_control_off.md:66
msgid "#=> Disable local control on MIDI devices on channel 2"
msgstr ""

#: midi_local_control_on.md:9
msgid ""
"Sends a MIDI local control on message to *all* connected devices on *all* chan"
"nels. Use the `port:` and `channel:` opts to restrict which MIDI ports and cha"
"nnels are used."
msgstr ""

#: midi_local_control_on.md:11
msgid ""
"All devices on a given channel will respond both to data received over MIDI an"
"d played data, etc. See `midi_local_control_off` to disable local control."
msgstr ""

#: midi_local_control_on.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - Local Control On](https://ww"
"w.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_local_control_on.md:28
msgid "midi_local_control_on"
msgstr ""

#: midi_local_control_on.md:39
msgid "#=> Enable local control on MIDI devices on all channels (and ports)"
msgstr ""

#: midi_local_control_on.md:66
msgid "#=> Enable local control on MIDI devices on channel 2"
msgstr ""

#: midi_mode.md:9
msgid ""
"Sends the Omni/Mono/Poly MIDI mode message to *all* connected MIDI devices on "
"*all* channels. Use the `port:` and `channel:` opts to restrict which MIDI por"
"ts and channels are used."
msgstr ""

#: midi_mode.md:11
msgid "Valid modes are:"
msgstr ""

#: midi_mode.md:13
msgid ":omni_off - Omni Mode Off"
msgstr ""

#: midi_mode.md:14
msgid ":omni_on  - Omni Mode On"
msgstr ""

#: midi_mode.md:15
msgid ""
":mono     - Mono Mode On (Poly Off). Set num_chans: to be the number of channe"
"ls to use (Omni Off) or 0 (Omni On). Default for num_chans: is 16."
msgstr ""

#: midi_mode.md:16
msgid ":poly     - Poly Mode On (Mono Off)"
msgstr ""

#: midi_mode.md:18
msgid "Note that this fn also includes the behaviour of `midi_all_notes_off`."
msgstr ""

#: midi_mode.md:20
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - Omni Mode Off | Omni Mode On"
" | Mono Mode On (Poly Off) | Poly Mode On](https://www.midi.org/specifications"
"/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_mode.md:35
msgid "midi_mode :omni_on"
msgstr ""

#: midi_mode.md:46
msgid "#=> Turn Omni Mode On on all ports and channels"
msgstr ""

#: midi_mode.md:73
msgid "#=> Mono Mode On, Omni off using 5 channels."
msgstr ""

#: midi_mode.md:100
msgid "#=> Mono Mode On, Omni on."
msgstr ""

#: midi_mode.md:127
msgid "#=> Mono Mode On, Omni off using 16 channels (the default) ."
msgstr ""

#: midi_note_off.md:9
msgid ""
"Sends the MIDI note off message to *all* connected devices on *all* channels. "
"Use the `port:` and `channel:` opts to restrict which MIDI ports and channels "
"are used."
msgstr ""

#: midi_note_off.md:11
msgid ""
"Note and release velocity values can be passed as a note symbol such as `:e3` "
"or a number. Decimal values will be rounded down or up to the nearest whole nu"
"mber - so values between 3.5 and 4 will be rounded up to 4 and values between "
"3.49999... and 3 will be rounded down to 3. These values will also be clipped "
"within the range 0->127 so all values lower then 0 will be increased to 0 and "
"all values greater than 127 will be reduced to 127."
msgstr ""

#: midi_note_off.md:13
msgid ""
"The `release_velocity` param may be omitted - in which case it will default to"
" 127 unless you supply it as a named opt via the keys `velocity:` or `vel_f:`."
msgstr ""

#: midi_note_off.md:15
msgid ""
"You may also optionally pass the release velocity value as a floating point va"
"lue between 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values "
"between 0 and 127) using the `vel_f:` opt."
msgstr ""

#: midi_note_off.md:17
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Note off event](https://www"
".midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_note_off.md:32
msgid "midi_note_off :e3"
msgstr ""

#: midi_note_off.md:43
msgid ""
"#=> Sends MIDI note off for :e3 with the default release velocity of 127 to al"
"l ports and channels"
msgstr ""

#: midi_note_off.md:70
msgid "#=> Sends MIDI note off on :e3 with velocity 12 on all channels"
msgstr ""

#: midi_note_off.md:97
msgid "#=> Sends MIDI note off on :e3 with velocity 12 to channel 3"
msgstr ""

#: midi_note_off.md:124
msgid "#=> Sends MIDI note on for :e3 with release velocity 100"
msgstr ""

#: midi_note_off.md:151
msgid ""
"#=> Scales release velocity 0.8 to MIDI value 102 and sends MIDI note off for "
":e3 with release velocity 102"
msgstr ""

#: midi_note_off.md:178
msgid ""
"#=> Rounds params up or down to the nearest whole number and sends MIDI note o"
"ff for note 60 with velocity 51"
msgstr ""

#: midi_note_off.md:205
msgid "#=> Send MIDI note off on :e3 to channels 1, 3, 5 on all connected ports"
msgstr ""

#: midi_note_off.md:232
msgid ""
"#=> Send MIDI note off on :e3 to on all channels on ports named \"foo\" and \"bar"
"\""
msgstr ""

#: midi_note_off.md:259
msgid "#=> Send MIDI note off on :e3 only on channel 1 on port \"foo\""
msgstr ""

#: midi_note_on.md:9
msgid ""
"Sends a MIDI Note On Event to *all* connected devices on *all* channels. Use t"
"he `port:` and `channel:` opts to indepently restrict which MIDI ports and cha"
"nnels are used."
msgstr ""

#: midi_note_on.md:11
msgid ""
"Note and velocity values can be passed as a note symbol such as `:e3` or a MID"
"I number such as 52. Decimal values will be rounded down or up to the nearest "
"whole number - so values between 3.5 and 4 will be rounded up to 4 and values "
"between 3.49999... and 3 will be rounded down to 3. These values will also be "
"clipped within the range 0->127 so all values lower than 0 will be increased t"
"o 0 and all values greater than 127 will be reduced to 127."
msgstr ""

#: midi_note_on.md:13
msgid ""
"The `velocity` param may be omitted - in which case it will default to 127 unl"
"ess you supply it as an opt via the keys `velocity:` or `vel_f:`."
msgstr ""

#: midi_note_on.md:15
msgid ""
"You may also optionally pass the velocity value as a floating point value betw"
"een 0 and 1 such as 0.2 or 0.785 (which will be linearly mapped to MIDI values"
" between 0 and 127) using the vel_f: opt."
msgstr ""

#: midi_note_on.md:17
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Note on event](https://www."
"midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_note_on.md:32
msgid "midi_note_on :e3 "
msgstr ""

#: midi_note_on.md:43
msgid ""
"#=> Sends MIDI note on :e3 with the default velocity of 12 to all ports and ch"
"annels"
msgstr ""

#: midi_note_on.md:70
msgid "#=> Sends MIDI note on :e3 with velocity 12 to all channels"
msgstr ""

#: midi_note_on.md:97
msgid "#=> Sends MIDI note on :e3 with velocity 12 on channel 3"
msgstr ""

#: midi_note_on.md:124
msgid "#=> Sends MIDI note on for :e3 with velocity 100"
msgstr ""

#: midi_note_on.md:151
msgid ""
"#=> Scales velocity 0.8 to MIDI value 102 and sends MIDI note on for :e3 with "
"velocity 102"
msgstr ""

#: midi_note_on.md:178
msgid ""
"#=> Rounds params up or down to the nearest whole number and sends MIDI note o"
"n for note 60 with velocity 51"
msgstr ""

#: midi_note_on.md:205
msgid "#=> Send MIDI note :e3 on to channels 1, 3, 5 on all connected ports"
msgstr ""

#: midi_note_on.md:232
msgid "#=> Send MIDI note :e3 on to on all channels on ports named \"foo\" and \"bar\""
msgstr ""

#: midi_note_on.md:259
msgid "#=> Send MIDI note :e3 on only on channel 1 on port \"foo\""
msgstr ""

#: midi_notes.md:9
msgid ""
"Create a new immutable ring buffer of notes from args. Indexes wrap around pos"
"itively and negatively. Final ring consists only of MIDI numbers and nil."
msgstr ""

#: midi_notes.md:11 rand_back.md:11 rand_reset.md:11 rand_skip.md:11
#: ratio_to_pitch.md:11 set_mixer_control!.md:11
msgid "Introduced in v2.7"
msgstr ""

#: midi_notes.md:23
msgid "(midi_notes :d3, :d4, :d5)"
msgstr ""

#: midi_notes.md:34
msgid "#=> (ring 50, 62, 74)"
msgstr ""

#: midi_notes.md:61
msgid "#=> (ring 50, 62, nil)"
msgstr ""

#: midi_pc.md:9
msgid ""
"Sends a MIDI program change message to *all* connected devices on *all* channe"
"ls. Use the `port:` and `channel:` opts to restrict which MIDI ports and chann"
"els are used."
msgstr ""

#: midi_pc.md:11
msgid ""
"Program number can be passed as a note such as `:e3` and decimal values will b"
"e rounded down or up to the nearest whole number - so values between 3.5 and 4"
" will be rounded up to 4 and values between 3.49999... and 3 will be rounded d"
"own to 3."
msgstr ""

#: midi_pc.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Program change](https://www"
".midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_pc.md:16
msgid "Introduced in v3.0.2"
msgstr ""

#: midi_pc.md:28
msgid "midi_pc 100 "
msgstr ""

#: midi_pc.md:39 midi_pc.md:66
msgid "#=> Sends MIDI pc message to all ports and channels"
msgstr ""

#: midi_pc.md:93 midi_pc.md:120
msgid "#=> Sends MIDI pc message on channel 5 to all ports"
msgstr ""

#: midi_pc.md:147
msgid "#=> Sends MIDI pc message on channel 1 and 5 to all ports"
msgstr ""

#: midi_pitch_bend.md:9
msgid ""
"Sends a MIDI pitch bend message to *all* connected devices on *all* channels. "
"Use the `port:` and `channel:` opts to restrict which MIDI ports and channels "
"are used."
msgstr ""

#: midi_pitch_bend.md:11
msgid ""
"Delta value is between 0 and 1 with 0.5 representing no pitch bend, 1 max pitc"
"h bend and 0 minimum pitch bend."
msgstr ""

#: midi_pitch_bend.md:13
msgid ""
"Typical MIDI values such as note or cc are represented with 7 bit numbers whic"
"h translates to the range 0-127. This makes sense for keyboards which have at "
"most 88 keys. However, it translates to a poor resolution when working with pi"
"tch bend. Therefore, pitch bend is unlike most MIDI values in that it has a mu"
"ch greater range: 0 - 16383 (by virtue of being represented by 14 bits)."
msgstr ""

#: midi_pitch_bend.md:15
msgid ""
"* It is also possible to specify the delta value as a (14 bit) MIDI pitch bend"
" value between 0 and 16383 using the `delta_midi:` opt."
msgstr ""

#: midi_pitch_bend.md:16
msgid "* When using the `delta_midi:` opt no pitch bend is the value 8192"
msgstr ""

#: midi_pitch_bend.md:18
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Pitch Bend Change](https://"
"www.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_pitch_bend.md:33
msgid "midi_pitch_bend 0 "
msgstr ""

#: midi_pitch_bend.md:44
msgid "#=> Sends MIDI pitch bend message with value 0 to all ports and channels"
msgstr ""

#: midi_pitch_bend.md:71
msgid "#=> Sends MIDI pitch bend message with value 16383 to all ports and channels"
msgstr ""

#: midi_pitch_bend.md:98 midi_pitch_bend.md:125
msgid "#=> Sends MIDI pitch bend message with value 8192 to all ports and channels"
msgstr ""

#: midi_pitch_bend.md:152
msgid "#=> Sends MIDI pitch bend message with value 0 on channel 1 and 5 to all ports"
msgstr ""

#: midi_poly_pressure.md:9
msgid ""
"Sends a MIDI polyphonic key pressure message to *all* connected devices on *al"
"l* channels. Use the `port:` and `channel:` opts to restrict which MIDI ports "
"and channels are used."
msgstr ""

#: midi_poly_pressure.md:11
msgid ""
"Note number and pressure value can be passed as a note such as `:e3` and decim"
"al values will be rounded down or up to the nearest whole number - so values b"
"etween 3.5 and 4 will be rounded up to 4 and values between 3.49999... and 3 w"
"ill be rounded down to 3."
msgstr ""

#: midi_poly_pressure.md:15
msgid ""
"[MIDI 1.0 Specification - Channel Voice Messages - Polyphonic Key Pressure (Af"
"tertouch)](https://www.midi.org/specifications/item/table-1-summary-of-midi-me"
"ssage)"
msgstr ""

#: midi_poly_pressure.md:30
msgid "midi_poly_pressure 100, 32 "
msgstr ""

#: midi_poly_pressure.md:41 midi_poly_pressure.md:68
msgid ""
"#=> Sends a MIDI poly key pressure message to control note 100 with value 32 t"
"o all ports and channels"
msgstr ""

#: midi_poly_pressure.md:95
msgid ""
"#=> Sends MIDI poly key pressure message to control note 100 with value 32 on "
"channel 5 to all ports"
msgstr ""

#: midi_poly_pressure.md:122
msgid ""
"#=> Sends a MIDI poly key pressure message to control note 100 with value 102 "
"on channel 5 to all ports"
msgstr ""

#: midi_poly_pressure.md:149
msgid ""
"#=> Sends MIDI poly key pressure message to control note 100 with value 102 on"
" channel 1 and 5 to all ports"
msgstr ""

#: midi_raw.md:9
msgid ""
"Sends the raw MIDI message to *all* connected MIDI devices. Gives you direct a"
"ccess to sending the individual bytes of a MIDI message. Typically this should"
" be rarely used - prefer the other `midi_` fns where possible."
msgstr ""

#: midi_raw.md:11
msgid ""
"A raw MIDI message consists of multiple bytes as numbers in decimal notation ("
"i.e. 176), hex (0xb0) or binary (0b10110000)."
msgstr ""

#: midi_raw.md:13
msgid ""
"See https://www.midi.org/specifications/item/table-1-summary-of-midi-message f"
"or a summary of MIDI messages and their corresponding byte structures."
msgstr ""

#: midi_raw.md:28
msgid "midi_raw 176, 121, 0 "
msgstr ""

#: midi_raw.md:39 midi_raw.md:93 midi_raw.md:120
msgid "#=> Sends the MIDI reset command"
msgstr ""

#: midi_raw.md:66
msgid ""
"#=> Sends the MIDI reset command (values are rounded down, up and down respect"
"ively)"
msgstr ""

#: midi_reset.md:9
msgid ""
"Sends a MIDI reset all controllers message to *all* connected devices on *all*"
" channels. Use the `port:` and `channel:` opts to restrict which MIDI ports an"
"d channels are used."
msgstr ""

#: midi_reset.md:11
msgid "All controller values are reset to their defaults."
msgstr ""

#: midi_reset.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - Reset All Controllers](https"
"://www.midi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_reset.md:28
msgid "midi_reset"
msgstr ""

#: midi_reset.md:39
msgid "#=> Reset MIDI devices on all channels (and ports)"
msgstr ""

#: midi_reset.md:66
msgid "#=> Reset MIDI devices on channel 2"
msgstr ""

#: midi_sound_off.md:9
msgid ""
"Sends a MIDI sound off message to *all* connected devices on *all* channels. U"
"se the `port:` and `channel:` opts to restrict which MIDI ports and channels a"
"re used."
msgstr ""

#: midi_sound_off.md:11
msgid ""
"All oscillators will turn off, and their volume envelopes are set to zero as s"
"oon as possible."
msgstr ""

#: midi_sound_off.md:13
msgid ""
"[MIDI 1.0 Specification - Channel Mode Messages - All Sound Off](https://www.m"
"idi.org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_sound_off.md:28
msgid "midi_sound_off"
msgstr ""

#: midi_sound_off.md:39
msgid "#=> Silence MIDI devices on all ports and channels"
msgstr ""

#: midi_sound_off.md:66
msgid "#=> Silence MIDI devices on channel 2"
msgstr ""

#: midi_start.md:9
msgid ""
"Sends the MIDI start system message to *all* connected MIDI devices on *all* p"
"orts.  Use the `port:` opt to restrict which MIDI ports are used."
msgstr ""

#: midi_start.md:11
msgid ""
"Start the current sequence playing. (This message should be followed with call"
"s to `midi_clock_tick` or `midi_clock_beat`)."
msgstr ""

#: midi_start.md:13 midi_stop.md:13
msgid ""
"[MIDI 1.0 Specification - System Real-Time Messages - Start](https://www.midi."
"org/specifications/item/table-1-summary-of-midi-message)"
msgstr ""

#: midi_start.md:28
msgid "midi_start"
msgstr ""

#: midi_start.md:39
msgid "#=> Send start message to all connected MIDI devices"
msgstr ""

#: midi_stop.md:9
msgid ""
"Sends the MIDI stop system message to *all* connected MIDI devices on *all* po"
"rts.  Use the `port:` opt to restrict which MIDI ports are used."
msgstr ""

#: midi_stop.md:11
msgid "Stops the current sequence."
msgstr ""

#: midi_stop.md:28
msgid "midi_stop"
msgstr ""

#: midi_stop.md:39
msgid "#=> Send stop message to all connected MIDI devices"
msgstr ""

#: midi_sysex.md:9
msgid "Sends the MIDI SysEx message to *all* connected MIDI devices."
msgstr ""

#: midi_sysex.md:11
msgid ""
"MIDI SysEx messages, unlike all other MIDI messages, are variable in length. T"
"hey allow MIDI device manufacturers to define device-specific messages, for ex"
"ample loading/saving patches, or programming device features such as illuminat"
"ed buttons."
msgstr ""

#: midi_sysex.md:13
msgid ""
"Floats will be rounded up or down to the nearest whole number e.g. 176.1 -> 17"
"6, 120.5 -> 121, 0.49 -> 0."
msgstr ""

#: midi_sysex.md:15
msgid ""
"Non-number values will be automatically turned into numbers prior to sending t"
"he event if possible (if this conversion does not work an Error will be thrown"
")."
msgstr ""

#: midi_sysex.md:30
msgid ""
"midi_sysex 0xf0, 0x00, 0x20, 0x6b, 0x7f, 0x42, 0x02, 0x00, 0x10, 0x77, 0x11, 0"
"xf7 "
msgstr ""

#: midi_sysex.md:41
msgid "#=> Program an Arturia Beatstep controller to turn the eighth pad pink"
msgstr ""

#: midi_to_hz.md:9
msgid "Convert a midi note to hz"
msgstr ""

#: midi_to_hz.md:23
msgid "midi_to_hz(60)"
msgstr ""

#: midi_to_hz.md:34
msgid "#=> 261.6256"
msgstr ""

#: ndefine.md:9
msgid ""
"Does nothing. Use to stop a define from actually defining. Simpler than wrappi"
"ng whole define in a comment block or commenting each individual line out."
msgstr ""

#: note.md:9
msgid ""
"Takes a midi note, a symbol (e.g. `:C`) or a string (e.g. `\"C\"`) and resolves "
"it to a midi note. You can also pass an optional `octave:` parameter to get th"
"e midi note for a given octave. Please note - `octave:` param overrides any oc"
"tave specified in a symbol i.e. `:c3`. If the note is `nil`, `:r` or `:rest`, "
"then `nil` is returned (`nil` represents a rest)"
msgstr ""

#: note.md:24
msgid "puts note(60)"
msgstr ""

#: note.md:25
msgid "puts note(:C)"
msgstr ""

#: note.md:26
msgid "puts note(:C4)"
msgstr ""

#: note.md:27
msgid "puts note('C')"
msgstr ""

#: note.md:37
msgid "# These all return 60 which is the midi number for middle C (octave 4)"
msgstr ""

#: note.md:73
msgid "# returns 60 - octave param has no effect if we pass in a number"
msgstr ""

#: note.md:76
msgid ""
"# These all return 36 which is the midi number for C2 (two octaves below middl"
"e C)"
msgstr ""

#: note.md:78
msgid "# note the octave param overrides any octaves specified in a symbol"
msgstr ""

#: note_info.md:9
msgid ""
"Returns an instance of `SonicPi::Note`. Please note - `octave:` param override"
"s any octave specified in a symbol i.e. `:c3`"
msgstr ""

#: note_info.md:23
msgid "puts note_info(:C, octave: 2)"
msgstr ""

#: note_info.md:36
msgid "# returns #<SonicPi::Note :C2>"
msgstr ""

#: note_range.md:9
msgid ""
"Produces a ring of all the notes between a low note and a high note. By defaul"
"t this is chromatic (all the notes) but can be filtered with a pitches: argume"
"nt. This opens the door to arpeggiator style sequences and other useful patter"
"ns. If you try to specify only pitches which aren't in the range it will raise"
" an error - you have been warned!"
msgstr ""

#: note_range.md:23
msgid "(note_range :c4, :c5)"
msgstr ""

#: note_range.md:34
msgid "# => (ring 60,61,62,63,64,65,66,67,68,69,70,71,72)"
msgstr ""

#: note_range.md:61
msgid "# => (ring 60,64,67,72)"
msgstr ""

#: note_range.md:88
msgid "# => (ring 60,64,67,72,76,79,84)"
msgstr ""

#: note_range.md:115
msgid "# => (ring 60,62,64,65,67,69,71,72)"
msgstr ""

#: note_range.md:142
msgid "# => (ring 60,67,72)"
msgstr ""

#: note_range.md:173
msgid "# try changing the chord"
msgstr ""

#: octs.md:9
msgid "Create a ring of successive octaves starting at `start` for `num_octaves`. "
msgstr ""

#: octs.md:23
msgid "(octs 60, 2) "
msgstr ""

#: octs.md:34
msgid "#=> (ring 60, 72)"
msgstr ""

#: octs.md:61
msgid "#=> (ring 52, 64, 76)"
msgstr ""

#: on.md:9
msgid ""
"Optionally evaluate the block depending on the truthiness of the supplied cond"
"ition. The truthiness rules are as follows: all values are seen as true except"
" for: false, nil and 0. Lambdas will be automatically called and the truthines"
"s of their results used."
msgstr ""

#: on.md:23
msgid "on true do"
msgstr ""

#: on.md:24
msgid "  play 70    "
msgstr ""

#: on.md:36
msgid "#=> will play 70 as true is truthy"
msgstr ""

#: on.md:66
msgid "#=> will play 70 as 1 is truthy"
msgstr ""

#: on.md:96
msgid "#=> will *not* play 70 as 0 is not truthy"
msgstr ""

#: on.md:126
msgid "#=> will *not* play 70 as false is not truthy"
msgstr ""

#: on.md:156
msgid "#=> will *not* play 70 as nil is not truthy"
msgstr ""

#: on.md:186
msgid "#=> will play 70 as the lambda returns a truthy value"
msgstr ""

#: on.md:216
msgid "#=> will *not* play 70 as the lambda does not return a truthy value"
msgstr ""

#: on.md:246
msgid "#=> will maybe play 70 depending on the choice in the lambda"
msgstr ""

#: one_in.md:9
msgid ""
"Returns `true` or `false` with a specified probability - it will return true e"
"very one in num times where num is the param you specify"
msgstr ""

#: one_in.md:23
msgid "one_in 2"
msgstr ""

#: one_in.md:34
msgid "# will return true with a probability of 1/2, false with probability 1/2"
msgstr ""

#: one_in.md:61
msgid "# will return true with a probability of 1/3, false with a probability of 2/3"
msgstr ""

#: one_in.md:88
msgid ""
"# will return true with a probability of 1/100, false with a probability of 99"
"/100"
msgstr ""

#: osc.md:9
msgid ""
"Sends an OSC message to the current host and port specified by `use_osc` or `w"
"ith_osc`."
msgstr ""

#: osc.md:11
msgid ""
"OSC (Open Sound Control) is a simple way of passing messages between two separ"
"ate programs on the same computer or even on different computers via a local n"
"etwork or even the internet. `osc` enables you to send well-timed OSC messages"
" from within Sonic Pi. `osc` will ensure that the OSC message is sent at the c"
"orrect time using the same timing system shared with the synthesis functionali"
"ty via `sample`, `synth` and friends. `osc` even works seamlessly within `time"
"_warp` - see examples."
msgstr ""

#: osc.md:13
msgid ""
"A typical OSC message has two parts: a descriptive `path` which looks simalar "
"to a URL (website address), and an optional list of `arguments` that are eithe"
"r numbers or strings."
msgstr ""

#: osc.md:15
msgid "For example, a hypothetical synth program might accept this OSC message:"
msgstr ""

#: osc.md:17
msgid "`/set/filter lowpass 80 0.5`"
msgstr ""

#: osc.md:19
msgid "where `/set/filter` is the path, and `lowpass`, `80`, and `0.5` are three"
msgstr ""

#: osc.md:20
msgid "arguments. This can be sent from within Sonic Pi by writing:"
msgstr ""

#: osc.md:22 osc.md:29
msgid "`osc \"/set/filter\", \"lowpass\", 80, 0.5`"
msgstr ""

#: osc.md:24
msgid ""
"However, in order to send the OSC message you must first specify where to send"
" it to. This is achieved by specifying both the host (the machine's internet a"
"ddress) and the port that the remote OSC server is listening on. This is confi"
"gured using `use_osc` or `with_osc`. So, if our synth program was running on a"
" machine on the local network with IP address `10.0.1.5` on port `5100` we cou"
"ld send our OSC message to it with the following:"
msgstr ""

#: osc.md:27
msgid "`use_osc \"10.0.1.5\", 5100`"
msgstr ""

#: osc.md:32
msgid ""
"Note, by default, Sonic Pi listens for OSC messages on port `4560`, so you may"
" send messages to an external machine running Sonic Pi if you know the IP addr"
"ess of that external machine. Any OSC messages received on port `4559` are aut"
"omatically converted to standard cue events and displayed in the GUI's cue log"
". This also means that you can use `sync` to wait for the next incoming OSC me"
"ssage with a given path (see example)."
msgstr ""

#: osc.md:34
msgid ""
"Finally, it is also very useful to send OSC messages to aother programs on the"
" same computer. This can be achieved by specifying \"localhost\" as the hostname"
" and the port as normal (depending on which port the other program is listenin"
"g on)."
msgstr ""

#: osc.md:36
msgid ""
"See `osc_send` for a version which allows you to specify the hostname and port"
" directly (ignoring any values set via `use_osc` or `with_osc`)."
msgstr ""

#: osc.md:38
msgid ""
"For further information see the OSC spec: [http://opensoundcontrol.org/spec-1_"
"0](http://opensoundcontrol.org/spec-1_0)"
msgstr ""

#: osc.md:55 use_osc.md:35 with_osc.md:23
msgid "use_osc \"localhost\", 7000 "
msgstr ""

#: osc.md:56 use_osc.md:36
msgid "osc \"/foo/bar\"            "
msgstr ""

#: osc.md:57 use_osc.md:37 with_osc.md:32 with_osc.md:33
msgid "                            "
msgstr ""

#: osc.md:68 use_osc.md:48
msgid "# Send a simple OSC message to another program on the same machine"
msgstr ""

#: osc.md:70 osc.md:108 use_osc.md:50 use_osc.md:88 use_osc.md:171
#: use_osc.md:175 use_osc.md:228
msgid "# Specify port 7000 on this machine"
msgstr ""

#: osc.md:71 osc.md:109 osc.md:150 use_osc.md:51 use_osc.md:89 use_osc.md:130
msgid "# Send an OSC message with path \"/foo/bar\""
msgstr ""

#: osc.md:72 use_osc.md:52
msgid "# and no arguments"
msgstr ""

#: osc.md:106 use_osc.md:86
msgid "# Send an OSC messages with arguments to another program on the same machine"
msgstr ""

#: osc.md:110 osc.md:151 use_osc.md:90 use_osc.md:131
msgid "# and three arguments:"
msgstr ""

#: osc.md:111 osc.md:152 use_osc.md:91 use_osc.md:132
msgid "# 1) The whole number (integer) 1"
msgstr ""

#: osc.md:112 osc.md:153
msgid "# 2) The fractional number (float) 3.89"
msgstr ""

#: osc.md:113 osc.md:154 use_osc.md:93 use_osc.md:134
msgid "# 3) The string \"baz\""
msgstr ""

#: osc.md:147 use_osc.md:127
msgid ""
"# Send an OSC messages with arguments to another program on a different machin"
"e"
msgstr ""

#: osc.md:149 use_osc.md:129
msgid "# Specify port 7000 on the machine with address 10.0.1.5"
msgstr ""

#: osc.md:189
msgid "# OSC messages honour the timing system"
msgstr ""

#: osc.md:191
msgid "# Send an OSC message with path /foo/bar at *exactly* the"
msgstr ""

#: osc.md:192
msgid "# same time as note 60 is played"
msgstr ""

#: osc.md:194 osc.md:279
msgid "# Wait for 1 beat"
msgstr ""

#: osc.md:196
msgid "# Send an OSC message with path /baz/quux at *exactly* the"
msgstr ""

#: osc.md:197
msgid "# same time as note 72 is played"
msgstr ""

#: osc.md:230
msgid "# Send a incrementing OSC counter"
msgstr ""

#: osc.md:233
msgid "# Send an OSC message with the path /counter"
msgstr ""

#: osc.md:234
msgid "# with successive whole numbers (0, 1, 2, 3.. etc.)"
msgstr ""

#: osc.md:235
msgid "# each time round the live loop"
msgstr ""

#: osc.md:236
msgid "# Repeat the live loop every 1 beat"
msgstr ""

#: osc.md:273
msgid "# OSC messages can be sent from within time_warp"
msgstr ""

#: osc.md:276
msgid "# Send an OSC message with path /foo/bar at 0.5 beats"
msgstr ""

#: osc.md:282
msgid "# Send an OSC message with path /baz/quux at 0.9 beats"
msgstr ""

#: osc_send.md:9
msgid ""
"Similar to `osc` except ignores any `use_osc` settings and sends the OSC messa"
"ge directly to the specified `hostname` and `port`."
msgstr ""

#: osc_send.md:11
msgid "See `osc` for more information."
msgstr ""

#: osc_send.md:25
msgid "osc_send \"localhost\", 7000, \"/foo/baz\" "
msgstr ""

#: osc_send.md:36
msgid "# Send an OSC message to port 7000 on the same machine"
msgstr ""

#: osc_send.md:67
msgid "# set hostname and port"
msgstr ""

#: osc_send.md:68 with_osc.md:49
msgid "# Send an OSC message to port 7010"
msgstr ""

#: osc_send.md:70 use_osc.md:172 with_osc.md:45 with_osc.md:52
msgid "# Send an OSC message to port 7000"
msgstr ""

#: osc_send.md:71
msgid "# (ignores use_osc settings)"
msgstr ""

#: pick.md:9
msgid ""
"Pick n elements from list or ring. Unlike shuffle, after each element has been"
" picked, it is 'returned' to the list so it may be picked again. This means th"
"ere may be duplicates in the result. If n is greater than the size of the ring"
"/list then duplicates are guaranteed to be in the result."
msgstr ""

#: pick.md:11
msgid "If `n` isn't supplied it defaults to a size of 1."
msgstr ""

#: pick.md:13
msgid ""
"If no arguments are given, will return a lambda function which when called tak"
"es an argument which will be a list to be picked from. This is useful for choo"
"sing random `onset:` vals for samples."
msgstr ""

#: pick.md:15
msgid "Always returns a list-like thing (either an array or ring)"
msgstr ""

#: pick.md:29
msgid "puts [1, 2, 3, 4, 5].pick(3)"
msgstr ""

#: pick.md:40
msgid "#=> [4, 4, 3]"
msgstr ""

#: pick.md:67
msgid "#=> (ring 4, 4, 3)"
msgstr ""

#: pick.md:94
msgid "#=> (ring 2, 2, 1, 1, 1)"
msgstr ""

#: pick.md:121
msgid "#=> (ring 3)"
msgstr ""

#: pick.md:151
msgid "# Using pick for random sample onsets"
msgstr ""

#: pick.md:153
msgid "# pick a random onset value each time"
msgstr ""

#: pitch_to_ratio.md:9
msgid ""
"Convert a midi note to a ratio which when applied to a frequency will scale th"
"e frequency by the number of semitones. Useful for changing the pitch of a sam"
"ple by using it as a way of generating the rate."
msgstr ""

#: pitch_to_ratio.md:23
msgid "pitch_to_ratio 12"
msgstr ""

#: pitch_to_ratio.md:34
msgid "#=> 2.0"
msgstr ""

#: pitch_to_ratio.md:61
msgid "#=> 1.05946"
msgstr ""

#: pitch_to_ratio.md:115
msgid "# Plays :ambi_choir 3 semitones above default."
msgstr ""

#: pitch_to_ratio.md:145
msgid "# Play a chromatic scale of semitones"
msgstr ""

#: pitch_to_ratio.md:146
msgid "# For each note in the range 0->16"
msgstr ""

#: pitch_to_ratio.md:147
msgid "# play :ambi_choir at the relative pitch"
msgstr ""

#: pitch_to_ratio.md:148
msgid "# and wait between notes"
msgstr ""

#: play.md:9
msgid ""
"Play note with current synth. Accepts a set of standard options which include "
"control of an amplitude envelope with `attack:`, `decay:`, `sustain:` and `rel"
"ease:` phases. These phases are triggered in order, so the duration of the sou"
"nd is attack + decay + sustain + release times. The duration of the sound does"
" not affect any other notes. Code continues executing whilst the sound is play"
"ing through its envelope phases."
msgstr ""

#: play.md:11
msgid ""
"If `duration:` is supplied and `sustain:` isn't, it causes `sustain:` to be se"
"t so that all four phases add up to the duration."
msgstr ""

#: play.md:13 play_chord.md:11 play_pattern_timed.md:13
msgid ""
"Accepts optional args for modification of the synth being played. See each syn"
"th's documentation for synth-specific opts. See `use_synth` and `with_synth` f"
"or changing the current synth."
msgstr ""

#: play.md:15
msgid ""
"If note is `nil`, `:r` or `:rest`, play is ignored and treated as a rest. Also"
", if the `on:` opt is specified and returns `false`, or `nil` then play is sim"
"ilarly ignored and treated as a rest."
msgstr ""

#: play.md:17
msgid ""
"Note that the default opts listed are only a guide to the most common opts acr"
"oss all the synths. Not all synths support all the default opts and each synth"
" typically supports many more opts specific to that synth. For example, the `:"
"tb303` synth supports 45 unique opts. For a full list of a synth's opts see it"
"s documentation in the Help system."
msgstr ""

#: play.md:43
msgid "# Plays note 50 on the current synth"
msgstr ""

#: play.md:70
msgid "# Plays note 50 with a fade-in time of 1s"
msgstr ""

#: play.md:97
msgid "# Play note 62 in the left ear with a fade-out time of 3s."
msgstr ""

#: play.md:130 synth.md:236
msgid "# controlling a synth synchronously"
msgstr ""

#: play.md:136 synth.md:241
msgid "# This is triggered after 1.5s from start"
msgstr ""

#: play.md:171 synth.md:275
msgid "# Controlling a synth asynchronously"
msgstr ""

#: play.md:173 sample.md:511 synth.md:277
msgid "# This block is run in an implicit in_thread"
msgstr ""

#: play.md:174 sample.md:512 synth.md:278
msgid "# and therefore is asynchronous"
msgstr ""

#: play.md:179 synth.md:282
msgid "# This is triggered after 0.5s from start"
msgstr ""

#: play_chord.md:9
msgid "Play a list of notes at the same time."
msgstr ""

#: play_chord.md:25
msgid "play_chord [40, 45, 47]"
msgstr ""

#: play_chord.md:29 play_pattern_timed.md:31
msgid "play 40"
msgstr ""

#: play_chord.md:30
msgid "play 45"
msgstr ""

#: play_chord.md:31
msgid "play 47"
msgstr ""

#: play_chord.md:43 play_chord.md:81 play_pattern_timed.md:49
#: play_pattern_timed.md:97 play_pattern_timed.md:145
msgid "# same as:"
msgstr ""

#: play_pattern.md:9
msgid "Play list of notes with the current synth one after another with a sleep of 1"
msgstr ""

#: play_pattern.md:11
msgid ""
"Accepts optional args for modification of the synth being played. See each syn"
"th's documentation for synth-specific opts. See use_synth and with_synth for c"
"hanging the current synth."
msgstr ""

#: play_pattern.md:25
msgid "play_pattern [40, 41, 42]"
msgstr ""

#: play_pattern.md:41
msgid "# Same as:"
msgstr ""

#: play_pattern.md:42
msgid "#   play 40"
msgstr ""

#: play_pattern.md:43 play_pattern.md:45
msgid "#   sleep 1"
msgstr ""

#: play_pattern.md:44
msgid "#   play 41"
msgstr ""

#: play_pattern.md:46
msgid "#   play 42"
msgstr ""

#: play_pattern.md:73
msgid "# You can use keyword notes"
msgstr ""

#: play_pattern.md:100
msgid "# Supports the same arguments as play:"
msgstr ""

#: play_pattern_timed.md:9
msgid ""
"Play each note in a list of notes one after another with specified times betwe"
"en them. The notes should be a list of MIDI numbers, symbols such as :E4 or ch"
"ords such as chord(:A3, :major) - identical to the first parameter of the play"
" function. The times should be a list of times between the notes in beats."
msgstr ""

#: play_pattern_timed.md:11
msgid ""
"If the list of times is smaller than the number of gaps between notes, the lis"
"t is repeated again. If the list of times is longer than the number of gaps be"
"tween notes, then some of the times are ignored. See examples for more detail."
msgstr ""

#: play_pattern_timed.md:27
msgid "play_pattern_timed [40, 42, 44, 46], [1, 2, 3]"
msgstr ""

#: play_pattern_timed.md:33
msgid "play 42"
msgstr ""

#: play_pattern_timed.md:34 sample_free.md:26 sample_free.md:28
#: sample_free_all.md:25 with_synth.md:24 with_synth.md:27 with_synth.md:31
msgid "sleep 2"
msgstr ""

#: play_pattern_timed.md:35
msgid "play 44"
msgstr ""

#: play_pattern_timed.md:36 reset_mixer!.md:25
msgid "sleep 3"
msgstr ""

#: play_pattern_timed.md:37
msgid "play 46"
msgstr ""

#: play_pattern_timed.md:189
msgid "#same as:"
msgstr ""

#: print.md:9
msgid ""
"Displays the information you specify as a string inside the output pane. This "
"can be a number, symbol, or a string itself. Useful for debugging. Synonym for"
" `puts`."
msgstr ""

#: print.md:23 puts.md:23
msgid "print \"hello there\"  "
msgstr ""

#: print.md:34 puts.md:34
msgid "#=> will print the string \"hello there\" to the output pane"
msgstr ""

#: print.md:61 puts.md:61
msgid "#=> will print the number 5 to the output pane"
msgstr ""

#: print.md:88 puts.md:88
msgid "#=> will print the contents of foo to the output pane"
msgstr ""

#: puts.md:9
msgid ""
"Displays the information you specify as a string inside the output pane. This "
"can be a number, symbol, or a string itself. Useful for debugging. Synonym for"
" `print`."
msgstr ""

#: quantise.md:9
msgid "Round value to the nearest multiple of step resolution."
msgstr ""

#: quantise.md:23
msgid "quantise(10, 1)"
msgstr ""

#: quantise.md:34
msgid "# 10 is already a multiple of 1, so returns 10"
msgstr ""

#: quantise.md:61
msgid "# Returns 9.9 which is 1.1 * 9"
msgstr ""

#: quantise.md:88
msgid "# 13.3"
msgstr ""

#: quantise.md:115
msgid "# 13.4"
msgstr ""

#: quantise.md:142
msgid "# 13.2"
msgstr ""

#: quantise.md:169
msgid "# 13.5"
msgstr ""

#: ramp.md:9
msgid ""
"Create a new immutable ramp vector from args. Indexes always return first or l"
"ast value if out of bounds."
msgstr ""

#: ramp.md:23
msgid "(ramp 1, 2, 3)[0]"
msgstr ""

#: rand.md:9
msgid ""
"Given a max number, produces a float between `0` and the supplied max value. I"
"f max is a range, produces a float within the range. With no args returns a ra"
"ndom value between `0` and `1`."
msgstr ""

#: rand.md:23
msgid "print rand(0.5)"
msgstr ""

#: rand.md:34 rand_look.md:36 rand_look.md:67
msgid "#=> will print a number like 0.375030517578125 to the output pane"
msgstr ""

#: rand_back.md:9
msgid ""
"Roll the random generator back essentially 'undoing' the last call to `rand`. "
"You may specify an amount to roll back allowing you to skip back n calls to `r"
"and`."
msgstr ""

#: rand_back.md:25 rand_back.md:31 rand_back.md:32 rand_reset.md:24
#: rand_reset.md:25 rand_reset.md:26 rand_reset.md:28 rand_skip.md:25
#: rand_skip.md:30 use_random_seed.md:26 use_random_source.md:46
#: use_random_source.md:47 use_random_source.md:48 use_random_source.md:51
#: use_random_source.md:52 use_random_source.md:55 use_random_source.md:56
#: use_random_source.md:62 with_random_seed.md:24 with_random_seed.md:27
#: with_random_seed.md:32 with_random_source.md:25 with_random_source.md:26
#: with_random_source.md:27 with_random_source.md:30 with_random_source.md:31
#: with_random_source.md:34 with_random_source.md:35 with_random_source.md:41
msgid "  puts rand"
msgstr ""

#: rand_back.md:27
msgid "  rand_back"
msgstr ""

#: rand_back.md:43
msgid "# Basic rand stream rollback"
msgstr ""

#: rand_back.md:45 rand_back.md:94 rand_reset.md:39 rand_reset.md:44
#: rand_skip.md:43 rand_skip.md:92 rand_skip.md:99
msgid "# prints 0.75006103515625"
msgstr ""

#: rand_back.md:47
msgid "# roll random stream back one"
msgstr ""

#: rand_back.md:48 rand_back.md:100 rand_skip.md:102
msgid "# the result of the next call to rand will be"
msgstr ""

#: rand_back.md:49
msgid "# exactly the same as the previous call"
msgstr ""

#: rand_back.md:51
msgid "# prints 0.75006103515625 again!"
msgstr ""

#: rand_back.md:52 rand_back.md:95 rand_reset.md:40 rand_skip.md:93
msgid "# prints 0.733917236328125"
msgstr ""

#: rand_back.md:92
msgid "# Jumping back multiple places in the rand stream"
msgstr ""

#: rand_back.md:96 rand_reset.md:41 rand_skip.md:48 rand_skip.md:94
msgid "# prints 0.464202880859375"
msgstr ""

#: rand_back.md:97 rand_reset.md:42 rand_skip.md:95
msgid "# prints 0.24249267578125"
msgstr ""

#: rand_back.md:99
msgid "# roll random stream back three places"
msgstr ""

#: rand_back.md:101
msgid "# exactly the same as the result 3 calls to"
msgstr ""

#: rand_back.md:102
msgid "# rand ago."
msgstr ""

#: rand_back.md:104
msgid "# prints  0.733917236328125 again!"
msgstr ""

#: rand_back.md:105
msgid "# prints  0.464202880859375"
msgstr ""

#: rand_i.md:9
msgid ""
"Given a max number, produces a whole number between `0` and the supplied max v"
"alue exclusively. If max is a range produces an int within the range. With no "
"args returns either `0` or `1`"
msgstr ""

#: rand_i.md:23
msgid "print rand_i(5)"
msgstr ""

#: rand_i.md:34 rand_i_look.md:36 rand_i_look.md:67 rand_i_look.md:70
msgid "#=> will print either 0, 1, 2, 3, or 4 to the output pane"
msgstr ""

#: rand_i_look.md:9
msgid ""
"Given a max number, produces a whole number between `0` and the supplied max v"
"alue exclusively. If max is a range produces an int within the range. With no "
"args returns either `0` or `1`."
msgstr ""

#: rand_i_look.md:11
msgid ""
"Does not consume a random value from the stream. Therefore, multiple sequentia"
"l calls to `rand_i_look` will all return the same value."
msgstr ""

#: rand_i_look.md:25
msgid "print rand_i_look(5)"
msgstr ""

#: rand_i_look.md:68 rand_i_look.md:69 rand_look.md:68 rand_look.md:69
msgid "#=> will print the same number again"
msgstr ""

#: rand_i_look.md:71
msgid "#=> will print the same number as the previous statement"
msgstr ""

#: rand_look.md:9
msgid ""
"Given a max number, produces a number between `0` and the supplied max value e"
"xclusively. If max is a range produces an int within the range. With no args r"
"eturns a value between `0` and `1`."
msgstr ""

#: rand_look.md:11
msgid ""
"Does not consume a random value from the stream. Therefore, multiple sequentia"
"l calls to `rand_look` will all return the same value."
msgstr ""

#: rand_look.md:25
msgid "print rand_look(0.5)"
msgstr ""

#: rand_look.md:70
msgid "#=> will print a different random number"
msgstr ""

#: rand_look.md:71
msgid "#=> will print the same number as the previous line again."
msgstr ""

#: rand_reset.md:9
msgid ""
"Resets the random stream to the last specified seed. See `use_random_seed` for"
" changing the seed."
msgstr ""

#: rand_reset.md:23
msgid "puts rand"
msgstr ""

#: rand_reset.md:27
msgid "  rand_reset "
msgstr ""

#: rand_reset.md:43 rand_skip.md:97
msgid "# reset the random stream"
msgstr ""

#: rand_skip.md:9
msgid ""
"Jump the random generator forward essentially skipping the next call to `rand`"
". You may specify an amount to jump allowing you to skip n calls to `rand`."
msgstr ""

#: rand_skip.md:27
msgid "  rand_skip"
msgstr ""

#: rand_skip.md:41
msgid "# Basic rand stream skip"
msgstr ""

#: rand_skip.md:45
msgid "# jump random stream forward one"
msgstr ""

#: rand_skip.md:46
msgid "# typically the next rand is 0.733917236328125"
msgstr ""

#: rand_skip.md:90
msgid "# Jumping forward multiple places in the rand stream"
msgstr ""

#: rand_skip.md:101
msgid "# jump random stream forward three places"
msgstr ""

#: rand_skip.md:103
msgid "# exactly the same as if rand had been called"
msgstr ""

#: rand_skip.md:104
msgid "# three times"
msgstr ""

#: range.md:9
msgid ""
"Create a new ring buffer from the range arguments (start, finish and step size"
"). Step size defaults to `1`. Indexes wrap around positively and negatively"
msgstr ""

#: range.md:23
msgid "(range 1, 5)   "
msgstr ""

#: range.md:34
msgid "#=> (ring 1, 2, 3, 4)"
msgstr ""

#: range.md:61
msgid "#=> (ring 1, 2, 3, 4, 5)"
msgstr ""

#: range.md:88
msgid "#=> (ring 1, 3)"
msgstr ""

#: range.md:115
msgid "#=> (ring 1, -1, -3)"
msgstr ""

#: range.md:142
msgid "#=> -3"
msgstr ""

#: ratio_to_pitch.md:9
msgid ""
"Convert a frequency ratio to a midi note which when added to a note will trans"
"pose the note to match the frequency ratio."
msgstr ""

#: ratio_to_pitch.md:23
msgid "ratio_to_pitch 2"
msgstr ""

#: ratio_to_pitch.md:34
msgid "#=> 12.0"
msgstr ""

#: ratio_to_pitch.md:61
msgid "#=> -12.0"
msgstr ""

#: rdist.md:9
msgid ""
"Returns a random number within the range with width around centre. If optional"
" arg `step:` is used, the result is quantised by step."
msgstr ""

#: rdist.md:23
msgid "print rdist(1, 0)"
msgstr ""

#: rdist.md:34
msgid "#=> will print a number between -1 and 1"
msgstr ""

#: rdist.md:61
msgid "#=> centre defaults to 0 so this is the same as rdist(1, 0)"
msgstr ""

#: rdist.md:91
msgid "#=> Will play :c3 with random L/R panning"
msgstr ""

#: reset.md:9
msgid ""
"All settings such as the current synth, BPM, random stream and tick values wil"
"l be reset to the values inherited from the parent thread. Consider using `cle"
"ar` to reset all these values to their defaults."
msgstr ""

#: reset.md:33
msgid "reset"
msgstr ""

#: reset.md:35
msgid "puts \"after\"         "
msgstr ""

#: reset.md:50
msgid "# Basic Reset"
msgstr ""

#: reset.md:62
msgid "#=> \"after\""
msgstr ""

#: reset.md:140
msgid "# The call to reset ensured that the current"
msgstr ""

#: reset.md:141
msgid "# synth was returned to the the state at the"
msgstr ""

#: reset.md:142
msgid "# time this thread was started. Thus any calls"
msgstr ""

#: reset.md:143
msgid "# to use_synth between this line and the start"
msgstr ""

#: reset.md:144
msgid "# of the thread are ignored"
msgstr ""

#: reset.md:148
msgid "# The call to reset ensured"
msgstr ""

#: reset.md:149
msgid "# that the random stream was reset"
msgstr ""

#: reset.md:150
msgid "# to the same state as it was when"
msgstr ""

#: reset.md:151
msgid "# the current thread was started"
msgstr ""

#: reset_mixer!.md:9
msgid ""
"The main mixer is the final mixer that all sound passes through. This fn reset"
"s it to its default set - undoing any changes made via set_mixer_control!"
msgstr ""

#: reset_mixer!.md:23
msgid "set_mixer_control! lpf: 70"
msgstr ""

#: reset_mixer!.md:24 reset_mixer!.md:27
msgid "sample :loop_amen         "
msgstr ""

#: reset_mixer!.md:26
msgid "reset_mixer!              "
msgstr ""

#: reset_mixer!.md:38
msgid "# LPF cutoff value of main mixer is now 70"
msgstr ""

#: reset_mixer!.md:39
msgid "# :loop_amen sample is played with low cutoff"
msgstr ""

#: reset_mixer!.md:41
msgid "# mixer is now reset to default values"
msgstr ""

#: reset_mixer!.md:42
msgid "# :loop_amen sample is played with normal cutoff"
msgstr ""

#: rest?.md:9
msgid ""
"Given a note or an args map, returns true if it represents a rest and false if"
" otherwise"
msgstr ""

#: rest?.md:23
msgid "puts rest? nil"
msgstr ""

#: rest?.md:34 rest?.md:61 rest?.md:88 rest?.md:169 rest?.md:196
msgid "# true"
msgstr ""

#: rest?.md:115 rest?.md:142 rest?.md:223
msgid "# false"
msgstr ""

#: ring.md:9
msgid ""
"Create a new immutable ring buffer from args. Indexes wrap around positively a"
"nd negatively"
msgstr ""

#: ring.md:23
msgid "(ring 1, 2, 3)[0]"
msgstr ""

#: rrand.md:9
msgid ""
"Given two numbers, this produces a float between the supplied min and max valu"
"es exclusively. Both min and max need to be supplied. For random integers, see"
" `rrand_i`. If optional arg `step:` is used, the result is quantised by step."
msgstr ""

#: rrand.md:23
msgid "print rrand(0, 10)"
msgstr ""

#: rrand.md:34
msgid "#=> will print a number like 8.917730007820797 to the output pane"
msgstr ""

#: rrand.md:64
msgid ""
"#=> Will play a random non-integer midi note between C4 (60) and C5 (72) such "
"as 67.3453 or 71.2393"
msgstr ""

#: rrand_i.md:9
msgid ""
"Given two numbers, this produces a whole number between the min and max you su"
"pplied inclusively. Both min and max need to be supplied. For random floats, s"
"ee `rrand`"
msgstr ""

#: rrand_i.md:23
msgid "print rrand_i(0, 10)"
msgstr ""

#: rrand_i.md:34
msgid ""
"#=> will print a random number between 0 and 10 (e.g. 4, 0 or 10) to the outpu"
"t pane"
msgstr ""

#: rrand_i.md:64
msgid "#=> Will play a random midi note between C4 (60) and C5 (72)"
msgstr ""

#: rt.md:9
msgid ""
"Real time representation. Returns the amount of beats for the value in real-ti"
"me seconds. Useful for bypassing any bpm scaling"
msgstr ""

#: rt.md:25 use_bpm_mul.md:25 with_bpm_mul.md:25
msgid "  sleep 1     "
msgstr ""

#: rt.md:27
msgid "  sleep rt(1) "
msgstr ""

#: rt.md:28 with_debug.md:32 with_transpose.md:29
msgid "  play 72"
msgstr ""

#: rt.md:38
msgid "# modifies all time to be half"
msgstr ""

#: rt.md:40
msgid "# actually sleeps for half of a second"
msgstr ""

#: rt.md:42
msgid "# bypasses bpm scaling and sleeps for a second"
msgstr ""

#: run_code.md:9
msgid ""
"Executes the code passed as a string in a new Run. This works as if the code w"
"as in a buffer and Run button was pressed."
msgstr ""

#: run_code.md:23
msgid "run_code \"sample :ambi_lunar_land\""
msgstr ""

#: run_code.md:34
msgid "#=> will play the :ambi_lunar_land sample"
msgstr ""

#: run_code.md:65
msgid "# Works with any amount of code:"
msgstr ""

#: run_code.md:69
msgid "# will play 60 8 times"
msgstr ""

#: run_file.md:9
msgid ""
"Reads the full contents of the file with `path` and executes it in a new Run. "
"This works as if the code in the file was in a buffer and Run button was press"
"ed."
msgstr ""

#: run_file.md:23
msgid "run_file \"~/path/to/sonic-pi-code.rb\""
msgstr ""

#: sample.md:9
msgid ""
"Play back a recorded sound file (sample). Sonic Pi comes with lots of great sa"
"mples included (see the section under help) but you can also load and play `.w"
"av`, `.wave`, `.aif`, `.aiff`, `.ogg`, `.oga` or `.flac` files from anywhere o"
"n your computer too. To play a built-in sample use the corresponding keyword s"
"uch as `sample :bd_haus`. To play any file on your computer use a full path su"
"ch as `sample \"/path/to/sample.wav\"`."
msgstr ""

#: sample.md:11
msgid ""
"There are many opts for manipulating the playback. For example, the `rate:` op"
"t affects both the speed and the pitch of the playback. To control the rate of"
" the sample in a pitch-meaningful way take a look at the `rpitch:` opt."
msgstr ""

#: sample.md:13
msgid ""
"The sampler synth has three separate envelopes - one for amplitude, one for a "
"low pass filter and another for a high pass filter. These work very similar to"
" the standard synth envelopes except for two major differences. Firstly, the e"
"nvelope times do not stretch or shrink to match the BPM. Secondly, the sustain"
" time by default stretches to make the envelope fit the length of the sample. "
"This is explained in detail in the tutorial."
msgstr ""

#: sample.md:15
msgid ""
"Samples are loaded on-the-fly when first requested (and subsequently remembere"
"d). If the sample loading process takes longer than the schedule ahead time, t"
"he sample trigger will be skipped rather than be played late and out of time. "
"To avoid this you may preload any samples you wish to work with using `load_sa"
"mple` or `load_samples`."
msgstr ""

#: sample.md:17
msgid ""
"It is possible to set the `start:` and `finish:` positions within the sample t"
"o play only a sub-section of it. These values can be automatically chosen base"
"d on an onset detection algorithm which will essentially isolate each individu"
"al drum or synth hit in the sample and let you access each one by an integer i"
"ndex (floats will be rounded to the nearest integer value). See the `onset:` d"
"ocstring and examples for more information."
msgstr ""

#: sample.md:19
msgid ""
"Finally, the sampler supports a powerful filtering system to make it easier to"
" work with large folders of samples. The filter commands must be used before t"
"he first standard opt. There are six kinds of filter parameters you may use:"
msgstr ""

#: sample.md:21
msgid ""
"1. Folder strings - `\"/foo/bar\"` - which will add all samples within the folde"
"r to the set of candidates."
msgstr ""

#: sample.md:22
msgid ""
"2. Recursive folder strings - `\"/foo/bar/**\"` - Folder strings ending with `**"
"` will add all samples contained within all subfolders (searched recursively)."
msgstr ""

#: sample.md:23
msgid ""
"3. Sample strings - `\"/path/to/sample.wav\"` - which will add the specific samp"
"le to the set of candidates."
msgstr ""

#: sample.md:24
msgid ""
"4. Other strings - `\"foobar\"` - which will filter the candidates based on whet"
"her the filename contains the string."
msgstr ""

#: sample.md:25
msgid ""
"5. Regular expressions - `/b[aA]z.*/` - which will filter the candidates based"
" on whether the regular expression matches the filename."
msgstr ""

#: sample.md:26
msgid ""
"6. Keywords - `:quux` - will filter the candidates based on whether the keywor"
"d is a direct match of the filename (without extension)."
msgstr ""

#: sample.md:27
msgid ""
"7. Numbers - `0` - will select the candidate with that index (wrapping round l"
"ike a ring if necessary)."
msgstr ""

#: sample.md:28
msgid ""
"8. Lists of the above - `[\"/foo/bar\", \"baz\", /0-9.*/]` - will recurse down and"
" work through the internal filter parameters as if they were in the top level."
msgstr ""

#: sample.md:29
msgid ""
"9. Lambdas - `lambda {|s| [s.choose] }` - the ultimate power tool for filters."
" Allows you to create a custom fn which receives a list of candidates as an ar"
"g and which should return a new list of candidates (this may be smaller, large"
"r, re-ordered it's up to you)."
msgstr ""

#: sample.md:31
msgid ""
"By combining commands which add to the candidates and then filtering those can"
"didates it is possible to work with folders full of samples in very powerful w"
"ays. Note that the specific ordering of filter parameters is irrelevant with t"
"he exception of the numbers - in which case the last number is the index. All "
"the candidates will be gathered first before the filters are applied."
msgstr ""

#: sample.md:58
msgid "# Play a built-in sample"
msgstr ""

#: sample.md:59
msgid "# Plays the Amen break"
msgstr ""

#: sample.md:90
msgid "# Play two samples at the same time"
msgstr ""

#: sample.md:91
msgid "# with incredible timing accuracy"
msgstr ""

#: sample.md:93
msgid "# Note, for timing guarantees select the pref:"
msgstr ""

#: sample.md:94
msgid "#   Studio -> Synths and FX -> Enforce timing guarantees"
msgstr ""

#: sample.md:124
msgid "# Create a simple repeating bass drum"
msgstr ""

#: sample.md:162
msgid "# Create a more complex rhythm with multiple live loops:"
msgstr ""

#: sample.md:199
msgid "# Change the playback speed of the sample using rate:"
msgstr ""

#: sample.md:200
msgid "# Play the Amen break at half speed"
msgstr ""

#: sample.md:201
msgid "# for old school hip-hop"
msgstr ""

#: sample.md:230
msgid "# Speed things up"
msgstr ""

#: sample.md:231
msgid "# Play the Amen break at 1.5x speed"
msgstr ""

#: sample.md:232
msgid "# for a jungle/gabba sound"
msgstr ""

#: sample.md:260
msgid "# Go backwards"
msgstr ""

#: sample.md:261
msgid "# Negative rates play the sample backwards"
msgstr ""

#: sample.md:289
msgid "# Fast rewind"
msgstr ""

#: sample.md:290
msgid "# Play backwards at 3x speed for a fast rewind effect"
msgstr ""

#: sample.md:318
msgid "# Start mid sample"
msgstr ""

#: sample.md:319
msgid "# Start playback half way through"
msgstr ""

#: sample.md:347
msgid "# Finish mid sample"
msgstr ""

#: sample.md:348
msgid "# Finish playback half way through"
msgstr ""

#: sample.md:376
msgid "# Play part of a sample"
msgstr ""

#: sample.md:377
msgid "# Play the second eighth of the sample"
msgstr ""

#: sample.md:405
msgid "# Finishing before the start plays backwards"
msgstr ""

#: sample.md:406
msgid "# Play the second eighth of the sample backwards"
msgstr ""

#: sample.md:436
msgid "# Play a section of a sample at quarter speed backwards"
msgstr ""

#: sample.md:437
msgid "# Play the second eighth of the"
msgstr ""

#: sample.md:438
msgid "# amen break backwards at a"
msgstr ""

#: sample.md:439
msgid "# quarter speed"
msgstr ""

#: sample.md:471
msgid "# Control a sample synchronously"
msgstr ""

#: sample.md:476
msgid "# This is triggered 1s from start"
msgstr ""

#: sample.md:509
msgid "# Controlling a sample asynchronously"
msgstr ""

#: sample.md:515
msgid "# This is triggered 0.5s from start"
msgstr ""

#: sample.md:549
msgid "# Play with slices"
msgstr ""

#: sample.md:550
msgid "# => play the first 16th of the sample"
msgstr ""

#: sample.md:553
msgid "# => play the second 16th of the sample 4 times"
msgstr ""

#: sample.md:556
msgid "# => play the final quarter backwards"
msgstr ""

#: sample.md:590
msgid "# Build a simple beat slicer"
msgstr ""

#: sample.md:591
msgid "# Set the BPM to match the amen break sample"
msgstr ""

#: sample.md:593
msgid "# Specify number of slices"
msgstr ""

#: sample.md:594
msgid "# (try changing to 2, 4, 6, 16 or 32)"
msgstr ""

#: sample.md:595
msgid "# Choose a random slice within range"
msgstr ""

#: sample.md:596
msgid "# Play the specific part of the sample"
msgstr ""

#: sample.md:597
msgid "# Sleep for the duration of the slice"
msgstr ""

#: sample.md:626
msgid "# Play with the built-in low pass filter, high pass filter and compressor"
msgstr ""

#: sample.md:627
msgid "# Make the amen break sound punchy."
msgstr ""

#: sample.md:657
msgid "# Use the cutoff filter envelopes"
msgstr ""

#: sample.md:658
msgid "# Sweep the low pass filter up over 8 beats"
msgstr ""

#: sample.md:660
msgid "# Sweep the high pass filter down over 8 beats"
msgstr ""

#: sample.md:694
msgid "# Sample stretching"
msgstr ""

#: sample.md:695
msgid "# => 0.88347"
msgstr ""

#: sample.md:696
msgid "# => 1"
msgstr ""

#: sample.md:698
msgid "# Stretch the sample to make it 1 beat long"
msgstr ""

#: sample.md:699
msgid "# This now loops perfectly."
msgstr ""

#: sample.md:700
msgid "# However, note that stretching/shrinking"
msgstr ""

#: sample.md:701
msgid "# also modifies the pitch."
msgstr ""

#: sample.md:736
msgid "# Sample shrinking"
msgstr ""

#: sample.md:737 sample_duration.md:283
msgid "# => 8"
msgstr ""

#: sample.md:738
msgid "# => 6"
msgstr ""

#: sample.md:740
msgid "# As :loop_garzul is longer than 6 beats"
msgstr ""

#: sample.md:741
msgid "# it is shrunk to fit. This increases the"
msgstr ""

#: sample.md:742
msgid "# pitch."
msgstr ""

#: sample.md:777
msgid "# Sample stretching matches the BPM"
msgstr ""

#: sample.md:778
msgid "# Set the BPM to 30"
msgstr ""

#: sample.md:779
msgid "# => 4.0 (at 30 BPM the sample lasts for 4 beats)"
msgstr ""

#: sample.md:780 sample_duration.md:302 sample_duration.md:307
msgid "# => 6.0"
msgstr ""

#: sample.md:782
msgid "# The sample is stretched to match 6 beats at 30 BPM"
msgstr ""

#: sample.md:814
msgid "# External samples"
msgstr ""

#: sample.md:815
msgid "# Play any Wav, Aif, Ogg, Oga, or FLAC sample on your computer"
msgstr ""

#: sample.md:816
msgid "# by simply passing a string representing the full"
msgstr ""

#: sample.md:817
msgid "# path"
msgstr ""

#: sample.md:868
msgid "# Sample pack filtering"
msgstr ""

#: sample.md:869
msgid "# You can easily work with a directory of samples"
msgstr ""

#: sample.md:870
msgid "# Play the first sample in the directory"
msgstr ""

#: sample.md:871
msgid "# (it is sorted alphabetically)"
msgstr ""

#: sample.md:872
msgid "# Play the second sample in the directory"
msgstr ""

#: sample.md:873
msgid "# Play the 100th sample in the directory, or if there"
msgstr ""

#: sample.md:874
msgid "# are fewer, treat the directory like a ring and keep"
msgstr ""

#: sample.md:875
msgid "# wrapping the index round until a sample is found."
msgstr ""

#: sample.md:876
msgid "# For example, if there are 90 samples, the 10th sample"
msgstr ""

#: sample.md:877
msgid "# is played (index 9)."
msgstr ""

#: sample.md:878
msgid "# Play the first sample in the directory that contains"
msgstr ""

#: sample.md:879 sample.md:882
msgid "# the substring \"120\"."
msgstr ""

#: sample.md:880
msgid "# For example, this may be \"beat1_120_rave.wav\""
msgstr ""

#: sample.md:881
msgid "# Play the second sample in the directory that contains"
msgstr ""

#: sample.md:883
msgid "# For example, this may be \"beat2_120_rave.wav\""
msgstr ""

#: sample.md:884
msgid "# Play the first sample in the directory that matches"
msgstr ""

#: sample.md:885
msgid "# the regular expression /beat[0-9]/."
msgstr ""

#: sample.md:886
msgid "# For example, this may be \"beat0_100_trance.wav\""
msgstr ""

#: sample.md:887
msgid "# You may use the full power of Ruby's regular expression"
msgstr ""

#: sample.md:888
msgid "# system here: http://ruby-doc.org/core-2.1.1/Regexp.html"
msgstr ""

#: sample.md:889
msgid "# Play the first sample in the directory that both matches"
msgstr ""

#: sample.md:890
msgid "# the regular expression /beat[0-9]0/ and contains the"
msgstr ""

#: sample.md:891
msgid "# the substring \"100\"."
msgstr ""

#: sample.md:892
msgid "# For example, this may be \"beat10_100_rave.wav\""
msgstr ""

#: sample.md:925
msgid "# Filtering built-in samples"
msgstr ""

#: sample.md:926
msgid "# If you don't pass a directory source, you can filter over"
msgstr ""

#: sample.md:927
msgid "# the built-in samples."
msgstr ""

#: sample.md:928
msgid "# Play the first built-in sample that contains the substring"
msgstr ""

#: sample.md:929 sample.md:931
msgid "# \"tabla\""
msgstr ""

#: sample.md:930
msgid "# Play the third built-in sample that contains the substring"
msgstr ""

#: sample.md:964
msgid "# Play with whole directories of samples"
msgstr ""

#: sample.md:965
msgid "# You may pass any of the source/filter options to load_samples"
msgstr ""

#: sample.md:966
msgid "# to load all matching samples. This will load all the built-in"
msgstr ""

#: sample.md:967
msgid "# samples containing the substring \"tabla_\""
msgstr ""

#: sample.md:969
msgid "# Treat the matching samples as a ring and tick through them"
msgstr ""

#: sample.md:1003
msgid "# Specify multiple sources"
msgstr ""

#: sample.md:1006
msgid "# Match the first sample that contains the string \"foo\" out of"
msgstr ""

#: sample.md:1007
msgid "# all the samples in dir1 and dir2 combined."
msgstr ""

#: sample.md:1008
msgid "# Note that the sources must be listed before any filters."
msgstr ""

#: sample.md:1046
msgid "# List contents recursively"
msgstr ""

#: sample.md:1047
msgid "# By default the list of all top-level samples within the directory"
msgstr ""

#: sample.md:1048
msgid "# is considered."
msgstr ""

#: sample.md:1049
msgid "# However, if you finish your directory string with ** then if that"
msgstr ""

#: sample.md:1050
msgid "# directory contains other directories then the samples within the"
msgstr ""

#: sample.md:1051
msgid "# subdirectories and their subsubdirectories in turn are considered."
msgstr ""

#: sample.md:1052
msgid "# Play the first top-level sample in the directory"
msgstr ""

#: sample.md:1053
msgid "# Play the first sample found after combining all samples found in"
msgstr ""

#: sample.md:1054
msgid "# the directory and all directories within it recursively."
msgstr ""

#: sample.md:1055
msgid "# Note that if there are many sub directories this may take some time"
msgstr ""

#: sample.md:1056
msgid "# to execute. However, the result is cached so subsequent calls will"
msgstr ""

#: sample.md:1057
msgid "# be fast."
msgstr ""

#: sample.md:1091
msgid "# Bespoke filters"
msgstr ""

#: sample.md:1092
msgid "# If the built-in String, Regexp and index filters are not sufficient"
msgstr ""

#: sample.md:1093
msgid "# you may write your own. They need to be a function which takes a list"
msgstr ""

#: sample.md:1094
msgid "# of paths to samples and return a list of samples. This one returns a"
msgstr ""

#: sample.md:1095
msgid "# list of a single randomly selected sample."
msgstr ""

#: sample.md:1097
msgid "# Play 8 randomly selected samples from the built-in sample set that also"
msgstr ""

#: sample.md:1098
msgid "# contain the substring \"drum_\""
msgstr ""

#: sample.md:1140
msgid "# Basic Onset Detection"
msgstr ""

#: sample.md:1142
msgid "# If you know the right start: and finish: values, you can extract a"
msgstr ""

#: sample.md:1143
msgid "# single drum hit from a longer sample. However, finding these values"
msgstr ""

#: sample.md:1144
msgid "# can be very time consuming."
msgstr ""

#: sample.md:1146
msgid "# Instead of specifying the start: and finish: values manually you can"
msgstr ""

#: sample.md:1147
msgid "# use the onset: option to find them for you using an integer index."
msgstr ""

#: sample.md:1148
msgid "# onset: 0 will set the start: and finish: values so that the first"
msgstr ""

#: sample.md:1149
msgid "# percussive sound (something that shifts from quiet to loud quickly)"
msgstr ""

#: sample.md:1150
msgid "# is picked out."
msgstr ""

#: sample.md:1153
msgid "# We can easily find the second percussive sound in the sample with"
msgstr ""

#: sample.md:1154
msgid "# onset: 1"
msgstr ""

#: sample.md:1193
msgid "# Ticking through onsets"
msgstr ""

#: sample.md:1195
msgid "# The onsets are actually a ring so the index will wrap around. This"
msgstr ""

#: sample.md:1196
msgid "# means that if there are only 8 onsets in a sample, specifying an"
msgstr ""

#: sample.md:1197
msgid "# onset of 100 will still return one of the 8 onsets. This means we"
msgstr ""

#: sample.md:1198
msgid "# can use tick to work through each onset in sequence. This allows us"
msgstr ""

#: sample.md:1199
msgid "# to redefine the rhythm and tempo of a sample"
msgstr ""

#: sample.md:1203
msgid "# We can choose our own BPM here - it doesn't need to match the sample"
msgstr ""

#: sample.md:1204
msgid "# tick through each onset in sequence"
msgstr ""

#: sample.md:1205
msgid "# randomly choose a delay between onset triggers"
msgstr ""

#: sample.md:1238
msgid "# Random Onset Triggering"
msgstr ""

#: sample.md:1239
msgid "# We can easily pick a random onset using the pick fn"
msgstr ""

#: sample.md:1242
msgid "# Each time round the live loop we now trigger a random onset"
msgstr ""

#: sample.md:1243
msgid "# creating an infinite stream of randomly selected drums"
msgstr ""

#: sample.md:1279
msgid "# Repeatable Random Onsets"
msgstr ""

#: sample.md:1280
msgid "# Instead of an infinite stream of choices, we can combine iteration"
msgstr ""

#: sample.md:1281
msgid "# and use_random_seed to create repeatable riffs:"
msgstr ""

#: sample.md:1283
msgid "# every 8 times, reset the random seed, this resets the riff"
msgstr ""

#: sample.md:1326
msgid "#  Random Onset Duration"
msgstr ""

#: sample.md:1327
msgid "# Each onset has a variable length (determined by the sample contents)."
msgstr ""

#: sample.md:1328
msgid "# Therefore, if you wish to ensure each onset has a specific length it"
msgstr ""

#: sample.md:1329
msgid "# is necessary to use the sample's amplitude envelope."
msgstr ""

#: sample.md:1330
msgid "# As the sample's envelope automatically changes the sustain: value to"
msgstr ""

#: sample.md:1331
msgid "# match the duration - you also need to override this with a value of 0."
msgstr ""

#: sample.md:1333
msgid "# Each drum onset will now be no longer than 0.1. Note that the envelope"
msgstr ""

#: sample.md:1334
msgid "# for a sample only determines the maximum duration of a sample trigger."
msgstr ""

#: sample.md:1335
msgid "# If the actual audible duration of the onset is smaller than 0.1 then"
msgstr ""

#: sample.md:1336
msgid "# it will *not* be extended."
msgstr ""

#: sample.md:1381
msgid "# Onset lambdas"
msgstr ""

#: sample.md:1383
msgid "# The onset index can be a lambda as well as an integer. If a lambda is"
msgstr ""

#: sample.md:1384
msgid "# given, it will be passed a ring of all of the onsets as an argument."
msgstr ""

#: sample.md:1385
msgid "# This will be a ring of maps:"
msgstr ""

#: sample.md:1387
msgid "# define a lambda which accepts a single argument, prints it and"
msgstr ""

#: sample.md:1388
msgid "# returns the first value. This particular example is essentially"
msgstr ""

#: sample.md:1389
msgid "# the same as using onset: 0 with the side effect of also printing out"
msgstr ""

#: sample.md:1390
msgid "# the full ring of onsets:"
msgstr ""

#: sample.md:1392
msgid "# (ring {:start=>0.0, :finish=>0.0076}, {:start=>0.0076, :finish 0.015}...)"
msgstr ""

#: sample.md:1394
msgid "# We are therefore free to define this lambda to do anything we want."
msgstr ""

#: sample.md:1395
msgid "# This gives us very powerful control over the choice of onset. It is"
msgstr ""

#: sample.md:1396
msgid "# unlikely you will use this frequently, but it is a powerful tool"
msgstr ""

#: sample.md:1397
msgid "# that's there when you need it."
msgstr ""

#: sample.md:1428
msgid "# Plays the 2nd onset (the first onset would have index 0)"
msgstr ""

#: sample.md:1430 sample.md:1467
msgid "# Will override opts with: {start: 0.0151, finish: 0.0304}"
msgstr ""

#: sample.md:1431 sample.md:1468 sample.md:1507 sample.md:1563 sample.md:1571
#: sample.md:1580
msgid "# (these values are specific to the :loop_tabla sample and"
msgstr ""

#: sample.md:1432 sample.md:1469 sample.md:1508 sample.md:1564 sample.md:1572
#: sample.md:1581
msgid "# will vary for different samples)"
msgstr ""

#: sample.md:1464
msgid "# Plays the 2nd onset. This behaves the same as not specifying"
msgstr ""

#: sample.md:1465
msgid "# a slice as we select the first of one slices."
msgstr ""

#: sample.md:1502
msgid "# This plays the first half of the 2nd onset."
msgstr ""

#: sample.md:1503
msgid "# This is because  we split that onset into two slices and"
msgstr ""

#: sample.md:1504 sample.md:1560
msgid "# play just the first slice (with index 0)."
msgstr ""

#: sample.md:1506
msgid "# Will override opts with: {start: 0.0151, finish: 0.0227}"
msgstr ""

#: sample.md:1558
msgid "# This plays the first quarter of the 2nd onset."
msgstr ""

#: sample.md:1559
msgid "# This is because we split that onset into four slices and"
msgstr ""

#: sample.md:1562
msgid "# Will override opts with: {start: 0.0151, finish: 0.0189}"
msgstr ""

#: sample.md:1566
msgid "# Will play the first 1/8th of the 2nd onset."
msgstr ""

#: sample.md:1567 sample.md:1575
msgid "# This is because we split that specific onset into 4 slices"
msgstr ""

#: sample.md:1568
msgid "# and then only play the first half of the first slice."
msgstr ""

#: sample.md:1570
msgid "# Will override opts with: {start: 0.0151, finish: 0.017}"
msgstr ""

#: sample.md:1574
msgid "# Will play the first 1/8th of the 2nd onset backwards.."
msgstr ""

#: sample.md:1576
msgid "# and then only play from the first half of the first slice"
msgstr ""

#: sample.md:1577
msgid "# back to the beginning."
msgstr ""

#: sample.md:1579
msgid "# Will override opts with: {start: 0.017, finish: 0.0151}"
msgstr ""

#: sample_buffer.md:9
msgid ""
"Alias for the `load_sample` method. Loads sample if necessary and returns buff"
"er information."
msgstr ""

#: sample_buffer.md:23 sample_info.md:23
msgid "see load_sample"
msgstr ""

#: sample_duration.md:9
msgid ""
"Given the name of a loaded sample, or a path to a `.wav`, `.wave`, `.aif`, `.a"
"iff`, `.ogg`, `.oga` or `.flac` file returns the length of time in beats that "
"the sample would play for. `sample_duration` understands and accounts for all "
"the opts you can pass to `sample` which have an effect on the playback duratio"
"n such as `rate:`. The time returned is scaled to the current BPM."
msgstr ""

#: sample_duration.md:11
msgid ""
"*Note:* avoid using `sample_duration` to set the sleep time in `live_loop`s, p"
"refer stretching the sample with the `beat_stretch:` opt or changing the BPM i"
"nstead. See the examples below for details."
msgstr ""

#: sample_duration.md:26
msgid "puts sample_duration(:loop_garzul)"
msgstr ""

#: sample_duration.md:37
msgid "# Simple use"
msgstr ""

#: sample_duration.md:38
msgid "# returns 8.0 because this sample is 8 seconds long"
msgstr ""

#: sample_duration.md:71
msgid "# The result is scaled to the current BPM"
msgstr ""

#: sample_duration.md:73 sample_duration.md:250
msgid "# => 16.0"
msgstr ""

#: sample_duration.md:75
msgid "# => 12.0"
msgstr ""

#: sample_duration.md:77
msgid "# => 2.8"
msgstr ""

#: sample_duration.md:125
msgid "# Avoid using sample_duration to set the sleep time in live_loops"
msgstr ""

#: sample_duration.md:127
msgid "# It is possible to use sample_duration to drive the frequency of a live loop."
msgstr ""

#: sample_duration.md:128
msgid ""
"# However, if you're using a rhythmical sample such as a drum beat and it isn'"
"t"
msgstr ""

#: sample_duration.md:129
msgid "# in the same BPM as the current BPM, then the FX such as this slicer will be"
msgstr ""

#: sample_duration.md:130
msgid "# badly out of sync. This is because the slicer slices at the current BPM and"
msgstr ""

#: sample_duration.md:131
msgid "# this live_loop is looping at a different BPM (that of the sample)"
msgstr ""

#: sample_duration.md:134
msgid "# Instead prefer to set the BPM of the live_loop to match the sample. It has"
msgstr ""

#: sample_duration.md:135
msgid "# two benefits. Now our sleep is a nice and simple 1 (as it's one beat)."
msgstr ""

#: sample_duration.md:136
msgid "# Also, our slicer now works with the beat and sounds much better."
msgstr ""

#: sample_duration.md:142
msgid ""
"# Alternatively we can beat_stretch the sample to match the current BPM. This "
"has the"
msgstr ""

#: sample_duration.md:143
msgid ""
"# side effect of changing the rate of the sample (and hence the pitch). Howeve"
"r, the"
msgstr ""

#: sample_duration.md:144
msgid "# FX works nicely in time and the sleep time is also a simple 1."
msgstr ""

#: sample_duration.md:244
msgid "# The standard sample opts are also honoured"
msgstr ""

#: sample_duration.md:246
msgid "# Playing a sample at standard speed will return standard length"
msgstr ""

#: sample_duration.md:247 sample_duration.md:259 sample_duration.md:260
#: sample_duration.md:261 sample_duration.md:264 sample_duration.md:265
#: sample_duration.md:266 sample_duration.md:269 sample_duration.md:270
#: sample_duration.md:271
msgid "# => 8.0"
msgstr ""

#: sample_duration.md:249
msgid "# Playing a sample at half speed will double duration"
msgstr ""

#: sample_duration.md:252
msgid "# Playing a sample at double speed will halve duration"
msgstr ""

#: sample_duration.md:253 sample_duration.md:256 sample_duration.md:293
#: sample_duration.md:311
msgid "# => 4.0"
msgstr ""

#: sample_duration.md:255
msgid "# Playing a sample backwards at double speed will halve duration"
msgstr ""

#: sample_duration.md:258
msgid "# Without an explicit sustain: opt attack: just affects amplitude not duration"
msgstr ""

#: sample_duration.md:263
msgid ""
"# Without an explicit sustain: opt release: just affects amplitude not duratio"
"n"
msgstr ""

#: sample_duration.md:268
msgid "# Without an explicit sustain: opt decay: just affects amplitude not duration"
msgstr ""

#: sample_duration.md:273
msgid ""
"# With an explicit sustain: opt, if the attack + decay + sustain + release env"
"elope"
msgstr ""

#: sample_duration.md:274
msgid ""
"# duration is less than the sample duration time, the envelope will shorten th"
"e"
msgstr ""

#: sample_duration.md:275
msgid "# sample time."
msgstr ""

#: sample_duration.md:276
msgid "# => 0.5"
msgstr ""

#: sample_duration.md:277
msgid "# => 0.1"
msgstr ""

#: sample_duration.md:278 sample_duration.md:314
msgid "# => 1.0"
msgstr ""

#: sample_duration.md:279
msgid "# => 3.5"
msgstr ""

#: sample_duration.md:281
msgid "# If the envelope duration is longer than the sample it will not affect the"
msgstr ""

#: sample_duration.md:282
msgid "# sample duration"
msgstr ""

#: sample_duration.md:286
msgid ""
"# All other opts are taken into account before the comparison with the envelop"
"e opts."
msgstr ""

#: sample_duration.md:287
msgid "# => 0.8"
msgstr ""

#: sample_duration.md:288
msgid "# => 0.8 (The duration of the sample is less than the envelope length so wins)"
msgstr ""

#: sample_duration.md:291
msgid ""
"# The rpitch: opt will modify the rate to shift the pitch of the sample up and"
" down"
msgstr ""

#: sample_duration.md:292
msgid "# and therefore affects duration."
msgstr ""

#: sample_duration.md:294
msgid "# => 16"
msgstr ""

#: sample_duration.md:296
msgid "# The rpitch: and rate: opts combine together."
msgstr ""

#: sample_duration.md:297 sample_duration.md:312 sample_duration.md:313
msgid "# => 2.0"
msgstr ""

#: sample_duration.md:299
msgid ""
"# The beat_stretch: opt stretches the sample so that its duration matches the "
"value."
msgstr ""

#: sample_duration.md:300
msgid "# It also combines with rate:"
msgstr ""

#: sample_duration.md:301 sample_duration.md:306
msgid "# => 3.0"
msgstr ""

#: sample_duration.md:304
msgid ""
"# The pitch_stretch: opt acts identically to beat_stretch when just considerin"
"g sample"
msgstr ""

#: sample_duration.md:305
msgid "# duration."
msgstr ""

#: sample_duration.md:309
msgid ""
"# The start: and finish: opts can also shorten the sample duration and also co"
"mbine"
msgstr ""

#: sample_duration.md:310
msgid "# with other opts such as rate:"
msgstr ""

#: sample_duration.md:345
msgid "# Triggering samples one after another"
msgstr ""

#: sample_duration.md:347
msgid "# start the :loop_amen sample"
msgstr ""

#: sample_duration.md:348
msgid "# wait for the duration of :loop_amen before"
msgstr ""

#: sample_duration.md:349
msgid "# starting it again"
msgstr ""

#: sample_free.md:9
msgid ""
"Frees the memory and resources consumed by loading the sample on the server. S"
"ubsequent calls to `sample` and friends will re-load the sample on the server."
msgstr ""

#: sample_free.md:11
msgid ""
"You may also specify the same set of source and filter pre-args available to `"
"sample` itself. `sample_free` will then free all matching samples. See `sample"
"`'s docs for more information."
msgstr ""

#: sample_free.md:29
msgid "sample_free :loop_amen"
msgstr ""

#: sample_free.md:41
msgid "# The Amen break is now loaded into memory and played"
msgstr ""

#: sample_free.md:43
msgid "# The Amen break is not loaded but played from memory"
msgstr ""

#: sample_free.md:45
msgid "# The Amen break is freed from memory"
msgstr ""

#: sample_free.md:46
msgid "# the Amen break is re-loaded and played"
msgstr ""

#: sample_free.md:77
msgid "# This returns the buffer id of the sample i.e. 1"
msgstr ""

#: sample_free.md:78
msgid "# The buffer id remains constant whilst the sample"
msgstr ""

#: sample_free.md:79
msgid "# is loaded in memory"
msgstr ""

#: sample_free.md:81
msgid "# The Amen break is re-loaded and gets a *new* id."
msgstr ""

#: sample_free.md:117 sample_free_all.md:42
msgid "# re-loads and plays amen"
msgstr ""

#: sample_free.md:118
msgid "# re-loads and plays lunar land"
msgstr ""

#: sample_free.md:152
msgid "# frees any loaded samples in \"/path/to/sample/dir\""
msgstr ""

#: sample_free.md:153
msgid "# frees sample with index 1 in \"/path/to/sample/dir\""
msgstr ""

#: sample_free.md:154
msgid "# frees sample with name \"foo\" in \"/path/to/sample/dir\""
msgstr ""

#: sample_free.md:155
msgid "# frees sample which matches regex /[Bb]ar/ in \"/path/to/sample/dir\""
msgstr ""

#: sample_free_all.md:9
msgid ""
"Unloads all samples therefore freeing the memory and resources consumed. Subse"
"quent calls to `sample` and friends will re-load the sample on the server."
msgstr ""

#: sample_free_all.md:23 sample_free_all.md:27
msgid "sample :loop_amen       "
msgstr ""

#: sample_free_all.md:24
msgid "sample :ambi_lunar_land "
msgstr ""

#: sample_free_all.md:26
msgid "sample_free_all"
msgstr ""

#: sample_free_all.md:38
msgid "# load and play :loop_amen"
msgstr ""

#: sample_free_all.md:39
msgid "# load and play :ambi_lunar_land"
msgstr ""

#: sample_groups.md:9
msgid "Return a list of all the sample groups available"
msgstr ""

#: sample_info.md:9
msgid ""
"Alias for the `load_sample` method. Loads sample if necessary and returns samp"
"le information."
msgstr ""

#: sample_loaded?.md:9
msgid ""
"Given a path to a `.wav`, `.wave`, `.aif`, `.aiff`, `.ogg`, `.oga` or `.flac` "
"file, returns `true` if the sample has already been loaded."
msgstr ""

#: sample_loaded?.md:24
msgid "puts sample_loaded? :elec_blip"
msgstr ""

#: sample_loaded?.md:25
msgid "puts sample_loaded? :misc_burp"
msgstr ""

#: sample_loaded?.md:37
msgid "# prints true because it has been pre-loaded"
msgstr ""

#: sample_loaded?.md:38
msgid "# prints false because it has not been loaded"
msgstr ""

#: sample_names.md:9
msgid "Return a ring of sample names for the specified group"
msgstr ""

#: sample_paths.md:9
msgid ""
"Accepts the same pre-args and opts as `sample` and returns a ring of matched s"
"ample paths."
msgstr ""

#: sample_paths.md:23
msgid "sample_paths \"/path/to/samples/\""
msgstr ""

#: sample_paths.md:34
msgid "#=> ring of all top-level samples in /path/to/samples"
msgstr ""

#: sample_paths.md:61
msgid "#=> ring of all nested samples in /path/to/samples"
msgstr ""

#: sample_paths.md:88
msgid "#=> ring of all samples in /path/to/samples"
msgstr ""

#: scale.md:9
msgid ""
"Creates a ring of MIDI note numbers when given a tonic note and a scale name. "
"Also takes an optional `num_octaves:` parameter (octave `1` is the default). I"
"f only passed the scale name, the tonic defaults to 0. See examples."
msgstr ""

#: scale.md:23
msgid "puts (scale :C, :major)"
msgstr ""

#: scale.md:34
msgid ""
"# returns the following ring of MIDI note numbers: (ring 60, 62, 64, 65, 67, 6"
"9, 71, 72)"
msgstr ""

#: scale.md:61
msgid "# anywhere you can use a list or ring of notes, you can also use scale"
msgstr ""

#: scale.md:89
msgid "# you can use the :num_octaves parameter to get more notes"
msgstr ""

#: scale.md:120
msgid "# Scales can start with any note:"
msgstr ""

#: scale.md:121
msgid "#=> (ring 50, 52, 53, 55, 57, 58, 60, 62)"
msgstr ""

#: scale.md:122
msgid "#=> (ring 50.1, 52.1, 53.1, 55.1, 57.1, 58.1, 60.1, 62.1)"
msgstr ""

#: scale.md:123
msgid "#=> (ring 0, 2, 3, 5, 7, 8, 10, 12)"
msgstr ""

#: scale.md:153
msgid "# scales are also rings"
msgstr ""

#: scale.md:187
msgid "# scales starting with 0 are useful in combination with sample's rpitch:"
msgstr ""

#: scale.md:369
msgid "# Sonic Pi supports a large range of scales:"
msgstr ""

#: scale_names.md:9
msgid "Returns a ring containing all scale names known to Sonic Pi"
msgstr ""

#: scale_names.md:23
msgid "puts scale_names"
msgstr ""

#: scale_names.md:34
msgid "#=>  prints a list of all the scales"
msgstr ""

#: scsynth_info.md:9
msgid ""
"Create a map of information about the running audio synthesiser SuperCollider."
" "
msgstr ""

#: scsynth_info.md:23
msgid "puts scsynth_info "
msgstr ""

#: scsynth_info.md:44
msgid "#=>  (map sample_rate: 44100.0,"
msgstr ""

#: scsynth_info.md:45
msgid "#         sample_dur: 2.2675736545352265e-05,"
msgstr ""

#: scsynth_info.md:46
msgid "#         radians_per_sample: 0.00014247585204429924,"
msgstr ""

#: scsynth_info.md:47
msgid "#         control_rate: 689.0625,"
msgstr ""

#: scsynth_info.md:48
msgid "#         control_dur: 0.001451247138902545,"
msgstr ""

#: scsynth_info.md:49
msgid "#         subsample_offset: 0.0,"
msgstr ""

#: scsynth_info.md:50
msgid "#         num_output_busses: 16.0,"
msgstr ""

#: scsynth_info.md:51
msgid "#         num_input_busses: 16.0,"
msgstr ""

#: scsynth_info.md:52
msgid "#         num_audio_busses: 1024.0,"
msgstr ""

#: scsynth_info.md:53
msgid "#         num_control_busses: 4096.0,"
msgstr ""

#: scsynth_info.md:54
msgid "#         num_buffers: 4096.0)"
msgstr ""

#: set.md:9
msgid ""
"Store information in the Time State for the current time for either the curren"
"t or any other thread. If called multiple times without an intervening call to"
" `sleep`, `sync`, `set` or `cue`, the last value set will prevail. The value w"
"ill remain in the Time State until overwritten by another call to `set`, or un"
"til Sonic Pi quits."
msgstr ""

#: set.md:11
msgid ""
"May be used within a `time_warp` to set past/future events. Does not affect ti"
"me."
msgstr ""

#: set.md:25
msgid "set :foo, 1"
msgstr ""

#: set.md:36
msgid "#=> Stores the value 1 with key :foo"
msgstr ""

#: set.md:64 set.md:98
msgid "# Set :foo to 3"
msgstr ""

#: set_audio_latency!.md:9
msgid ""
"On some systems with certain configurations (such as wireless speakers, and ev"
"en a typical Windows environment with the default audio drivers) the audio lat"
"ency can be large. If all the user is doing is generating audio via calls such"
" as `play`, `synth` and `sample`, then this latency essentially adds to the sc"
"hedule ahead time and for the most part can be ignored. However, if the user i"
"s combining audio with external MIDI/OSC triggered events, this latency can re"
"sult in a noticeable offset. This function allows you to address this offset b"
"y moving the audio events forwards and backwards in time."
msgstr ""

#: set_audio_latency!.md:11
msgid ""
"So, for example, if your audio system has an audio latency of 150ms, you can c"
"ompensate for this by setting Sonic Pi's latency to be a negative value: `set_"
"audio_latency! -150`."
msgstr ""

#: set_audio_latency!.md:13
msgid "Introduced in v3.1"
msgstr ""

#: set_audio_latency!.md:25
msgid "set_audio_latency! 100"
msgstr ""

#: set_audio_latency!.md:26
msgid "                                                 "
msgstr ""

#: set_audio_latency!.md:37
msgid "# Audio events will now be scheduled 100ms"
msgstr ""

#: set_audio_latency!.md:38
msgid "# after the schedule ahead time"
msgstr ""

#: set_audio_latency!.md:66
msgid "# Audio events will now be scheduled 200ms"
msgstr ""

#: set_audio_latency!.md:67
msgid "# before the schedule ahead time"
msgstr ""

#: set_cent_tuning!.md:9
msgid "Globally tune Sonic Pi to play with another external instrument."
msgstr ""

#: set_cent_tuning!.md:11 use_cent_tuning.md:9
msgid ""
"Uniformly tunes your music by shifting all notes played by the specified numbe"
"r of cents. To shift up by a cent use a cent tuning of 1. To shift down use ne"
"gative numbers. One semitone consists of 100 cents."
msgstr ""

#: set_cent_tuning!.md:13
msgid ""
"See `use_cent_tuning` for setting the cent tuning value locally for a specific"
" thread or `live_loop`. This is a global value and will shift the tuning for *"
"all* notes. It will also persist for the entire session."
msgstr ""

#: set_cent_tuning!.md:15
msgid ""
"Important note: the cent tuning set by `set_cent_tuning!` is independent of an"
"y thread-local cent tuning values set by `use_cent_tuning` or `with_cent_tunin"
"g`. "
msgstr ""

#: set_cent_tuning!.md:30
msgid "set_cent_tuning! 1"
msgstr ""

#: set_cent_tuning!.md:42 use_cent_tuning.md:38 use_octave.md:36
#: use_octave.md:73 use_transpose.md:36 use_transpose.md:73 with_octave.md:40
#: with_octave.md:46
msgid "# Plays note 50"
msgstr ""

#: set_cent_tuning!.md:44 use_cent_tuning.md:40 with_cent_tuning.md:43
#: with_cent_tuning.md:50
msgid "# Plays note 50.01"
msgstr ""

#: set_control_delta!.md:9
msgid ""
"Specify how many seconds between successive modifications (i.e. trigger then c"
"ontrols) of a specific node on a specific thread. Set larger if you are missin"
"g control messages sent extremely close together in time."
msgstr ""

#: set_control_delta!.md:23
msgid "set_control_delta! 0.1                "
msgstr ""

#: set_control_delta!.md:25
msgid "s = play 70, release: 8, note_slide: 8"
msgstr ""

#: set_control_delta!.md:26
msgid "control s, note: 82                   "
msgstr ""

#: set_control_delta!.md:27 set_control_delta!.md:28 set_control_delta!.md:29
#: set_control_delta!.md:30 set_control_delta!.md:31
msgid "                                      "
msgstr ""

#: set_control_delta!.md:42
msgid "# Set control delta to 0.1"
msgstr ""

#: set_control_delta!.md:44
msgid "# Play a note and set the slide time"
msgstr ""

#: set_control_delta!.md:45
msgid "# immediately start sliding note."
msgstr ""

#: set_control_delta!.md:46
msgid "# This control message might not be"
msgstr ""

#: set_control_delta!.md:47
msgid "# correctly handled as it is sent at the"
msgstr ""

#: set_control_delta!.md:48
msgid "# same virtual time as the trigger."
msgstr ""

#: set_control_delta!.md:49
msgid "# If you don't hear a slide, try increasing the"
msgstr ""

#: set_control_delta!.md:50
msgid "# control delta until you do."
msgstr ""

#: set_mixer_control!.md:9
msgid ""
"The main mixer is the final mixer that all sound passes through. This fn gives"
" you control over the main mixer allowing you to manipulate all the sound play"
"ing through Sonic Pi at once. For example, you can sweep a lpf or hpf over the"
" entire sound. You can reset the controls back to their defaults with `reset_m"
"ixer!`."
msgstr ""

#: set_mixer_control!.md:23
msgid "set_mixer_control! lpf: 30, lpf_slide: 16"
msgstr ""

#: set_mixer_control!.md:34
msgid "# slide the global lpf to 30 over 16 beats."
msgstr ""

#: set_recording_bit_depth!.md:9
msgid ""
"When you hit the record button, Sonic Pi saves all the audio you can hear into"
" a wav file. By default, this file uses a resolution of 16 bits which is the s"
"ame as CD audio and good enough for most use cases. However, when working with"
" professional equipment, it is common to want to work with even higher quality"
" files such as 24 bits and even 32 bits. This function allows you to switch th"
"e default from 16 to one of 8, 16, 24 or 32."
msgstr ""

#: set_recording_bit_depth!.md:23
msgid "set_recording_bit_depth! 24                "
msgstr ""

#: set_recording_bit_depth!.md:34
msgid "# Set recording bit depth to 24"
msgstr ""

#: set_sched_ahead_time!.md:9 use_sched_ahead_time.md:9
msgid ""
"Specify how many seconds ahead of time the synths should be triggered. This re"
"presents the amount of time between pressing 'Run' and hearing audio. A larger"
" time gives the system more room to work with and can reduce performance issue"
"s in playing fast sections on slower platforms. However, a larger time also in"
"creases latency between modifying code and hearing the result whilst live codi"
"ng."
msgstr ""

#: set_sched_ahead_time!.md:23
msgid "set_sched_ahead_time! 1"
msgstr ""

#: set_sched_ahead_time!.md:34 use_real_time.md:39 use_sched_ahead_time.md:38
#: with_real_time.md:40
msgid "# Code will now run approximately 1 second ahead of audio."
msgstr ""

#: set_volume!.md:9
msgid ""
"Set the main system volume to `vol`. Accepts a value between `0` and `5` inclu"
"sive. Vols greater or smaller than the allowed values are trimmed to keep them"
" within range. Default is `1`."
msgstr ""

#: set_volume!.md:23
msgid "set_volume! 2"
msgstr ""

#: set_volume!.md:34
msgid "# Set the main system volume to 2"
msgstr ""

#: set_volume!.md:61
msgid "# Out of range, so sets main system volume to 0"
msgstr ""

#: set_volume!.md:88
msgid "# Out of range, so sets main system volume to 5"
msgstr ""

#: shuffle.md:9
msgid ""
"Returns a new list with the same elements as the original but with their order"
" shuffled. Also works for strings"
msgstr ""

#: shuffle.md:23
msgid "shuffle [1, 2, 3, 4]"
msgstr ""

#: shuffle.md:34
msgid "#=> Would return something like: [3, 4, 2, 1]"
msgstr ""

#: shuffle.md:61
msgid "#=> Would return something like: \"roobfa\""
msgstr ""

#: sleep.md:9
msgid ""
"Wait for a number of beats before triggering the next command. Beats are conve"
"rted to seconds by scaling to the current bpm setting."
msgstr ""

#: sleep.md:25 sleep.md:31
msgid "  play 50 "
msgstr ""

#: sleep.md:26 sleep.md:33
msgid "  play 55"
msgstr ""

#: sleep.md:29
msgid "  sleep 1 "
msgstr ""

#: sleep.md:32 sleep.md:34 stop.md:24 time_warp.md:41
msgid "  sleep 0.5"
msgstr ""

#: sleep.md:45
msgid "# Without calls to sleep, all sounds would happen at once:"
msgstr ""

#: sleep.md:47
msgid "# This is actually a chord with all notes played simultaneously"
msgstr ""

#: sleep.md:51
msgid "# Create a gap, to allow a moment's pause for reflection..."
msgstr ""

#: sleep.md:53
msgid "# Let's try the chord again, but this time with sleeps:"
msgstr ""

#: sleep.md:54
msgid "# With the sleeps, we turn a chord into an arpeggio"
msgstr ""

#: sleep.md:99
msgid ""
"# The amount of time sleep pauses for is scaled to match the current bpm. The "
"default bpm is 60. Let's double it:"
msgstr ""

#: sleep.md:103
msgid "# This actually sleeps for 0.5 seconds as we're now at double speed"
msgstr ""

#: sleep.md:108
msgid "# Let's go down to half speed:"
msgstr ""

#: sleep.md:112
msgid "# This now sleeps for 2 seconds as we're now at half speed."
msgstr ""

#: spark.md:9
msgid ""
"Given a list of numeric values, this method turns them into a string of bar he"
"ights and prints them out. Useful for quickly graphing the shape of an array."
msgstr ""

#: spark.md:23
msgid "spark (range 1, 5)   "
msgstr ""

#: spark.md:34 spark_graph.md:34
msgid "#=> ▁▃▅█"
msgstr ""

#: spark.md:61 spark_graph.md:61
msgid "#=> ▃█▅▁"
msgstr ""

#: spark_graph.md:9
msgid ""
"Given a list of numeric values, this method turns them into a string of bar he"
"ights. Useful for quickly graphing the shape of an array. Remember to use puts"
" so you can see the output. See `spark` for a simple way of printing a spark g"
"raph."
msgstr ""

#: spark_graph.md:23
msgid "puts (spark_graph (range 1, 5))   "
msgstr ""

#: spread.md:9
msgid ""
"Creates a new ring of boolean values which space a given number of accents as "
"evenly as possible throughout a bar. This is an implementation of the process "
"described in 'The Euclidean Algorithm Generates Traditional Musical Rhythms' ("
"Toussaint 2005)."
msgstr ""

#: spread.md:11
msgid "Introduced in v2.4"
msgstr ""

#: spread.md:23
msgid "(spread 3, 8)   "
msgstr ""

#: spread.md:34
msgid ""
"#=> (ring true, false, false, true, false, false, true, false) a spacing of 33"
"2"
msgstr ""

#: spread.md:61
msgid ""
"#=> (ring true, false, false, true, false, true, false, false) a spacing of 32"
"3"
msgstr ""

#: spread.md:93
msgid "# Easily create interesting polyrhythmic beats"
msgstr ""

#: spread.md:95
msgid "# Spread 3 bongs over 8"
msgstr ""

#: spread.md:96
msgid "# Spread 7 snaps over 11"
msgstr ""

#: spread.md:97
msgid "# Spread 1 bd over 4"
msgstr ""

#: spread.md:175
msgid "# Spread descriptions from"
msgstr ""

#: spread.md:176
msgid ""
"# 'The Euclidean Algorithm Generates Traditional Musical Rhythms' (Toussaint 2"
"005)."
msgstr ""

#: spread.md:177
msgid "# A thirteenth century Persian rhythm called Khafif-e-ramal."
msgstr ""

#: spread.md:179
msgid "# The archetypal pattern of the Cumbria from Columbia, as well"
msgstr ""

#: spread.md:180
msgid "# as a Calypso rhythm from Trinidad"
msgstr ""

#: spread.md:182
msgid "# When started on the second onset, is another thirteenth"
msgstr ""

#: spread.md:183
msgid "# century Persian rhythm by the name of Khafif-e-ramal, as well"
msgstr ""

#: spread.md:184
msgid "# as a Romanian folk-dance rhythm."
msgstr ""

#: spread.md:186
msgid "# A ruchenitza rhythm used in a Bulgarian folk-dance."
msgstr ""

#: spread.md:188
msgid "# The Cuban tresillo pattern"
msgstr ""

#: spread.md:190
msgid "# Another Ruchenitza Bulgarian folk-dance rhythm"
msgstr ""

#: spread.md:192
msgid "# The Aksak rhythm of Turkey."
msgstr ""

#: spread.md:194
msgid "# The metric pattern used by Frank Zappa in his piece Outside Now"
msgstr ""

#: spread.md:196
msgid "# Yields the York-Samai pattern, a popular Arab rhythm, when"
msgstr ""

#: spread.md:197
msgid "# started on the second onset."
msgstr ""

#: spread.md:199
msgid "# The Nawakhat pattern, another popular Arab rhythm."
msgstr ""

#: spread.md:201
msgid "# The Cuban cinquillo pattern."
msgstr ""

#: spread.md:203
msgid "# A popular Arab rhythm called Agsag-Samai."
msgstr ""

#: spread.md:205
msgid "# The metric pattern used by Moussorgsky in Pictures at an"
msgstr ""

#: spread.md:206
msgid "# Exhibition"
msgstr ""

#: spread.md:208
msgid "# The Venda clapping pattern of a South African children's"
msgstr ""

#: spread.md:209
msgid "# song."
msgstr ""

#: spread.md:211
msgid "# The Bossa-Nova rhythm necklace of Brazil."
msgstr ""

#: spread.md:213
msgid "# A typical rhythm played on the Bendir (frame drum)"
msgstr ""

#: spread.md:215
msgid "# A common West African bell pattern."
msgstr ""

#: spread.md:217
msgid "# A Samba rhythm necklace from Brazil."
msgstr ""

#: spread.md:219
msgid "# A rhythm necklace used in the Central African Republic."
msgstr ""

#: spread.md:221
msgid "# A rhythm necklace of the Aka Pygmies of Central Africa."
msgstr ""

#: spread.md:223
msgid "# Another rhythm necklace of the Aka Pygmies of the upper"
msgstr ""

#: spread.md:224
msgid "# Sangha."
msgstr ""

#: status.md:9
msgid ""
"This returns a Hash of information about the synthesis environment. Mostly use"
"d for debugging purposes."
msgstr ""

#: status.md:23
msgid "puts status"
msgstr ""

#: status.md:46
msgid "# Returns something similar to:"
msgstr ""

#: status.md:47
msgid "# {"
msgstr ""

#: status.md:48
msgid "#   :ugens=>10,"
msgstr ""

#: status.md:49
msgid "#   :synths=>1,"
msgstr ""

#: status.md:50
msgid "#   :groups=>7,"
msgstr ""

#: status.md:51
msgid "#   :sdefs=>61,"
msgstr ""

#: status.md:52
msgid "#   :avg_cpu=>0.20156468451023102,"
msgstr ""

#: status.md:53
msgid "#   :peak_cpu=>0.36655542254447937,"
msgstr ""

#: status.md:54
msgid "#   :nom_samp_rate=>44100.0,"
msgstr ""

#: status.md:55
msgid "#   :act_samp_rate=>44099.9998411752,"
msgstr ""

#: status.md:56
msgid "#   :audio_busses=>2,"
msgstr ""

#: status.md:57
msgid "#   :control_busses=>0"
msgstr ""

#: status.md:58
msgid "# }"
msgstr ""

#: stop.md:9
msgid ""
"Stops the current thread or if not in a thread, stops the current run. Does no"
"t stop any running synths triggered previously in the run/thread or kill any e"
"xisting sub-threads."
msgstr ""

#: stop.md:25
msgid "  stop               "
msgstr ""

#: stop.md:26
msgid "  sample :loop_garzul"
msgstr ""

#: stop.md:37
msgid "#=> this sample is played until completion"
msgstr ""

#: stop.md:39
msgid "#=> signal to stop executing this run"
msgstr ""

#: stop.md:40
msgid "#=> this never executes"
msgstr ""

#: stop.md:75
msgid "#=> this note plays"
msgstr ""

#: stop.md:77
msgid "#=> this sleep never happens"
msgstr ""

#: stop.md:78
msgid "#=> this play never happens"
msgstr ""

#: stop.md:81
msgid "#=> this plays as the stop only affected the above thread"
msgstr ""

#: stop.md:117
msgid "# Stopping live loops"
msgstr ""

#: stop.md:121
msgid "# live loop :foo will now stop and no longer loop"
msgstr ""

#: stop.md:124
msgid "# live loop :bar will continue looping"
msgstr ""

#: stretch.md:9
msgid ""
"Stretches a list of values each value repeated count times. Always returns a r"
"ing regardless of the type of the list that is stretched. To preserve type, co"
"nsider using `.stretch` i.e. `(ramp 1, 2, 3).stretch(2) #=> (ramp 1, 1, 2, 2, "
"3, 3)`"
msgstr ""

#: stretch.md:23
msgid "(stretch [1,2], 3)   "
msgstr ""

#: stretch.md:34
msgid "#=> (ring 1, 1, 1, 2, 2, 2)"
msgstr ""

#: stretch.md:61
msgid "#=> (ring :e2, :c3, :c2, :c2, :d3, :d3)"
msgstr ""

#: sync.md:9
msgid ""
"Pause/block the current thread until a `cue` heartbeat with a matching `cue_id"
"` is received. When a matching `cue` message is received, unblock the current "
"thread, and continue execution with the virtual time set to match the thread t"
"hat sent the `cue` heartbeat. The current thread is therefore synced to the `c"
"ue` thread. If multiple cue ids are passed as arguments, it will `sync` on the"
" first matching `cue_id`. The BPM of the cueing thread can optionally be inher"
"ited by using the bpm_sync: opt."
msgstr ""

#: sync.md:43
msgid "# this parks the current thread waiting for a foo sync message to be received."
msgstr ""

#: sync.md:49
msgid "# We send a sync message from the main thread."
msgstr ""

#: sync.md:96
msgid "# waiting for :tick sync messages"
msgstr ""

#: sync.md:125
msgid "# Wait for either a :foo or :bar cue"
msgstr ""

#: sync.md:190
msgid "# waiting for :foo sync messages"
msgstr ""

#: sync.md:197
msgid "# waiting for :bar sync messages"
msgstr ""

#: sync.md:204
msgid "# waiting for :baz sync messages"
msgstr ""

#: sync_bpm.md:9
msgid "An alias for `sync` with the `bpm_sync:` opt set to true."
msgstr ""

#: sync_bpm.md:23
msgid "See examples for sync"
msgstr ""

#: synth.md:9
msgid ""
"Trigger specified synth with given opts. Bypasses `current_synth` value, yet s"
"till honours `current_synth_defaults`. When using `synth`, the note is no long"
"er an explicit argument but an opt with the key `note:`."
msgstr ""

#: synth.md:11
msgid ""
"If note: opt is `nil`, `:r` or `:rest`, play is ignored and treated as a rest."
" Also, if the `on:` opt is specified and returns `false`, or `nil` then play i"
"s similarly ignored and treated as a rest."
msgstr ""

#: synth.md:13
msgid ""
"If the synth name is `nil` behaviour is identical to that of `play` in that th"
"e `current_synth` will determine the actual synth triggered."
msgstr ""

#: synth.md:15
msgid ""
"If a block is given, it is assumed to take one arg which will be the controlla"
"ble synth node and the body of the block is run in an implicit `in_thread`. Th"
"is allows for asynchronous control of the synth without interfering with time."
" For synchronous control capture the result of `synth` as a variable and use t"
"hat."
msgstr ""

#: synth.md:17
msgid ""
"Note that the default opts listed are only a guide to the most common opts acr"
"oss all the synths. Not all synths support all the default opts and each synth"
" typically supports many more opts specific to that synth. For example, the `:"
"tb303` synth supports 45 unique opts. For a full list of a synth's opts see it"
"s documentation in the Help system. This can be accessed directly by clicking "
"on the name of the synth and using the shortcut `C-i`"
msgstr ""

#: synth.md:31
msgid "use_synth :beep           "
msgstr ""

#: synth.md:32
msgid "play 60                   "
msgstr ""

#: synth.md:34
msgid "synth :dsaw, note: 60   "
msgstr ""

#: synth.md:35
msgid "                        "
msgstr ""

#: synth.md:46
msgid "# Set current synth to :beep"
msgstr ""

#: synth.md:47
msgid "# Play note 60 with opt defaults"
msgstr ""

#: synth.md:49
msgid "# Bypass current synth and play :dsaw"
msgstr ""

#: synth.md:50
msgid "# with note 60 and opt defaults"
msgstr ""

#: synth.md:77
msgid "# Play note 60 of the :fm synth with an amplitude of 0.5"
msgstr ""

#: synth.md:106
msgid "# Play note 50 of the :dsaw synth with a release of 5"
msgstr ""

#: synth.md:133
msgid "# You can play chords with the notes: opt:"
msgstr ""

#: synth.md:182
msgid "# on: vs if"
msgstr ""

#: synth.md:188 synth.md:199
msgid "# Here, we're calling notes.tick"
msgstr ""

#: synth.md:189
msgid "# every time we attempt to play the synth"
msgstr ""

#: synth.md:190
msgid "# so the notes rise faster than rhyth2"
msgstr ""

#: synth.md:200
msgid "# only when the spread says to play"
msgstr ""

#: synth.md:201
msgid "# so the notes rise slower than rhyth"
msgstr ""

#: synth_names.md:9
msgid "Return a list of all the synths available"
msgstr ""

#: tick.md:9
msgid ""
"Increment the default tick by 1 and return value. Successive calls to `tick` w"
"ill continue to increment the default tick. If a `key` is specified, increment"
" that specific tick. If an increment `value` is specified, increment key by th"
"at value rather than 1. Ticks are `in_thread` and `live_loop` local, so increm"
"enting a tick only affects the current thread's version of that tick. See `tic"
"k_reset` and `tick_set` for directly manipulating the tick vals."
msgstr ""

#: tick.md:23
msgid "puts tick"
msgstr ""

#: tick.md:24 tick.md:25 tick.md:26
msgid "  puts tick"
msgstr ""

#: tick.md:70
msgid "#=> 0 # named ticks have their own counts"
msgstr ""

#: tick.md:73
msgid "#=> 0 # tick :bar is independent of tick :foo"
msgstr ""

#: tick.md:109
msgid "# You can tick by more than increments of 1"
msgstr ""

#: tick.md:110
msgid "# using the step: opt"
msgstr ""

#: tick.md:116
msgid "#=> 6"
msgstr ""

#: tick.md:117
msgid "#=> 16"
msgstr ""

#: tick.md:118
msgid "#=> 17"
msgstr ""

#: tick.md:155
msgid "# Each_live loop has its own separate ticks"
msgstr ""

#: tick.md:157
msgid "# the fast_tick live_loop's tick will"
msgstr ""

#: tick.md:158
msgid "# be updated every 2 seconds"
msgstr ""

#: tick.md:162
msgid "# the slow_tick live_loop's tick is"
msgstr ""

#: tick.md:163
msgid "# totally independent from the fast_tick"
msgstr ""

#: tick.md:164
msgid "# live loop and will be updated every 4"
msgstr ""

#: tick.md:165
msgid "# seconds"
msgstr ""

#: tick.md:206
msgid "# the regular_tick live_loop's tick will"
msgstr ""

#: tick.md:207
msgid "# be updated every second"
msgstr ""

#: tick.md:211
msgid "# randomly reset tick"
msgstr ""

#: tick.md:215
msgid "# this live_loop's tick is totally"
msgstr ""

#: tick.md:216
msgid "# independent and the reset only affects"
msgstr ""

#: tick.md:217
msgid "# this tick."
msgstr ""

#: tick.md:249
msgid "# Ticks work directly on lists, and will tick through each element"
msgstr ""

#: tick.md:250
msgid "# However, once they get to the end, they'll return nil"
msgstr ""

#: tick.md:252
msgid "# play all notes just once, then rests"
msgstr ""

#: tick.md:286
msgid "# Normal ticks interact directly with list ticks"
msgstr ""

#: tick.md:288
msgid "# Increment the default tick"
msgstr ""

#: tick.md:289
msgid "# this now play every *other* note just once,"
msgstr ""

#: tick.md:290
msgid "# then rests"
msgstr ""

#: tick.md:325
msgid "# Ticks work wonderfully with rings"
msgstr ""

#: tick.md:326
msgid "# as the ring ensures the tick wraps"
msgstr ""

#: tick.md:327
msgid "# round internally always returning a"
msgstr ""

#: tick.md:328
msgid "# value"
msgstr ""

#: tick.md:330 tick.md:366
msgid "# play all notes just once, then repeats"
msgstr ""

#: tick.md:363
msgid "# Ticks work wonderfully with scales"
msgstr ""

#: tick.md:364
msgid "# which are also rings"
msgstr ""

#: tick_reset.md:9
msgid ""
"Reset default tick to 0. If a `key` is referenced, set that tick to 0 instead."
" Same as calling tick_set(0)"
msgstr ""

#: tick_reset.md:24 tick_reset.md:25 tick_reset.md:26 tick_reset_all.md:24
msgid "  tick"
msgstr ""

#: tick_reset.md:28
msgid "  tick_set 0"
msgstr ""

#: tick_reset.md:40
msgid "# increment default tick a few times"
msgstr ""

#: tick_reset.md:44
msgid "#=> 2 (default tick is now 2)"
msgstr ""

#: tick_reset.md:45 tick_reset.md:86
msgid "# default tick is now 0"
msgstr ""

#: tick_reset.md:46
msgid "#=> 0 (default tick is now 0"
msgstr ""

#: tick_reset.md:81
msgid "# increment tick :foo a few times"
msgstr ""

#: tick_reset.md:85
msgid "#=> 2 (tick :foo is now 2)"
msgstr ""

#: tick_reset.md:87
msgid "#=> 2 (tick :foo is still 2)"
msgstr ""

#: tick_reset.md:88
msgid "#  reset tick :foo"
msgstr ""

#: tick_reset.md:89
msgid "#=> 0 (tick :foo is now 0)"
msgstr ""

#: tick_reset_all.md:9
msgid "Reset all ticks - default and keyed"
msgstr ""

#: tick_reset_all.md:23
msgid "tick     "
msgstr ""

#: tick_reset_all.md:25 tick_reset_all.md:26 tick_reset_all.md:27
msgid "  tick :foo"
msgstr ""

#: tick_reset_all.md:29 tick_reset_all.md:32
msgid "  puts look(:foo)"
msgstr ""

#: tick_reset_all.md:30
msgid "  tick_reset_all"
msgstr ""

#: tick_reset_all.md:43
msgid "# increment default tick and tick :foo"
msgstr ""

#: tick_set.md:9
msgid ""
"Set the default tick to the specified `value`. If a `key` is referenced, set t"
"hat tick to `value` instead. Next call to `look` will return `value`."
msgstr ""

#: tick_set.md:23
msgid "tick_set 40"
msgstr ""

#: tick_set.md:24
msgid "  puts look  "
msgstr ""

#: tick_set.md:35
msgid "# set default tick to 40"
msgstr ""

#: tick_set.md:36
msgid "#=> 40"
msgstr ""

#: tick_set.md:65
msgid "# set tick :foo to 40"
msgstr ""

#: tick_set.md:66
msgid "#=> 40 (tick :foo is now 40)"
msgstr ""

#: tick_set.md:67
msgid "#=> 0 (default tick is unaffected)"
msgstr ""

#: time_warp.md:9
msgid ""
"The code within the given block is executed with the specified delta time shif"
"t specified in beats. For example, if the delta value is 0.1 then all code wit"
"hin the block is executed with a 0.1 beat delay. Negative values are allowed w"
"hich means you can move a block of code *backwards in time*. For example a del"
"ta value of -0.1 will execute the code in the block 0.1 beats ahead of time. T"
"he time before the block started is restored after the execution of the block."
msgstr ""

#: time_warp.md:13
msgid ""
"Note that the code within the block is executed synchronously with the code be"
"fore and after, so all thread locals will be modified inline - as is the case "
"for `with_fx`. However, as time is always restored to the value before `time_w"
"arp` started, you can use it to schedule events for the future in a similar fa"
"shion to a thread (via `at` or `in_thread`) without having to use an entirely "
"fresh and distinct set of thread locals - see examples."
msgstr ""

#: time_warp.md:15
msgid ""
"Also, note that you cannot travel backwards in time beyond the `current_sched_"
"ahead_time`."
msgstr ""

#: time_warp.md:17
msgid ""
"If the `time_warp` block is within a `density` block, the delta time is not af"
"fected (although all the other times such as sleep and phase durations will be"
" affected) - see example."
msgstr ""

#: time_warp.md:19
msgid ""
"`time_warp` is ahead-of-time scheduling within the current thread. See `at` fo"
"r just-in-time scheduling using multiple isolated threads."
msgstr ""

#: time_warp.md:34 time_warp.md:50
msgid "play 70           "
msgstr ""

#: time_warp.md:36
msgid "play 75           "
msgstr ""

#: time_warp.md:38
msgid "time_warp 0.1 do"
msgstr ""

#: time_warp.md:40 time_warp.md:42
msgid "  play 80         "
msgstr ""

#: time_warp.md:44
msgid "end               "
msgstr ""

#: time_warp.md:61
msgid "# shift forwards in time"
msgstr ""

#: time_warp.md:62 time_warp.md:123
msgid "#=> plays at time 0"
msgstr ""

#: time_warp.md:64 time_warp.md:125
msgid "#=> plays at time 1"
msgstr ""

#: time_warp.md:67 time_warp.md:132
msgid "# time shifts forward by 0.1 beats"
msgstr ""

#: time_warp.md:68
msgid "#=> plays at 1.1"
msgstr ""

#: time_warp.md:70
msgid "#=> plays at 1.6"
msgstr ""

#: time_warp.md:72
msgid "# time shifts back by 0.6 beats"
msgstr ""

#: time_warp.md:74 time_warp.md:134
msgid "# we now honour the original sleep 1 and the"
msgstr ""

#: time_warp.md:75 time_warp.md:135
msgid "# sleep 0.5 within the time_warp block is"
msgstr ""

#: time_warp.md:76
msgid "# ignored including the 0.1 shift offset"
msgstr ""

#: time_warp.md:78 time_warp.md:137
msgid "#=> plays at 1"
msgstr ""

#: time_warp.md:121
msgid "# shift backwards in time"
msgstr ""

#: time_warp.md:128
msgid "# time shifts backwards by 0.1 beats"
msgstr ""

#: time_warp.md:129
msgid "#=> plays at 0.9"
msgstr ""

#: time_warp.md:131
msgid "#=> plays at 1.4"
msgstr ""

#: time_warp.md:136
msgid "# ignored, including the -0.1 offset"
msgstr ""

#: time_warp.md:176
msgid "# Ticks count linearly through time_warp"
msgstr ""

#: time_warp.md:178 time_warp.md:237
msgid "#=> prints 0 (at time 0)"
msgstr ""

#: time_warp.md:183
msgid "#=> prints 1 (at time 3)"
msgstr ""

#: time_warp.md:188
msgid "#=> prints 2 (at time 1.5)"
msgstr ""

#: time_warp.md:235
msgid "# Comparing time_warp with at"
msgstr ""

#: time_warp.md:239
msgid "#=> prints 1 (at time 0.5)"
msgstr ""

#: time_warp.md:242
msgid "#=> prints 2 (at time 2.5)"
msgstr ""

#: time_warp.md:244
msgid "#=> prints 3 (at time 3)"
msgstr ""

#: time_warp.md:247
msgid "# the at will reset all thread locals"
msgstr ""

#: time_warp.md:248
msgid "#=> prints 0 (At time 3.5)"
msgstr ""

#: time_warp.md:250
msgid "#=> prints 1 (At time 4)"
msgstr ""

#: time_warp.md:255
msgid "#=> prints 4 (at time 1)"
msgstr ""

#: time_warp.md:291
msgid "# Time Warp within Density"
msgstr ""

#: time_warp.md:292
msgid "# Typically this will double the BPM and affect all times"
msgstr ""

#: time_warp.md:293
msgid "# in addition to looping the internal block twice"
msgstr ""

#: time_warp.md:294
msgid "# However, this time is *not* affected and will remain 0.5"
msgstr ""

#: time_warp.md:295
msgid "# This phase duration *is* affected and will be 0.25"
msgstr ""

#: time_warp.md:297
msgid "# This time *will* be affected by the density and be 0.5"
msgstr ""

#: time_warp.md:339
msgid "# Time Warp with lists of times"
msgstr ""

#: time_warp.md:342
msgid "# Will print \"hello\" at 0, 1, 2, and 3 seconds"
msgstr ""

#: time_warp.md:344
msgid "# Notice that the run completes before all the"
msgstr ""

#: time_warp.md:345
msgid "# messages have been delivered. This is because it"
msgstr ""

#: time_warp.md:346
msgid "# schedules all the messages at once so the program"
msgstr ""

#: time_warp.md:347
msgid "# can complete immediately. This is unlike at which"
msgstr ""

#: time_warp.md:348
msgid "# would appear to behave similarly, but would wait"
msgstr ""

#: time_warp.md:349
msgid "# for all messages to be delivered (on time) before"
msgstr ""

#: time_warp.md:350
msgid "# allowing the program to complete."
msgstr ""

#: time_warp.md:501
msgid ""
"# If you specify the block with 2 args, it will pass through both the time and"
" the param"
msgstr ""

#: time_warp.md:531
msgid ""
"# If you specify the block with 2 args, and no param list to at, it will pass "
"through both the time and the index"
msgstr ""

#: time_warp.md:561
msgid ""
"# If you specify the block with 3 args, it will pass through the time, the par"
"am and the index"
msgstr ""

#: time_warp.md:601
msgid "# time_warp consumes & interferes with the outer random stream"
msgstr ""

#: time_warp.md:604
msgid "# the random stream inside the at block is the"
msgstr ""

#: time_warp.md:605
msgid "# same as the one in the outer block"
msgstr ""

#: time_warp.md:607
msgid "# 0.733917236328125"
msgstr ""

#: time_warp.md:608
msgid "# undo last call to rand"
msgstr ""

#: time_warp.md:612
msgid "# value is now 0.733917236328125 again"
msgstr ""

#: time_warp.md:649
msgid "# Each block run inherits the same thread locals from the previous one."
msgstr ""

#: time_warp.md:650
msgid "# This means things like the thread local counters can flow through"
msgstr ""

#: time_warp.md:651
msgid "# time warp iterations:"
msgstr ""

#: time_warp.md:654
msgid "# 0"
msgstr ""

#: time_warp.md:659
msgid "# 3"
msgstr ""

#: uncomment.md:9
msgid ""
"Evaluates all of the code within the block. Use to reverse the effect of the c"
"omment without having to explicitly remove it."
msgstr ""

#: uncomment.md:23
msgid "uncomment do"
msgstr ""

#: uncomment.md:38 uncomment.md:40
msgid "# played"
msgstr ""

#: uncomment.md:39
msgid "# sleep happens"
msgstr ""

#: use_arg_bpm_scaling.md:9
msgid ""
"Turn synth argument bpm scaling on or off for the current thread. This is on b"
"y default. Note, using `rt` for args will result in incorrect times when used "
"after turning arg bpm scaling off."
msgstr ""

#: use_arg_bpm_scaling.md:23 with_arg_bpm_scaling.md:23
msgid "use_bpm 120"
msgstr ""

#: use_arg_bpm_scaling.md:24 use_arg_bpm_scaling.md:27
#: with_arg_bpm_scaling.md:24
msgid "play 50, release: 2"
msgstr ""

#: use_arg_bpm_scaling.md:25 use_arg_bpm_scaling.md:28
msgid "sleep 2            "
msgstr ""

#: use_arg_bpm_scaling.md:26
msgid "use_arg_bpm_scaling false"
msgstr ""

#: use_arg_bpm_scaling.md:40 with_arg_bpm_scaling.md:38
msgid "# release is actually 1 due to bpm scaling"
msgstr ""

#: use_arg_bpm_scaling.md:41
msgid "# actually sleeps for 1 second"
msgstr ""

#: use_arg_bpm_scaling.md:43 with_arg_bpm_scaling.md:40
msgid "# release is now 2"
msgstr ""

#: use_arg_bpm_scaling.md:44
msgid "# still sleeps for 1 second"
msgstr ""

#: use_arg_bpm_scaling.md:77 with_arg_bpm_scaling.md:74
msgid "# Interaction with rt"
msgstr ""

#: use_arg_bpm_scaling.md:79 with_arg_bpm_scaling.md:76
msgid "# release is 2 seconds"
msgstr ""

#: use_arg_bpm_scaling.md:80 with_arg_bpm_scaling.md:77
msgid "# sleeps for 2 seconds"
msgstr ""

#: use_arg_bpm_scaling.md:82 with_arg_bpm_scaling.md:79
msgid "# ** Warning: release is NOT 2 seconds! **"
msgstr ""

#: use_arg_bpm_scaling.md:83 with_arg_bpm_scaling.md:80
msgid "# still sleeps for 2 seconds"
msgstr ""

#: use_arg_checks.md:9
msgid ""
"When triggering synths, each argument is checked to see if it is sensible. Whe"
"n argument checking is enabled and an argument isn't sensible, you'll see an e"
"rror in the debug pane. This setting allows you to explicitly enable and disab"
"le the checking mechanism. See with_arg_checks for enabling/disabling argument"
" checking only for a specific `do`/`end` block."
msgstr ""

#: use_arg_checks.md:23 use_arg_checks.md:25
msgid "play 50, release: 5"
msgstr ""

#: use_arg_checks.md:24
msgid "use_arg_checks false"
msgstr ""

#: use_arg_checks.md:36 with_arg_checks.md:50 with_arg_checks.md:60
msgid "# Args are checked"
msgstr ""

#: use_arg_checks.md:38 with_arg_checks.md:54
msgid "# Args are not checked"
msgstr ""

#: use_bpm.md:9
msgid ""
"Sets the tempo in bpm (beats per minute) for everything afterwards. Affects al"
"l subsequent calls to `sleep` and all temporal synth arguments which will be s"
"caled to match the new bpm. If you wish to bypass scaling in calls to sleep, s"
"ee the fn `rt`. Also, if you wish to bypass time scaling in synth args see `us"
"e_arg_bpm_scaling`. See also `with_bpm` for a block scoped version of `use_bpm"
"`."
msgstr ""

#: use_bpm.md:11 with_bpm.md:11
msgid ""
"  For dance music here's a rough guide for which BPM to aim for depending on y"
"our genre:"
msgstr ""

#: use_bpm.md:13 with_bpm.md:13
msgid "  * Dub: 60-90 bpm"
msgstr ""

#: use_bpm.md:14 with_bpm.md:14
msgid "  * Hip-hop: 60-100 bpm"
msgstr ""

#: use_bpm.md:15 with_bpm.md:15
msgid "  * Downtempo: 90-120 bpm"
msgstr ""

#: use_bpm.md:16 with_bpm.md:16
msgid "  * House: 115-130 bpm"
msgstr ""

#: use_bpm.md:17 with_bpm.md:17
msgid "  * Techno/trance: 120-140 bpm"
msgstr ""

#: use_bpm.md:18 with_bpm.md:18
msgid "  * Dubstep: 135-145 bpm"
msgstr ""

#: use_bpm.md:19 with_bpm.md:19
msgid "  * Drum and bass: 160-180 bpm"
msgstr ""

#: use_bpm.md:34 use_bpm.md:43 with_bpm.md:35 with_bpm.md:54
msgid "  4.times do"
msgstr ""

#: use_bpm.md:35
msgid "    play 50, attack: 0.5, release: 0.25"
msgstr ""

#: use_bpm.md:39
msgid "  sleep 2 "
msgstr ""

#: use_bpm.md:42
msgid "  use_bpm 120 "
msgstr ""

#: use_bpm.md:44 use_bpm.md:53
msgid "    play 62, attack: 0.5, release: 0.25"
msgstr ""

#: use_bpm.md:51
msgid "  use_bpm 240 "
msgstr ""

#: use_bpm.md:52
msgid "  8.times do"
msgstr ""

#: use_bpm.md:65 with_bpm.md:67
msgid "# default tempo is 60 bpm"
msgstr ""

#: use_bpm.md:67
msgid "# attack is 0.5s and release is 0.25s"
msgstr ""

#: use_bpm.md:68 use_bpm.md:80
msgid "# sleep for 1 second"
msgstr ""

#: use_bpm.md:71
msgid "# sleep for 2 seconds"
msgstr ""

#: use_bpm.md:73
msgid "# Let's make it go faster..."
msgstr ""

#: use_bpm.md:74
msgid "# double the bpm"
msgstr ""

#: use_bpm.md:76
msgid "# attack is scaled to 0.25s and release is now 0.125s"
msgstr ""

#: use_bpm.md:77
msgid "# actually sleeps for 0.5 seconds"
msgstr ""

#: use_bpm.md:82
msgid "# Let's make it go even faster..."
msgstr ""

#: use_bpm.md:83
msgid "#  bpm is 4x original speed!"
msgstr ""

#: use_bpm.md:85
msgid "# attack is scaled to 0.125s and release is now 0.0625s"
msgstr ""

#: use_bpm.md:86
msgid "# actually sleeps for 0.25 seconds"
msgstr ""

#: use_bpm_mul.md:9
msgid ""
"Sets the tempo in bpm (beats per minute) as a multiplication of the current te"
"mpo. Affects all containing calls to `sleep` and all temporal synth arguments "
"which will be scaled to match the new bpm. See also `use_bpm`"
msgstr ""

#: use_bpm_mul.md:27 with_bpm_mul.md:27
msgid "  sleep 2     "
msgstr ""

#: use_bpm_mul.md:28
msgid "  use_bpm_mul 0.5"
msgstr ""

#: use_bpm_mul.md:43
msgid "# Sleeps for 1 seconds"
msgstr ""

#: use_bpm_mul.md:45 use_bpm_mul.md:48 with_bpm_mul.md:48 with_bpm_mul.md:51
msgid "# Sleeps for 2 seconds"
msgstr ""

#: use_bpm_mul.md:46 with_bpm_mul.md:49
msgid "# BPM is now (60 * 0.5) == 30"
msgstr ""

#: use_cent_tuning.md:11
msgid ""
"See `with_cent_tuning` for setting the cent tuning value only for a specific `"
"do`/`end` block. To transpose entire semitones see `use_transpose`."
msgstr ""

#: use_cent_tuning.md:26 with_cent_tuning.md:23
msgid "use_cent_tuning 1"
msgstr ""

#: use_cue_logging.md:9
msgid ""
"Enable or disable log messages created on cues. This does not disable the cues"
" themselves, it just stops them from being printed to the log"
msgstr ""

#: use_cue_logging.md:23
msgid "use_cue_logging true"
msgstr ""

#: use_cue_logging.md:34
msgid "# Turn on cue messages"
msgstr ""

#: use_cue_logging.md:61
msgid "# Disable cue messages"
msgstr ""

#: use_debug.md:9
msgid ""
"Enable or disable messages created on synth triggers. If this is set to false,"
" the synths will be silent until debug is turned back on. Silencing debug mess"
"ages can reduce output noise and also increase performance on slower platforms"
". See `with_debug` for setting the debug value only for a specific `do`/`end` "
"block."
msgstr ""

#: use_debug.md:23 with_debug.md:24
msgid "use_debug true"
msgstr ""

#: use_debug.md:34
msgid "# Turn on debug messages"
msgstr ""

#: use_debug.md:61
msgid "# Disable debug messages"
msgstr ""

#: use_merged_midi_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `midi_*` fns."
" Merges the specified values with any previous defaults, rather than replacing"
" them"
msgstr ""

#: use_merged_midi_defaults.md:25 use_midi_defaults.md:25
#: with_merged_midi_defaults.md:25
msgid "use_midi_defaults channel: 3, port: \"foo\""
msgstr ""

#: use_merged_midi_defaults.md:27 use_midi_defaults.md:27
#: with_merged_midi_defaults.md:27
msgid "midi_note_on :e3"
msgstr ""

#: use_merged_midi_defaults.md:29
msgid "use_merged_midi_defaults channel: 1"
msgstr ""

#: use_merged_midi_defaults.md:31 use_midi_defaults.md:31
#: with_merged_midi_defaults.md:36
msgid "midi_note_on :e2"
msgstr ""

#: use_merged_midi_defaults.md:32 use_merged_midi_defaults.md:33
#: with_merged_midi_defaults.md:37 with_merged_midi_defaults.md:38
msgid "                "
msgstr ""

#: use_merged_midi_defaults.md:44 use_midi_defaults.md:42
#: with_merged_midi_defaults.md:49
msgid "# Sends MIDI :e1 note_on with default opts"
msgstr ""

#: use_merged_midi_defaults.md:48 use_midi_defaults.md:46
#: with_merged_midi_defaults.md:53
msgid "# Sends MIDI :e3 note_on to channel 3 on port \"foo\""
msgstr ""

#: use_merged_midi_defaults.md:52 with_merged_midi_defaults.md:57
msgid "# Sends MIDI :e2 note_on to channel 1 on port \"foo\"."
msgstr ""

#: use_merged_midi_defaults.md:53 with_merged_midi_defaults.md:58
msgid "# This is because the call to use_merged_midi_defaults overrode the"
msgstr ""

#: use_merged_midi_defaults.md:54 with_merged_midi_defaults.md:59
msgid "# channel but not the port which got merged in."
msgstr ""

#: use_merged_sample_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `sample`. Mer"
"ges the specified values with any previous defaults, rather than replacing the"
"m."
msgstr ""

#: use_merged_sample_defaults.md:25 with_merged_sample_defaults.md:25
msgid "use_merged_sample_defaults amp: 0.5, cutoff: 70"
msgstr ""

#: use_merged_sample_defaults.md:29
msgid "use_merged_sample_defaults cutoff: 90"
msgstr ""

#: use_merged_sample_defaults.md:31 use_sample_defaults.md:31
#: use_timing_guarantees.md:25 with_merged_sample_defaults.md:33
#: with_sample_defaults.md:33
msgid "sample :loop_amen "
msgstr ""

#: use_merged_sample_defaults.md:42 use_sample_defaults.md:42
#: with_merged_sample_defaults.md:44 with_sample_defaults.md:44
msgid "# plays amen break with default arguments"
msgstr ""

#: use_merged_sample_defaults.md:46 use_sample_defaults.md:46
#: with_merged_sample_defaults.md:48 with_sample_defaults.md:48
msgid ""
"# plays amen break with an amp of 0.5, cutoff of 70 and defaults for rest of a"
"rgs"
msgstr ""

#: use_merged_sample_defaults.md:50
msgid ""
"# plays amen break with a cutoff of 90 and and an amp of 0.5 with defaults for"
" rest of args"
msgstr ""

#: use_merged_synth_defaults.md:9
msgid ""
"Specify synth arg values to be used by any following call to play. Merges the "
"specified values with any previous defaults, rather than replacing them."
msgstr ""

#: use_merged_synth_defaults.md:25
msgid "use_merged_synth_defaults amp: 0.5"
msgstr ""

#: use_merged_synth_defaults.md:28
msgid "use_merged_synth_defaults cutoff: 80"
msgstr ""

#: use_merged_synth_defaults.md:31
msgid "use_merged_synth_defaults amp: 0.7"
msgstr ""

#: use_merged_synth_defaults.md:43
msgid "#=> Plays note 50"
msgstr ""

#: use_merged_synth_defaults.md:46
msgid "#=> Plays note 50 with amp 0.5"
msgstr ""

#: use_merged_synth_defaults.md:49
msgid "#=> Plays note 50 with amp 0.5 and cutoff 80"
msgstr ""

#: use_merged_synth_defaults.md:52
msgid "#=> Plays note 50 with amp 0.7 and cutoff 80"
msgstr ""

#: use_merged_synth_defaults.md:83
msgid "#=> Plays note 50 with amp 0.7, cutoff 80 and pan -1"
msgstr ""

#: use_midi_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `midi_*` fns."
" Will remove and override any previous defaults."
msgstr ""

#: use_midi_defaults.md:29
msgid "use_midi_defaults channel: 1"
msgstr ""

#: use_midi_defaults.md:50
msgid ""
"# Sends MIDI :e2 note_on to channel 1. Note that the port is back to the defau"
"lt and no longer \"foo\"."
msgstr ""

#: use_midi_logging.md:9
msgid ""
"Enable or disable log messages created on MIDI functions. This does not disabl"
"e the MIDI functions themselves, it just stops them from being printed to the "
"log"
msgstr ""

#: use_midi_logging.md:23
msgid "use_midi_logging true"
msgstr ""

#: use_midi_logging.md:34
msgid "# Turn on MIDI logging"
msgstr ""

#: use_midi_logging.md:61
msgid "# Disable MIDI logging"
msgstr ""

#: use_octave.md:9
msgid ""
"Transposes your music by shifting all notes played by the specified number of "
"octaves. To shift up by an octave use a transpose of 1. To shift down use nega"
"tive numbers. See `with_octave` for setting the octave shift only for a specif"
"ic `do`/`end` block. For transposing the notes within the octave range see `us"
"e_transpose`."
msgstr ""

#: use_octave.md:24
msgid "use_octave 1"
msgstr ""

#: use_octave.md:38 use_octave.md:71 use_transpose.md:71 with_octave.md:43
#: with_transpose.md:48
msgid "# Plays note 62"
msgstr ""

#: use_octave.md:70 use_transpose.md:70
msgid "# You may change the transposition multiple times:"
msgstr ""

#: use_octave.md:75
msgid "# Plays note 86"
msgstr ""

#: use_osc.md:9
msgid ""
"Sets the destination host and port that `osc` will send messages to. If no por"
"t number is specified - will default to port 4560 (Sonic Pi's default OSC list"
"ening port)."
msgstr ""

#: use_osc.md:11
msgid ""
"OSC (Open Sound Control) is a simple way of passing messages between two separ"
"ate programs on the same computer or even on different computers via a local n"
"etwork or even the internet. `use_osc` allows you to specify which computer (`"
"hostname`) and program (`port`) to send messages to."
msgstr ""

#: use_osc.md:13
msgid ""
"It is possible to send messages to the same computer by using the host name `\""
"localhost\"`"
msgstr ""

#: use_osc.md:15
msgid ""
"This is a thread-local setting - therefore each thread (or live loop) can have"
" their own separate `use_osc` values."
msgstr ""

#: use_osc.md:17
msgid "Note that calls to `osc_send` will ignore these values."
msgstr ""

#: use_osc.md:92 use_osc.md:133
msgid "# 2) The fractional number (float) 3,89"
msgstr ""

#: use_osc.md:169
msgid "# use_osc only affects calls to osc until the next call to use_osc"
msgstr ""

#: use_osc.md:173
msgid "# Send another OSC message to port 7000"
msgstr ""

#: use_osc.md:176
msgid "# Send an OSC message to port 7005"
msgstr ""

#: use_osc.md:177
msgid "# Send another OSC message to port 7005"
msgstr ""

#: use_osc.md:226
msgid "# threads may have their own use_osc value"
msgstr ""

#: use_osc.md:231
msgid "# Thread inherits outside use_osc values"
msgstr ""

#: use_osc.md:232
msgid "# and therefore sends OSC messages to port 7000"
msgstr ""

#: use_osc.md:236
msgid "# Override OSC hostname and port for just this"
msgstr ""

#: use_osc.md:237
msgid "# thread (live loop :bar). Live loop :foo is"
msgstr ""

#: use_osc.md:238
msgid "# unaffected."
msgstr ""

#: use_osc.md:240
msgid "# Send OSC messages to port 7005"
msgstr ""

#: use_osc.md:244 with_osc.md:44
msgid "# Specify port 7010"
msgstr ""

#: use_osc.md:245
msgid "# Send another OSC message to port 7010"
msgstr ""

#: use_osc.md:246
msgid "# Note that neither live loops :foo or :bar"
msgstr ""

#: use_osc.md:247
msgid "# are affected (their use_osc values are"
msgstr ""

#: use_osc.md:248
msgid "# independent and isolated."
msgstr ""

#: use_osc_logging.md:9
msgid ""
"Enable or disable log messages created on OSC functions. This does not disable"
" the OSC functions themselves, it just stops them from being printed to the lo"
"g"
msgstr ""

#: use_osc_logging.md:23
msgid "use_osc_logging true"
msgstr ""

#: use_osc_logging.md:34
msgid "# Turn on OSC logging"
msgstr ""

#: use_osc_logging.md:61
msgid "# Disable OSC logging"
msgstr ""

#: use_random_seed.md:9
msgid ""
"Resets the random number generator to the specified seed. All subsequently gen"
"erated random numbers and randomisation functions such as `shuffle` and `choos"
"e` will use this new generator and the current generator is discarded. Use thi"
"s to change the sequence of random numbers in your piece in a way that can be "
"reproduced. Especially useful if combined with iteration. See examples."
msgstr ""

#: use_random_seed.md:25 use_random_seed.md:27 with_random_seed.md:26
msgid "  use_random_seed 1"
msgstr ""

#: use_random_seed.md:28 with_random_seed.md:25
msgid "  puts rand "
msgstr ""

#: use_random_seed.md:41 with_random_seed.md:44
msgid "# reset random seed to 1"
msgstr ""

#: use_random_seed.md:42 with_random_seed.md:45 with_random_seed.md:48
#: with_random_seed.md:50
msgid "# => 0.417022004702574"
msgstr ""

#: use_random_seed.md:43
msgid "# reset random seed back to 1"
msgstr ""

#: use_random_seed.md:44
msgid "#=> 0.417022004702574"
msgstr ""

#: use_random_seed.md:94 with_random_seed.md:110
msgid "# Generating melodies"
msgstr ""

#: use_random_seed.md:95 with_random_seed.md:111
msgid "# Create a set of notes to choose from."
msgstr ""

#: use_random_seed.md:96 with_random_seed.md:112
msgid "# Scales work well for this"
msgstr ""

#: use_random_seed.md:99 with_random_seed.md:115
msgid "# Create a live loop"
msgstr ""

#: use_random_seed.md:101 with_random_seed.md:117
msgid "# Set the random seed to a known value every"
msgstr ""

#: use_random_seed.md:102 with_random_seed.md:118
msgid "# time around the loop. This seed is the key"
msgstr ""

#: use_random_seed.md:103 with_random_seed.md:119
msgid "# to our melody. Try changing the number to"
msgstr ""

#: use_random_seed.md:104 with_random_seed.md:120
msgid "# something else. Different numbers produce"
msgstr ""

#: use_random_seed.md:105 with_random_seed.md:121
msgid "# different melodies"
msgstr ""

#: use_random_seed.md:107 with_random_seed.md:123
msgid "# Now iterate a number of times. The size of"
msgstr ""

#: use_random_seed.md:108 with_random_seed.md:124
msgid "# the iteration will be the length of the"
msgstr ""

#: use_random_seed.md:109 with_random_seed.md:125
msgid "# repeating melody."
msgstr ""

#: use_random_seed.md:111 with_random_seed.md:127
msgid "# 'Randomly' choose a note from our ring of"
msgstr ""

#: use_random_seed.md:112 with_random_seed.md:128
msgid "# notes. See how this isn't actually random"
msgstr ""

#: use_random_seed.md:113 with_random_seed.md:129
msgid "# but uses a reproducible method! These notes"
msgstr ""

#: use_random_seed.md:114 with_random_seed.md:130
msgid "# are therefore repeated over and over..."
msgstr ""

#: use_random_source.md:9
msgid ""
"Sets the random number source to be one of `:white`, `:pink`, `:light_pink`, `"
":dark_pink` or `:perlin`."
msgstr ""

#: use_random_source.md:11
msgid ""
"`:white` is totally random - between 0 and 1, you can expect an even spread of"
" values around 0.1, 0.2, 0.3 etc. This means that jumping around within the ra"
"nge (including large jumps) is expected."
msgstr ""

#: use_random_source.md:13
msgid ""
"`:pink` is more likely to produce values in the middle of the range and less l"
"ikely to produce values at the extremes. Between 0 and 1 you expect to see a c"
"oncentration of values around 0.5. This can make random melodies a little bit "
"more smooth."
msgstr ""

#: use_random_source.md:15
msgid ""
"`:perlin` is a special kind of noise which produces gradients, a bit like a mo"
"untain landscape. Large jumps are much less likely and you will tend to see lo"
"ts of smooth motion going either up or down"
msgstr ""

#: use_random_source.md:17
msgid ""
"`:light_pink` is halfway between white noise and pink noise - more random and "
"jumpy"
msgstr ""

#: use_random_source.md:19
msgid ""
"`:dark_pink` is halfway between pink noise and brown noise - less jumpy with s"
"moother slopes"
msgstr ""

#: use_random_source.md:21
msgid ""
"You can see the 'buckets' that the numbers between 0 and 1 fall into with the "
"following code:"
msgstr ""

#: use_random_source.md:23
msgid "        rand_type :white"
msgstr ""

#: use_random_source.md:24 use_random_source.md:26 use_random_source.md:28
msgid "        puts 10000.times.collect { rand.round(1) }.tally.sort"
msgstr ""

#: use_random_source.md:25
msgid "        rand_type :pink"
msgstr ""

#: use_random_source.md:27
msgid "        rand_type :perlin"
msgstr ""

#: use_random_source.md:44 with_random_source.md:23
msgid "use_random_source :white"
msgstr ""

#: use_random_source.md:45 use_random_source.md:49 use_random_source.md:53
#: with_random_source.md:24 with_random_source.md:28 with_random_source.md:32
msgid "  rand_reset"
msgstr ""

#: use_random_source.md:50 with_random_source.md:29
msgid "  use_random_source :pink"
msgstr ""

#: use_random_source.md:54 with_random_source.md:33
msgid "  use_random_source :perlin"
msgstr ""

#: use_random_source.md:58 with_random_source.md:37
msgid "  with_random_source :white do"
msgstr ""

#: use_random_source.md:59 with_random_seed.md:29 with_random_seed.md:30
#: with_random_source.md:38
msgid "    puts rand"
msgstr ""

#: use_random_source.md:74 with_random_source.md:53
msgid "# use white noise as the distribution (default)"
msgstr ""

#: use_random_source.md:75 with_random_source.md:54
msgid "# reset random seed"
msgstr ""

#: use_random_source.md:76 with_random_source.md:55
msgid "# => 0.75006103515625"
msgstr ""

#: use_random_source.md:77 with_random_source.md:56
msgid "# => 0.733917236328125"
msgstr ""

#: use_random_source.md:78 use_random_source.md:89 with_random_source.md:57
#: with_random_source.md:68
msgid "# => 0.464202880859375"
msgstr ""

#: use_random_source.md:79 with_random_source.md:58
msgid "# reset it again"
msgstr ""

#: use_random_source.md:80 with_random_source.md:59
msgid "# use pink noise as the distribution"
msgstr ""

#: use_random_source.md:81 with_random_source.md:60
msgid "# => 0.47808837890625"
msgstr ""

#: use_random_source.md:82 with_random_source.md:61
msgid "# => 0.56011962890625"
msgstr ""

#: use_random_source.md:83 with_random_source.md:62
msgid "# reset it"
msgstr ""

#: use_random_source.md:84 with_random_source.md:63
msgid "# use perlin noise as the distribution"
msgstr ""

#: use_random_source.md:85 with_random_source.md:64
msgid "# => 0.546478271484375"
msgstr ""

#: use_random_source.md:86 with_random_source.md:65
msgid "# => 0.573150634765625"
msgstr ""

#: use_random_source.md:88 with_random_source.md:67
msgid "# use white noise just for this block"
msgstr ""

#: use_random_source.md:92 with_random_source.md:71
msgid "# => 0.597015380859375"
msgstr ""

#: use_random_source.md:93 with_random_source.md:72
msgid "# notice how the last generator (perlin) is restored"
msgstr ""

#: use_real_time.md:10
msgid ""
"Set sched ahead time to 0 for the current thread. Shorthand for `use_sched_ahe"
"ad_time 0`."
msgstr ""

#: use_real_time.md:12
msgid ""
"See `use_sched_ahead_time` for a version of this function which allows you to "
"set the schedule ahead time to any arbitrary value. Note, `use_real_time` will"
" override any value set with `set_sched_ahead_time!` for the current thread."
msgstr ""

#: use_real_time.md:28 with_real_time.md:29
msgid "use_real_time 1"
msgstr ""

#: use_sample_bpm.md:9
msgid "Modify bpm so that sleeping for 1 will sleep for the duration of the sample."
msgstr ""

#: use_sample_bpm.md:23
msgid "use_sample_bpm :loop_amen "
msgstr ""

#: use_sample_bpm.md:25 with_sample_bpm.md:23
msgid "live_loop :dnb do"
msgstr ""

#: use_sample_bpm.md:26
msgid "  sample :bass_dnb_f"
msgstr ""

#: use_sample_bpm.md:27 with_fx.md:29
msgid "  sample :loop_amen"
msgstr ""

#: use_sample_bpm.md:28
msgid "  sleep 1                 "
msgstr ""

#: use_sample_bpm.md:39 with_sample_bpm.md:40
msgid "#Set bpm based on :loop_amen duration"
msgstr ""

#: use_sample_bpm.md:44
msgid "#`sleep`ing for 1 actually sleeps for duration of :loop_amen"
msgstr ""

#: use_sample_bpm.md:81 with_sample_bpm.md:82
msgid "# Set bpm based on :loop_amen duration"
msgstr ""

#: use_sample_bpm.md:82 with_sample_bpm.md:83
msgid "# but also specify that the sample duration"
msgstr ""

#: use_sample_bpm.md:83 with_sample_bpm.md:84
msgid "# is actually 4 beats long."
msgstr ""

#: use_sample_bpm.md:88
msgid "#`sleep`ing for 4 actually sleeps for duration of :loop_amen"
msgstr ""

#: use_sample_bpm.md:89 with_sample_bpm.md:88
msgid "# as we specified that the sample consisted of"
msgstr ""

#: use_sample_bpm.md:90 with_sample_bpm.md:89
msgid "# 4 beats"
msgstr ""

#: use_sample_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `sample`. Wil"
"l remove and override any previous defaults."
msgstr ""

#: use_sample_defaults.md:25 with_sample_defaults.md:25
msgid "use_sample_defaults amp: 0.5, cutoff: 70"
msgstr ""

#: use_sample_defaults.md:29
msgid "use_sample_defaults cutoff: 90"
msgstr ""

#: use_sample_defaults.md:50 with_sample_defaults.md:51
msgid ""
"# plays amen break with a cutoff of 90 and defaults for rest of args - note th"
"at amp is no longer 0.5"
msgstr ""

#: use_sched_ahead_time.md:11
msgid ""
"See `set_sched_ahead_time!` for a global version of this function. Note, `use_"
"sched_ahead_time` will override any value set with `set_sched_ahead_time!` for"
" the current thread."
msgstr ""

#: use_sched_ahead_time.md:13
msgid "See `use_real_time` for a simple way of setting the schedule ahead time to 0."
msgstr ""

#: use_sched_ahead_time.md:27
msgid "use_sched_ahead_time 1"
msgstr ""

#: use_sched_ahead_time.md:75
msgid "# Each thread can have its own sched ahead time"
msgstr ""

#: use_sched_ahead_time.md:78
msgid "# Note 70 will be played with 1 second latency"
msgstr ""

#: use_sched_ahead_time.md:83
msgid "# Note 70 will be played with 0.5 second latency"
msgstr ""

#: use_synth.md:9
msgid ""
"Switch the current synth to `synth_name`. Affects all further calls to `play`."
" See `with_synth` for changing the current synth only for a specific `do`/`end"
"` block."
msgstr ""

#: use_synth.md:24
msgid "use_synth :mod_sine"
msgstr ""

#: use_synth.md:36 with_synth.md:44
msgid "# Plays with default synth"
msgstr ""

#: use_synth.md:38
msgid "# Plays with mod_sine synth"
msgstr ""

#: use_synth_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `play`. Will "
"remove and override any previous defaults."
msgstr ""

#: use_synth_defaults.md:25
msgid "use_synth_defaults amp: 0.5, cutoff: 70"
msgstr ""

#: use_synth_defaults.md:29
msgid "use_synth_defaults cutoff: 90"
msgstr ""

#: use_synth_defaults.md:42 with_synth_defaults.md:44
msgid "# plays note 50 with default arguments"
msgstr ""

#: use_synth_defaults.md:46
msgid "# plays note 50 with an amp of 0.5, cutoff of 70 and defaults for rest of args"
msgstr ""

#: use_synth_defaults.md:50
msgid ""
"# plays note 50 with a cutoff of 90 and defaults for rest of args - note that "
"amp is no longer 0.5"
msgstr ""

#: use_timing_guarantees.md:9
msgid ""
"If set to true, synths will not trigger if it is too late. If false, some synt"
"h triggers may be late."
msgstr ""

#: use_timing_guarantees.md:23
msgid "use_timing_guarantees true"
msgstr ""

#: use_timing_guarantees.md:38 with_timing_guarantees.md:36
msgid "#=> if time is behind by any margin, this will not trigger"
msgstr ""

#: use_timing_guarantees.md:69 with_timing_guarantees.md:66
msgid "#=> unless time is too far behind, this will trigger even when late."
msgstr ""

#: use_transpose.md:9
msgid ""
"Transposes your music by shifting all notes played by the specified amount. To"
" shift up by a semitone use a transpose of 1. To shift down use negative numbe"
"rs. See `with_transpose` for setting the transpose value only for a specific `"
"do`/`end` block. To transpose entire octaves see `use_octave`."
msgstr ""

#: use_transpose.md:24
msgid "use_transpose 1"
msgstr ""

#: use_transpose.md:38
msgid "# Plays note 51"
msgstr ""

#: use_transpose.md:75 with_transpose.md:45
msgid "# Plays note 65"
msgstr ""

#: use_tuning.md:9
msgid ""
"In most music we make semitones by dividing the octave into 12 equal parts, wh"
"ich is known as equal temperament. However there are lots of other ways to tun"
"e the 12 notes. This method adjusts each midi note into the specified tuning s"
"ystem. Because the ratios between notes aren't always equal, be careful to pic"
"k a centre note that is in the key of the music you're making for the best sou"
"nd. Currently available tunings are `:just`, `:pythagorean`, `:meantone` and t"
"he default of `:equal`"
msgstr ""

#: use_tuning.md:23 use_tuning.md:25 with_tuning.md:24 with_tuning.md:31
msgid "play :e4"
msgstr ""

#: use_tuning.md:24
msgid "use_tuning :just, :c"
msgstr ""

#: use_tuning.md:27
msgid "play 64"
msgstr ""

#: use_tuning.md:38 use_tuning.md:75 use_tuning.md:79 with_tuning.md:43
#: with_tuning.md:50
msgid "# Plays note 64"
msgstr ""

#: use_tuning.md:40 use_tuning.md:42 use_tuning.md:77 with_tuning.md:45
msgid "# Plays note 63.8631"
msgstr ""

#: use_tuning.md:41
msgid "# transparently changes midi notes too"
msgstr ""

#: use_tuning.md:74
msgid "# You may change the tuning multiple times:"
msgstr ""

#: vector.md:9
msgid "Create a new immutable vector from args. Out of range indexes return nil."
msgstr ""

#: vector.md:23
msgid "(vector 1, 2, 3)[0]"
msgstr ""

#: version.md:9
msgid ""
"Return information representing the current version of Sonic Pi. This informat"
"ion may be further inspected with `version.major`, `version.minor`, `version.p"
"atch` and `version.dev`"
msgstr ""

#: version.md:23
msgid "puts version"
msgstr ""

#: version.md:34
msgid "# => Prints out the current version such as v2.0.1"
msgstr ""

#: version.md:61
msgid "# => Prints out the major version number such as 2"
msgstr ""

#: version.md:88
msgid "# => Prints out the minor version number such as 0"
msgstr ""

#: version.md:115
msgid "# => Prints out the patch level for this version such as 0"
msgstr ""

#: vt.md:9
msgid "Get the virtual time of the current thread."
msgstr ""

#: vt.md:23
msgid "puts vt"
msgstr ""

#: vt.md:24
msgid "   sleep 1"
msgstr ""

#: vt.md:25
msgid "   puts vt"
msgstr ""

#: vt.md:36
msgid "# prints 0"
msgstr ""

#: vt.md:38
msgid "# prints 1"
msgstr ""

#: wait.md:9
msgid "Synonym for `sleep` - see `sleep`"
msgstr ""

#: with_arg_bpm_scaling.md:9
msgid ""
"Turn synth argument bpm scaling on or off for the supplied block. Note, using "
"`rt` for args will result in incorrect times when used within this block."
msgstr ""

#: with_arg_bpm_scaling.md:25
msgid "with_arg_bpm_scaling false do"
msgstr ""

#: with_arg_bpm_scaling.md:26
msgid "  play 50, release: 2"
msgstr ""

#: with_arg_checks.md:9
msgid ""
"Similar to `use_arg_checks` except only applies to code within supplied `do`/`"
"end` block. Previous arg check value is restored after block."
msgstr ""

#: with_arg_checks.md:24
msgid "use_arg_checks true"
msgstr ""

#: with_arg_checks.md:26
msgid "play 80, cutoff: 100"
msgstr ""

#: with_arg_checks.md:28
msgid "with_arg_checks false do"
msgstr ""

#: with_arg_checks.md:30
msgid "  play 50, release: 3"
msgstr ""

#: with_arg_checks.md:32
msgid "  play 72            "
msgstr ""

#: with_arg_checks.md:36 with_debug.md:36
msgid "play 90"
msgstr ""

#: with_arg_checks.md:47
msgid "# Turn on arg checking:"
msgstr ""

#: with_arg_checks.md:53
msgid "#Arg checking is now disabled"
msgstr ""

#: with_arg_checks.md:56
msgid "# Arg is not checked"
msgstr ""

#: with_arg_checks.md:59
msgid "# Arg checking is re-enabled"
msgstr ""

#: with_bpm.md:9
msgid ""
"Sets the tempo in bpm (beats per minute) for everything in the given block. Af"
"fects all containing calls to `sleep` and all temporal synth arguments which w"
"ill be scaled to match the new bpm. See also `use_bpm`"
msgstr ""

#: with_bpm.md:20
msgid "  "
msgstr ""

#: with_bpm.md:36 with_bpm.md:55
msgid "    sample :drum_bass_hard"
msgstr ""

#: with_bpm.md:44
msgid "  with_bpm 120 do "
msgstr ""

#: with_bpm.md:45
msgid "    4.times do"
msgstr ""

#: with_bpm.md:46
msgid "      sample :drum_bass_hard"
msgstr ""

#: with_bpm.md:47
msgid "      sleep 1"
msgstr ""

#: with_bpm.md:48
msgid "    end"
msgstr ""

#: with_bpm.md:70 with_bpm.md:89
msgid "# sleeps for 1 second"
msgstr ""

#: with_bpm.md:73
msgid "# sleeps for 5 seconds"
msgstr ""

#: with_bpm.md:75
msgid "# with_bpm sets a tempo for everything between do ... end (a block)"
msgstr ""

#: with_bpm.md:76
msgid "# Hear how it gets faster?"
msgstr ""

#: with_bpm.md:77
msgid "# set bpm to be twice as fast"
msgstr ""

#: with_bpm.md:80
msgid "# now sleeps for 0.5 seconds"
msgstr ""

#: with_bpm.md:86
msgid "# bpm goes back to normal"
msgstr ""

#: with_bpm_mul.md:9
msgid ""
"Sets the tempo in bpm (beats per minute) for everything in the given block as "
"a multiplication of the current tempo. Affects all containing calls to `sleep`"
" and all temporal synth arguments which will be scaled to match the new bpm. S"
"ee also `with_bpm`"
msgstr ""

#: with_bpm_mul.md:28
msgid "  with_bpm_mul 0.5 do"
msgstr ""

#: with_bpm_mul.md:30
msgid "    sleep 1          "
msgstr ""

#: with_bpm_mul.md:33
msgid "  sleep 1           "
msgstr ""

#: with_bpm_mul.md:46
msgid "# Sleeps for 1 second"
msgstr ""

#: with_bpm_mul.md:54
msgid "# BPM is now back to 60, therefore sleep is 1 second"
msgstr ""

#: with_cent_tuning.md:9
msgid ""
"Similar to `use_cent_tuning` except only applies cent shift to code within sup"
"plied `do`/`end` block. Previous cent tuning value is restored after block. On"
"e semitone consists of 100 cents. To transpose entire semitones see `with_tran"
"spose`."
msgstr ""

#: with_cent_tuning.md:26
msgid "with_cent_tuning 2 do"
msgstr ""

#: with_cent_tuning.md:46
msgid "# Plays note 50.02"
msgstr ""

#: with_cent_tuning.md:49
msgid "# Original cent tuning value is restored"
msgstr ""

#: with_cue_logging.md:9
msgid ""
"Similar to use_cue_logging except only applies to code within supplied `do`/`e"
"nd` block. Previous cue log value is restored after block."
msgstr ""

#: with_cue_logging.md:24
msgid "  use_cue_logging true"
msgstr ""

#: with_cue_logging.md:28
msgid "  with_cue_logging false do"
msgstr ""

#: with_cue_logging.md:29 with_midi_logging.md:29 with_osc_logging.md:29
msgid "   "
msgstr ""

#: with_cue_logging.md:30
msgid "    cue :bar"
msgstr ""

#: with_cue_logging.md:34
msgid "  cue :quux"
msgstr ""

#: with_cue_logging.md:45 with_debug.md:47
msgid "# Turn on debugging:"
msgstr ""

#: with_cue_logging.md:48
msgid "# cue message is printed to log"
msgstr ""

#: with_cue_logging.md:51
msgid "#Cue logging is now disabled"
msgstr ""

#: with_cue_logging.md:52
msgid "# cue *is* sent but not displayed in log"
msgstr ""

#: with_cue_logging.md:55 with_debug.md:59 with_midi_logging.md:55
#: with_osc_logging.md:55
msgid "# Debug is re-enabled"
msgstr ""

#: with_cue_logging.md:56
msgid "# cue is displayed in log"
msgstr ""

#: with_debug.md:9
msgid ""
"Similar to use_debug except only applies to code within supplied `do`/`end` bl"
"ock. Previous debug value is restored after block."
msgstr ""

#: with_debug.md:26 with_transpose.md:33
msgid "play 80"
msgstr ""

#: with_debug.md:28
msgid "with_debug false do"
msgstr ""

#: with_debug.md:50 with_debug.md:60
msgid "# Debug message is sent"
msgstr ""

#: with_debug.md:53
msgid "#Debug is now disabled"
msgstr ""

#: with_debug.md:54 with_debug.md:56
msgid "# Debug message is not sent"
msgstr ""

#: with_fx.md:9
msgid ""
"This applies the named effect (FX) to everything within a given `do`/`end` blo"
"ck. Effects may take extra parameters to modify their behaviour. See FX help f"
"or parameter details."
msgstr ""

#: with_fx.md:11
msgid ""
"For advanced control, it is also possible to modify the parameters of an effec"
"t within the body of the block. If you define the block with a single argument"
", the argument becomes a reference to the current effect and can be used to co"
"ntrol its parameters (see examples)."
msgstr ""

#: with_fx.md:26
msgid "with_fx :distortion do"
msgstr ""

#: with_fx.md:41
msgid "# Use the distortion effect with default parameters"
msgstr ""

#: with_fx.md:42
msgid "# => plays note 50 with distortion"
msgstr ""

#: with_fx.md:44
msgid "# => plays the loop_amen sample with distortion too"
msgstr ""

#: with_fx.md:76
msgid "# Specify effect parameters"
msgstr ""

#: with_fx.md:77
msgid "# Use the level effect with the amp parameter set to 0.3"
msgstr ""

#: with_fx.md:122
msgid "# Controlling the effect parameters within the block"
msgstr ""

#: with_fx.md:124
msgid "# here we set the reverb level quite low to start with (0.1)"
msgstr ""

#: with_fx.md:125
msgid "# and we can change it later by using the 'fx' reference we've set up"
msgstr ""

#: with_fx.md:127
msgid "# plays note 60 with a little bit of reverb"
msgstr ""

#: with_fx.md:130 with_fx.md:134
msgid "# change the parameters of the effect to add more reverb"
msgstr ""

#: with_fx.md:131
msgid "# again note 60 but with more reverb"
msgstr ""

#: with_fx.md:135
msgid "# plays note 60 with loads of reverb"
msgstr ""

#: with_fx.md:175
msgid "# Repeat the block 16 times internally"
msgstr ""

#: with_fx.md:181
msgid "# The above is a shorthand for this:"
msgstr ""

#: with_merged_midi_defaults.md:9
msgid ""
"Specify opt values to be used by any following call to the `midi_*` fns within"
" the specified `do`/`end` block. Merges the specified values with any previous"
" midi defaults, rather than replacing them. After the `do`/`end` block has com"
"pleted, previous defaults (if any) are restored."
msgstr ""

#: with_merged_midi_defaults.md:29
msgid "with_merged_midi_defaults channel: 1 do"
msgstr ""

#: with_merged_midi_defaults.md:31 with_midi_defaults.md:32
msgid "  midi_note_on :e2"
msgstr ""

#: with_merged_midi_defaults.md:62
msgid "# Sends MIDI :e2 note_on to channel 3 on port \"foo\"."
msgstr ""

#: with_merged_midi_defaults.md:63
msgid "# This is because the previous defaults were restored after"
msgstr ""

#: with_merged_midi_defaults.md:64
msgid "# the call to with_merged_midi_defaults."
msgstr ""

#: with_merged_sample_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `sample` with"
"in the `do`/`end` block.  Merges the specified values with any previous sample"
" defaults, rather than replacing them. After the `do`/`end` block has complete"
"d, the previous sampled defaults (if any) are restored."
msgstr ""

#: with_merged_sample_defaults.md:29
msgid "with_merged_sample_defaults cutoff: 90 do"
msgstr ""

#: with_merged_sample_defaults.md:30 with_sample_defaults.md:30
#: with_timing_guarantees.md:24
msgid "  sample :loop_amen "
msgstr ""

#: with_merged_sample_defaults.md:51
msgid "# plays amen break with a cutoff of 90 and amp of 0.5"
msgstr ""

#: with_merged_sample_defaults.md:54 with_sample_defaults.md:54
msgid ""
"# plays amen break with a cutoff of 70 and amp is 0.5 again as the previous de"
"faults are restored."
msgstr ""

#: with_merged_synth_defaults.md:9
msgid ""
"Specify synth arg values to be used by any following call to play within the s"
"pecified `do`/`end` block. Merges the specified values with any previous synth"
" defaults, rather than replacing them. After the `do`/`end` block has complete"
"d, previous defaults (if any) are restored."
msgstr ""

#: with_merged_synth_defaults.md:23
msgid "with_merged_synth_defaults amp: 0.5, pan: 1 do"
msgstr ""

#: with_merged_synth_defaults.md:36
msgid "# => plays note 50 with amp 0.5 and pan 1"
msgstr ""

#: with_merged_synth_defaults.md:73
msgid "#=> plays note 50"
msgstr ""

#: with_merged_synth_defaults.md:75 with_merged_synth_defaults.md:82
msgid "#=> plays note 50 with amp 0.5"
msgstr ""

#: with_merged_synth_defaults.md:79
msgid "#=> plays note 50 with amp 0.7 and pan -1"
msgstr ""

#: with_midi_defaults.md:9
msgid ""
"Specify new default values to be used by all calls to `midi_*` fns within the "
"`do`/`end` block. After the `do`/`end` block has completed the previous MIDI d"
"efaults (if any) are restored."
msgstr ""

#: with_midi_defaults.md:25
msgid "with_midi_defaults channel: 3, port: \"foo\" do"
msgstr ""

#: with_midi_defaults.md:26
msgid "  midi_note_on :e3"
msgstr ""

#: with_midi_defaults.md:29
msgid "use_midi_defaults channel: 1  "
msgstr ""

#: with_midi_defaults.md:31
msgid "with_midi_defaults channel: 5 do"
msgstr ""

#: with_midi_defaults.md:36
msgid "  midi_note_on :e4"
msgstr ""

#: with_midi_defaults.md:48
msgid "# Sends MIDI :e1 note on with default opts"
msgstr ""

#: with_midi_defaults.md:51
msgid "# Sends MIDI :e3 note on to channel 3 on port \"foo\""
msgstr ""

#: with_midi_defaults.md:54
msgid "# this will be overridden by the following"
msgstr ""

#: with_midi_defaults.md:57
msgid "# Sends MIDI :e2 note on to channel 5."
msgstr ""

#: with_midi_defaults.md:58
msgid "# Note that the port is back to the default"
msgstr ""

#: with_midi_defaults.md:61
msgid "# Sends MIDI :e4 note on to channel 1"
msgstr ""

#: with_midi_defaults.md:62
msgid "# Note that the call to use_midi_defaults is now honoured."
msgstr ""

#: with_midi_logging.md:9
msgid ""
"Similar to use_midi_logging except only applies to code within supplied `do`/`"
"end` block. Previous MIDI log value is restored after block."
msgstr ""

#: with_midi_logging.md:24
msgid "  use_midi_logging true"
msgstr ""

#: with_midi_logging.md:26
msgid "  midi :e1"
msgstr ""

#: with_midi_logging.md:28
msgid "  with_midi_logging false do"
msgstr ""

#: with_midi_logging.md:30
msgid "    midi :f2"
msgstr ""

#: with_midi_logging.md:34
msgid "  midi :G3"
msgstr ""

#: with_midi_logging.md:45
msgid "# Turn on MIDI logging:"
msgstr ""

#: with_midi_logging.md:48 with_osc_logging.md:48
msgid "#  message is printed to log"
msgstr ""

#: with_midi_logging.md:51
msgid "#MIDI logging is now disabled"
msgstr ""

#: with_midi_logging.md:52
msgid "# MIDI message *is* sent but not displayed in log"
msgstr ""

#: with_midi_logging.md:56 with_osc_logging.md:56
msgid "# message is displayed in log"
msgstr ""

#: with_octave.md:9
msgid ""
"Transposes your music by shifting all notes played by the specified number of "
"octaves within the specified block. To shift up by an octave use a transpose o"
"f 1. To shift down use negative numbers. For transposing the notes within the "
"octave range see `with_transpose`."
msgstr ""

#: with_octave.md:25
msgid "with_octave 1 do"
msgstr ""

#: with_octave.md:26
msgid " play 50"
msgstr ""

#: with_osc.md:9
msgid ""
"Sets the destination host and port that `osc` will send messages to for the gi"
"ven do/end block."
msgstr ""

#: with_osc.md:24 with_osc.md:31
msgid "osc \"/foo/baz\"            "
msgstr ""

#: with_osc.md:26
msgid "with_osc \"localhost\", 7010 do"
msgstr ""

#: with_osc.md:27
msgid "                               "
msgstr ""

#: with_osc.md:28
msgid "   osc \"/foo/baz\"            "
msgstr ""

#: with_osc.md:47
msgid "# set hostname and port for the duration"
msgstr ""

#: with_osc.md:48
msgid "# of this do/end block"
msgstr ""

#: with_osc.md:53
msgid "# as old setting is restored outside"
msgstr ""

#: with_osc.md:54
msgid "# do/end block"
msgstr ""

#: with_osc_logging.md:9
msgid ""
"Similar to use_osc_logging except only applies to code within supplied `do`/`e"
"nd` block. Previous OSC log value is restored after block."
msgstr ""

#: with_osc_logging.md:24
msgid "  use_osc_logging true"
msgstr ""

#: with_osc_logging.md:26 with_osc_logging.md:34
msgid "  osc \"/foo\""
msgstr ""

#: with_osc_logging.md:28
msgid "  with_osc_logging false do"
msgstr ""

#: with_osc_logging.md:30
msgid "    osc \"/foo\""
msgstr ""

#: with_osc_logging.md:45
msgid "# Turn on OSC logging:"
msgstr ""

#: with_osc_logging.md:51
msgid "#OSC logging is now disabled"
msgstr ""

#: with_osc_logging.md:52
msgid "# OSC message *is* sent but not displayed in log"
msgstr ""

#: with_random_seed.md:9
msgid ""
"Resets the random number generator to the specified seed for the specified cod"
"e block. All generated random numbers and randomisation functions such as `shu"
"ffle` and `choose` within the code block will use this new generator. Once the"
" code block has completed, the original generator is restored and the code blo"
"ck generator is discarded. Use this to change the sequence of random numbers i"
"n your piece in a way that can be reproduced. Especially useful if combined wi"
"th iteration. See examples."
msgstr ""

#: with_random_seed.md:23
msgid "use_random_seed 1"
msgstr ""

#: with_random_seed.md:28
msgid "  with_random_seed 1 do"
msgstr ""

#: with_random_seed.md:46 with_random_seed.md:51
msgid "#=> 0.7203244934421581"
msgstr ""

#: with_random_seed.md:47
msgid "# reset it back to 1"
msgstr ""

#: with_random_seed.md:49
msgid "# reset seed back to 1 just for this block"
msgstr ""

#: with_random_seed.md:53
msgid "# => 0.7203244934421581"
msgstr ""

#: with_random_seed.md:54
msgid "# notice how the original generator is restored"
msgstr ""

#: with_random_seed.md:135
msgid "# Note that this line is outside of"
msgstr ""

#: with_random_seed.md:136
msgid "# the with_random_seed block and therefore"
msgstr ""

#: with_random_seed.md:137
msgid "# the randomisation never gets reset and this"
msgstr ""

#: with_random_seed.md:138
msgid "# part of the melody never repeats."
msgstr ""

#: with_random_source.md:9
msgid ""
"Resets the random number generator to the specified noise type for the specifi"
"ed code block. All generated random numbers and randomisation functions such a"
"s `shuffle` and `choose` within the code block will use this new generator. On"
"ce the code block has completed, the original generator is restored and the co"
"de block generator is discarded. Use this to change the sequence of random num"
"bers in your piece in a way that can be reproduced. Especially useful if combi"
"ned with iteration. See examples."
msgstr ""

#: with_real_time.md:11
msgid ""
"Sets sched ahead time to 0 within the block for the current thread. Shorthand "
"for `with_sched_ahead_time 0`."
msgstr ""

#: with_real_time.md:13
msgid ""
"See `with_sched_ahead_time` for a version of this function which allows you to"
" set the schedule ahead time to any arbitrary value. Note, `with_real_time` wi"
"ll override any value set with `set_sched_ahead_time!` for the current thread."
msgstr ""

#: with_sample_bpm.md:9
msgid ""
"Block-scoped modification of bpm so that sleeping for 1 will sleep for the dur"
"ation of the sample."
msgstr ""

#: with_sample_bpm.md:24
msgid "  with_sample_bpm :loop_amen do"
msgstr ""

#: with_sample_bpm.md:25
msgid "    sample :bass_dnb_f"
msgstr ""

#: with_sample_bpm.md:26
msgid "    sample :loop_amen"
msgstr ""

#: with_sample_bpm.md:27
msgid "    sleep 1                    "
msgstr ""

#: with_sample_bpm.md:43
msgid "#`sleep`ing for 1 sleeps for duration of :loop_amen"
msgstr ""

#: with_sample_bpm.md:87
msgid "#`sleep`ing for 4 sleeps for duration of :loop_amen"
msgstr ""

#: with_sample_defaults.md:9
msgid ""
"Specify new default values to be used by all subsequent calls to `sample` with"
"in the `do`/`end` block. After the `do`/`end` block has completed, the previou"
"s sampled defaults (if any) are restored. For the contents of the block, will "
"remove and override any previous defaults."
msgstr ""

#: with_sample_defaults.md:29
msgid "with_sample_defaults cutoff: 90 do"
msgstr ""

#: with_sched_ahead_time.md:9
msgid ""
"Specify how many seconds ahead of time the synths should be triggered for the "
"block. See `use_sched_ahead_time` for further information."
msgstr ""

#: with_sched_ahead_time.md:11
msgid ""
"See `set_sched_ahead_time!` for a global version of this function. Note, `with"
"_sched_ahead_time` will override any value set with `set_sched_ahead_time!` fo"
"r the given block within the current thread."
msgstr ""

#: with_sched_ahead_time.md:13
msgid "See `with_real_time` for a simple way of setting the schedule ahead time to 0."
msgstr ""

#: with_sched_ahead_time.md:27
msgid "with_sched_ahead_time 1 do"
msgstr ""

#: with_sched_ahead_time.md:28
msgid "  play 70 "
msgstr ""

#: with_sched_ahead_time.md:31
msgid "play 70 "
msgstr ""

#: with_sched_ahead_time.md:43
msgid "# Sound will happen with a latency of 1"
msgstr ""

#: with_sched_ahead_time.md:46
msgid "# Sound will happen with the default latency (0.5s)"
msgstr ""

#: with_swing.md:9
msgid ""
"Runs block within a `time_warp` except for once every `pulse` consecutive runs"
" (defaulting to 4). When used for rhythmical purposes this results in one in e"
"very `pulse` calls of the block being 'on beat' and the rest shifted forward o"
"r backwards in time by `shift` beats."
msgstr ""

#: with_swing.md:23
msgid "live_loop :foo do"
msgstr ""

#: with_swing.md:24
msgid "  with_swing 0.1 do"
msgstr ""

#: with_swing.md:25
msgid "    sample :elec_beep     "
msgstr ""

#: with_swing.md:27
msgid "  sleep 0.25"
msgstr ""

#: with_swing.md:40
msgid "# plays the :elec_beep sample late except for every 4th time"
msgstr ""

#: with_swing.md:76 with_swing.md:112
msgid "# plays the :elec_beep sample slightly early"
msgstr ""

#: with_swing.md:77 with_swing.md:157
msgid "# except for every 4th time"
msgstr ""

#: with_swing.md:113
msgid "# except for every 8th time"
msgstr ""

#: with_swing.md:152
msgid "# Use unique tick names if you plan on using with_swing"
msgstr ""

#: with_swing.md:153
msgid "# more than once in any given live_loop or thread."
msgstr ""

#: with_swing.md:156
msgid "# plays the :elec_beep sample slightly late"
msgstr ""

#: with_swing.md:160
msgid "# plays the :elec_beep sample at double rate"
msgstr ""

#: with_swing.md:161
msgid "#  slightly early except for every 4th time"
msgstr ""

#: with_swing.md:203
msgid "# send out cue messages with swing timing"
msgstr ""

#: with_swing.md:210
msgid "# sync on the swing cue messages to bring the swing into"
msgstr ""

#: with_swing.md:211
msgid "# another live loop (sync will match the timing and clock of"
msgstr ""

#: with_swing.md:212
msgid "# the sending live loop)"
msgstr ""

#: with_synth.md:9
msgid ""
"Switch the current synth to `synth_name` but only for the duration of the `do`"
"/`end` block. After the `do`/`end` block has completed, the previous synth is "
"restored."
msgstr ""

#: with_synth.md:25
msgid "use_synth :supersaw"
msgstr ""

#: with_synth.md:28
msgid "with_synth :saw_beep do"
msgstr ""

#: with_synth.md:47 with_synth.md:54
msgid "# Plays with supersaw synth"
msgstr ""

#: with_synth.md:50
msgid "# Plays with saw_beep synth"
msgstr ""

#: with_synth.md:53
msgid "# Previous synth is restored"
msgstr ""

#: with_synth_defaults.md:9
msgid ""
"Specify new default values to be used by all calls to `play` within the `do`/`"
"end` block. After the `do`/`end` block has completed the previous synth defaul"
"ts (if any) are restored."
msgstr ""

#: with_synth_defaults.md:25
msgid "use_synth_defaults amp: 0.5, pan: -1"
msgstr ""

#: with_synth_defaults.md:29
msgid "with_synth_defaults amp: 0.6, cutoff: 80 do"
msgstr ""

#: with_synth_defaults.md:33
msgid "play 60"
msgstr ""

#: with_synth_defaults.md:48
msgid "# plays note 50 with an amp of 0.5, pan of -1 and defaults for rest of args"
msgstr ""

#: with_synth_defaults.md:51
msgid ""
"# plays note 50 with an amp of 0.6, cutoff of 80 and defaults for rest of args"
" (including pan)"
msgstr ""

#: with_synth_defaults.md:54
msgid "# plays note 60 with an amp of 0.5, pan of -1 and defaults for rest of args"
msgstr ""

#: with_timing_guarantees.md:9
msgid ""
"For the given block, if set to true, synths will not trigger if it is too late"
". If false, some synth triggers may be late. After the block has completed, th"
"e previous value is restored. "
msgstr ""

#: with_timing_guarantees.md:23
msgid "with_timing_guarantees true do"
msgstr ""

#: with_transpose.md:9
msgid ""
"Similar to use_transpose except only applies to code within supplied `do`/`end"
"` block. Previous transpose value is restored after block. To transpose entire"
" octaves see `with_octave`."
msgstr ""

#: with_transpose.md:23
msgid "use_transpose 3"
msgstr ""

#: with_transpose.md:24
msgid "play 62"
msgstr ""

#: with_transpose.md:26
msgid "with_transpose 12 do"
msgstr ""

#: with_transpose.md:50
msgid "# Plays note 84"
msgstr ""

#: with_transpose.md:53
msgid "# Original transpose value is restored"
msgstr ""

#: with_transpose.md:54
msgid "# Plays note 83"
msgstr ""

#: with_tuning.md:9
msgid ""
"Similar to use_tuning except only applies to code within supplied `do`/`end` b"
"lock. Previous tuning value is restored after block."
msgstr ""

#: with_tuning.md:23
msgid "use_tuning :equal, :c"
msgstr ""

#: with_tuning.md:25
msgid "with_tuning :just, :c do"
msgstr ""

#: with_tuning.md:26
msgid "  play :e4"
msgstr ""

#: with_tuning.md:28
msgid "  play :c4"
msgstr ""

#: with_tuning.md:47
msgid "# Plays note 60"
msgstr ""

#: with_tuning.md:49
msgid "# Original tuning value is restored"
msgstr ""
